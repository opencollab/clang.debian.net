DC-Build-Header: octave-interval 3.2.0-5 / 2020-02-25 11:50:00 +0000
DC-Task: type:rebuild-binarch-only source:octave-interval version:3.2.0-5 chroot:unstable esttime:2260 logfile:/tmp/octave-interval_3.2.0-5_unstable_clang9.log modes:clang9:binarch-only
DC-Sbuild-call: su user42 -c 'sbuild -n --arch-any --apt-update -d unstable -v --no-run-lintian --chroot-setup-commands=/tmp/clang9 octave-interval_3.2.0-5'
sbuild (Debian sbuild) 0.78.1 (09 February 2019) on ip-172-31-11-224.eu-central-1.compute.internal

+==============================================================================+
| octave-interval 3.2.0-5 (amd64)              Tue, 25 Feb 2020 11:50:00 +0000 |
+==============================================================================+

Package: octave-interval
Version: 3.2.0-5
Source Version: 3.2.0-5
Distribution: unstable
Machine Architecture: amd64
Host Architecture: amd64
Build Architecture: amd64
Build Type: binary

I: NOTICE: Log filtering will replace 'var/run/schroot/mount/sid-amd64-sbuild-6493c03f-eb65-43df-b060-bda47e8bbf49' with '<<CHROOT>>'

+------------------------------------------------------------------------------+
| Chroot Setup Commands                                                        |
+------------------------------------------------------------------------------+


/tmp/clang9
-----------

+ echo 'Entering customization script...'
Entering customization script...
+ CLANG_VERSION=9
+ echo 'Install of clang-9'
Install of clang-9
+ apt-get update
Get:1 http://127.0.0.1:12990/debian sid InRelease [142 kB]
Get:2 http://127.0.0.1:12990/debian sid/main Sources.diff/Index [27.9 kB]
Get:3 http://127.0.0.1:12990/debian sid/main amd64 Packages.diff/Index [27.9 kB]
Get:4 http://127.0.0.1:12990/debian sid/main Sources 2020-02-24-0823.32.pdiff [11.0 kB]
Get:5 http://127.0.0.1:12990/debian sid/main Sources 2020-02-24-1420.34.pdiff [30.2 kB]
Get:6 http://127.0.0.1:12990/debian sid/main Sources 2020-02-24-2014.03.pdiff [16.9 kB]
Get:7 http://127.0.0.1:12990/debian sid/main Sources 2020-02-25-0213.11.pdiff [23.2 kB]
Get:8 http://127.0.0.1:12990/debian sid/main Sources 2020-02-25-0815.22.pdiff [9222 B]
Get:9 http://127.0.0.1:12990/debian sid/main amd64 Packages 2020-02-24-0823.32.pdiff [15.5 kB]
Get:10 http://127.0.0.1:12990/debian sid/main amd64 Packages 2020-02-24-1420.34.pdiff [27.5 kB]
Get:11 http://127.0.0.1:12990/debian sid/main amd64 Packages 2020-02-24-2014.03.pdiff [21.6 kB]
Get:8 http://127.0.0.1:12990/debian sid/main Sources 2020-02-25-0815.22.pdiff [9222 B]
Get:12 http://127.0.0.1:12990/debian sid/main amd64 Packages 2020-02-25-0213.11.pdiff [35.0 kB]
Get:13 http://127.0.0.1:12990/debian sid/main amd64 Packages 2020-02-25-0815.22.pdiff [20.1 kB]
Get:13 http://127.0.0.1:12990/debian sid/main amd64 Packages 2020-02-25-0815.22.pdiff [20.1 kB]
Get:14 http://127.0.0.1:12990/debian sid/main Translation-en [6195 kB]
Fetched 6604 kB in 2s (3509 kB/s)
Reading package lists...
+ apt-get install --yes --no-install-recommends --force-yes clang-9 libomp-9-dev libobjc-9-dev
Reading package lists...
Building dependency tree...
The following additional packages will be installed:
  cpp-9 g++-9 gcc-8-base gcc-9 gcc-9-base lib32gcc-s1 lib32gcc1 lib32stdc++6
  libasan5 libbsd0 libc6-i386 libclang-common-9-dev libclang-cpp9 libedit2
  libgc1c2 libgcc-8-dev libgcc-9-dev libllvm9 libmpx2 libobjc-8-dev libobjc4
  libomp5-9 libstdc++-8-dev libstdc++-9-dev libz3-4
Suggested packages:
  clang-9-doc gcc-9-locales g++-9-multilib gcc-9-doc gcc-9-multilib
  libomp-9-doc libstdc++-8-doc libstdc++-9-doc
Recommended packages:
  llvm-9-dev python3
The following NEW packages will be installed:
  clang-9 gcc-8-base lib32gcc-s1 lib32gcc1 lib32stdc++6 libbsd0 libc6-i386
  libclang-common-9-dev libclang-cpp9 libedit2 libgc1c2 libgcc-8-dev libllvm9
  libmpx2 libobjc-8-dev libobjc-9-dev libobjc4 libomp-9-dev libomp5-9
  libstdc++-8-dev libz3-4
The following packages will be upgraded:
  cpp-9 g++-9 gcc-9 gcc-9-base libasan5 libgcc-9-dev libstdc++-9-dev
7 upgraded, 21 newly installed, 0 to remove and 2 not upgraded.
Need to get 78.9 MB of archives.
After this operation, 237 MB of additional disk space will be used.
Get:1 http://127.0.0.1:12990/debian sid/main amd64 libasan5 amd64 9.2.1-30 [389 kB]
Get:2 http://127.0.0.1:12990/debian sid/main amd64 g++-9 amd64 9.2.1-30 [10.7 MB]
Get:3 http://127.0.0.1:12990/debian sid/main amd64 gcc-9 amd64 9.2.1-30 [10.0 MB]
Get:4 http://127.0.0.1:12990/debian sid/main amd64 libstdc++-9-dev amd64 9.2.1-30 [1697 kB]
Get:5 http://127.0.0.1:12990/debian sid/main amd64 libgcc-9-dev amd64 9.2.1-30 [2349 kB]
Get:6 http://127.0.0.1:12990/debian sid/main amd64 cpp-9 amd64 9.2.1-30 [9711 kB]
Get:7 http://127.0.0.1:12990/debian sid/main amd64 gcc-9-base amd64 9.2.1-30 [196 kB]
Get:8 http://127.0.0.1:12990/debian sid/main amd64 libbsd0 amd64 0.10.0-1 [107 kB]
Get:9 http://127.0.0.1:12990/debian sid/main amd64 libedit2 amd64 3.1-20191231-1 [95.4 kB]
Get:10 http://127.0.0.1:12990/debian sid/main amd64 libz3-4 amd64 4.8.7-4 [6790 kB]
Get:11 http://127.0.0.1:12990/debian sid/main amd64 libllvm9 amd64 1:9.0.1-8 [15.0 MB]
Get:12 http://127.0.0.1:12990/debian sid/main amd64 libclang-cpp9 amd64 1:9.0.1-8 [8429 kB]
Get:13 http://127.0.0.1:12990/debian sid/main amd64 gcc-8-base amd64 8.3.0-29 [194 kB]
Get:14 http://127.0.0.1:12990/debian sid/main amd64 libmpx2 amd64 8.3.0-29 [11.4 kB]
Get:15 http://127.0.0.1:12990/debian sid/main amd64 libgcc-8-dev amd64 8.3.0-29 [2297 kB]
Get:16 http://127.0.0.1:12990/debian sid/main amd64 libstdc++-8-dev amd64 8.3.0-29 [1543 kB]
Get:17 http://127.0.0.1:12990/debian sid/main amd64 libgc1c2 amd64 1:7.6.4-0.4 [224 kB]
Get:18 http://127.0.0.1:12990/debian sid/main amd64 libobjc4 amd64 10-20200222-1 [41.6 kB]
Get:19 http://127.0.0.1:12990/debian sid/main amd64 libobjc-8-dev amd64 8.3.0-29 [227 kB]
Get:20 http://127.0.0.1:12990/debian sid/main amd64 libc6-i386 amd64 2.29-10 [2918 kB]
Get:21 http://127.0.0.1:12990/debian sid/main amd64 lib32gcc-s1 amd64 10-20200222-1 [49.4 kB]
Get:22 http://127.0.0.1:12990/debian sid/main amd64 lib32gcc1 amd64 1:10-20200222-1 [1104 B]
Get:23 http://127.0.0.1:12990/debian sid/main amd64 lib32stdc++6 amd64 10-20200222-1 [510 kB]
Get:24 http://127.0.0.1:12990/debian sid/main amd64 libclang-common-9-dev amd64 1:9.0.1-8 [3727 kB]
Get:25 http://127.0.0.1:12990/debian sid/main amd64 clang-9 amd64 1:9.0.1-8 [1156 kB]
Get:26 http://127.0.0.1:12990/debian sid/main amd64 libobjc-9-dev amd64 9.2.1-30 [219 kB]
Get:27 http://127.0.0.1:12990/debian sid/main amd64 libomp5-9 amd64 1:9.0.1-8 [333 kB]
Get:28 http://127.0.0.1:12990/debian sid/main amd64 libomp-9-dev amd64 1:9.0.1-8 [66.2 kB]
debconf: delaying package configuration, since apt-utils is not installed
Fetched 78.9 MB in 1s (91.1 MB/s)
(Reading database ... (Reading database ... 5%(Reading database ... 10%(Reading database ... 15%(Reading database ... 20%(Reading database ... 25%(Reading database ... 30%(Reading database ... 35%(Reading database ... 40%(Reading database ... 45%(Reading database ... 50%(Reading database ... 55%(Reading database ... 60%(Reading database ... 65%(Reading database ... 70%(Reading database ... 75%(Reading database ... 80%(Reading database ... 85%(Reading database ... 90%(Reading database ... 95%(Reading database ... 100%(Reading database ... 12119 files and directories currently installed.)
Preparing to unpack .../00-libasan5_9.2.1-30_amd64.deb ...
Unpacking libasan5:amd64 (9.2.1-30) over (9.2.1-29) ...
Preparing to unpack .../01-g++-9_9.2.1-30_amd64.deb ...
Unpacking g++-9 (9.2.1-30) over (9.2.1-29) ...
Preparing to unpack .../02-gcc-9_9.2.1-30_amd64.deb ...
Unpacking gcc-9 (9.2.1-30) over (9.2.1-29) ...
Preparing to unpack .../03-libstdc++-9-dev_9.2.1-30_amd64.deb ...
Unpacking libstdc++-9-dev:amd64 (9.2.1-30) over (9.2.1-29) ...
Preparing to unpack .../04-libgcc-9-dev_9.2.1-30_amd64.deb ...
Unpacking libgcc-9-dev:amd64 (9.2.1-30) over (9.2.1-29) ...
Preparing to unpack .../05-cpp-9_9.2.1-30_amd64.deb ...
Unpacking cpp-9 (9.2.1-30) over (9.2.1-29) ...
Preparing to unpack .../06-gcc-9-base_9.2.1-30_amd64.deb ...
Unpacking gcc-9-base:amd64 (9.2.1-30) over (9.2.1-29) ...
Selecting previously unselected package libbsd0:amd64.
Preparing to unpack .../07-libbsd0_0.10.0-1_amd64.deb ...
Unpacking libbsd0:amd64 (0.10.0-1) ...
Selecting previously unselected package libedit2:amd64.
Preparing to unpack .../08-libedit2_3.1-20191231-1_amd64.deb ...
Unpacking libedit2:amd64 (3.1-20191231-1) ...
Selecting previously unselected package libz3-4:amd64.
Preparing to unpack .../09-libz3-4_4.8.7-4_amd64.deb ...
Unpacking libz3-4:amd64 (4.8.7-4) ...
Selecting previously unselected package libllvm9:amd64.
Preparing to unpack .../10-libllvm9_1%3a9.0.1-8_amd64.deb ...
Unpacking libllvm9:amd64 (1:9.0.1-8) ...
Selecting previously unselected package libclang-cpp9.
Preparing to unpack .../11-libclang-cpp9_1%3a9.0.1-8_amd64.deb ...
Unpacking libclang-cpp9 (1:9.0.1-8) ...
Selecting previously unselected package gcc-8-base:amd64.
Preparing to unpack .../12-gcc-8-base_8.3.0-29_amd64.deb ...
Unpacking gcc-8-base:amd64 (8.3.0-29) ...
Selecting previously unselected package libmpx2:amd64.
Preparing to unpack .../13-libmpx2_8.3.0-29_amd64.deb ...
Unpacking libmpx2:amd64 (8.3.0-29) ...
Selecting previously unselected package libgcc-8-dev:amd64.
Preparing to unpack .../14-libgcc-8-dev_8.3.0-29_amd64.deb ...
Unpacking libgcc-8-dev:amd64 (8.3.0-29) ...
Selecting previously unselected package libstdc++-8-dev:amd64.
Preparing to unpack .../15-libstdc++-8-dev_8.3.0-29_amd64.deb ...
Unpacking libstdc++-8-dev:amd64 (8.3.0-29) ...
Selecting previously unselected package libgc1c2:amd64.
Preparing to unpack .../16-libgc1c2_1%3a7.6.4-0.4_amd64.deb ...
Unpacking libgc1c2:amd64 (1:7.6.4-0.4) ...
Selecting previously unselected package libobjc4:amd64.
Preparing to unpack .../17-libobjc4_10-20200222-1_amd64.deb ...
Unpacking libobjc4:amd64 (10-20200222-1) ...
Selecting previously unselected package libobjc-8-dev:amd64.
Preparing to unpack .../18-libobjc-8-dev_8.3.0-29_amd64.deb ...
Unpacking libobjc-8-dev:amd64 (8.3.0-29) ...
Selecting previously unselected package libc6-i386.
Preparing to unpack .../19-libc6-i386_2.29-10_amd64.deb ...
Unpacking libc6-i386 (2.29-10) ...
Selecting previously unselected package lib32gcc-s1.
Preparing to unpack .../20-lib32gcc-s1_10-20200222-1_amd64.deb ...
Unpacking lib32gcc-s1 (10-20200222-1) ...
Selecting previously unselected package lib32gcc1.
Preparing to unpack .../21-lib32gcc1_1%3a10-20200222-1_amd64.deb ...
Unpacking lib32gcc1 (1:10-20200222-1) ...
Selecting previously unselected package lib32stdc++6.
Preparing to unpack .../22-lib32stdc++6_10-20200222-1_amd64.deb ...
Unpacking lib32stdc++6 (10-20200222-1) ...
Selecting previously unselected package libclang-common-9-dev.
Preparing to unpack .../23-libclang-common-9-dev_1%3a9.0.1-8_amd64.deb ...
Unpacking libclang-common-9-dev (1:9.0.1-8) ...
Selecting previously unselected package clang-9.
Preparing to unpack .../24-clang-9_1%3a9.0.1-8_amd64.deb ...
Unpacking clang-9 (1:9.0.1-8) ...
Selecting previously unselected package libobjc-9-dev:amd64.
Preparing to unpack .../25-libobjc-9-dev_9.2.1-30_amd64.deb ...
Unpacking libobjc-9-dev:amd64 (9.2.1-30) ...
Selecting previously unselected package libomp5-9:amd64.
Preparing to unpack .../26-libomp5-9_1%3a9.0.1-8_amd64.deb ...
Unpacking libomp5-9:amd64 (1:9.0.1-8) ...
Selecting previously unselected package libomp-9-dev.
Preparing to unpack .../27-libomp-9-dev_1%3a9.0.1-8_amd64.deb ...
Unpacking libomp-9-dev (1:9.0.1-8) ...
Setting up libgc1c2:amd64 (1:7.6.4-0.4) ...
Setting up libobjc4:amd64 (10-20200222-1) ...
Setting up libz3-4:amd64 (4.8.7-4) ...
Setting up gcc-8-base:amd64 (8.3.0-29) ...
Setting up libmpx2:amd64 (8.3.0-29) ...
Setting up libc6-i386 (2.29-10) ...
Setting up libbsd0:amd64 (0.10.0-1) ...
Setting up gcc-9-base:amd64 (9.2.1-30) ...
Setting up libomp5-9:amd64 (1:9.0.1-8) ...
Setting up libedit2:amd64 (3.1-20191231-1) ...
Setting up libasan5:amd64 (9.2.1-30) ...
Setting up lib32gcc-s1 (10-20200222-1) ...
Setting up libgcc-8-dev:amd64 (8.3.0-29) ...
Setting up libomp-9-dev (1:9.0.1-8) ...
Setting up cpp-9 (9.2.1-30) ...
Setting up libllvm9:amd64 (1:9.0.1-8) ...
Setting up libstdc++-8-dev:amd64 (8.3.0-29) ...
Setting up libclang-cpp9 (1:9.0.1-8) ...
Setting up lib32gcc1 (1:10-20200222-1) ...
Setting up libgcc-9-dev:amd64 (9.2.1-30) ...
Setting up libobjc-8-dev:amd64 (8.3.0-29) ...
Setting up lib32stdc++6 (10-20200222-1) ...
Setting up libobjc-9-dev:amd64 (9.2.1-30) ...
Setting up libclang-common-9-dev (1:9.0.1-8) ...
Setting up gcc-9 (9.2.1-30) ...
Setting up libstdc++-9-dev:amd64 (9.2.1-30) ...
Setting up clang-9 (1:9.0.1-8) ...
Setting up g++-9 (9.2.1-30) ...
Processing triggers for libc-bin (2.29-10) ...
W: --force-yes is deprecated, use one of the options starting with --allow instead.
+ echo 'Replace gcc, g++ & cpp by clang'
Replace gcc, g++ & cpp by clang
+ VERSIONS='4.6 4.7 4.8 4.9 5 6 7 8 9 10'
+ cd /usr/bin
+ for VERSION in $VERSIONS
+ rm -f g++-4.6 gcc-4.6 cpp-4.6 gcc
+ ln -s clang++-9 g++-4.6
+ ln -s clang-9 gcc-4.6
+ ln -s clang-9 cpp-4.6
+ ln -s clang-9 gcc
+ echo 'gcc-4.6 hold'
+ dpkg --set-selections
dpkg: warning: package not in status nor available database at line 1: gcc-4.6
dpkg: warning: found unknown packages; this might mean the available database
is outdated, and needs to be updated through a frontend method;
please see the FAQ <https://wiki.debian.org/Teams/Dpkg/FAQ>
+ echo 'g++-4.6 hold'
+ dpkg --set-selections
dpkg: warning: package not in status nor available database at line 1: g++-4.6
dpkg: warning: found unknown packages; this might mean the available database
is outdated, and needs to be updated through a frontend method;
please see the FAQ <https://wiki.debian.org/Teams/Dpkg/FAQ>
+ for VERSION in $VERSIONS
+ rm -f g++-4.7 gcc-4.7 cpp-4.7 gcc
+ ln -s clang++-9 g++-4.7
+ ln -s clang-9 gcc-4.7
+ ln -s clang-9 cpp-4.7
+ ln -s clang-9 gcc
+ echo 'gcc-4.7 hold'
+ dpkg --set-selections
dpkg: warning: package not in status nor available database at line 1: gcc-4.7
dpkg: warning: found unknown packages; this might mean the available database
is outdated, and needs to be updated through a frontend method;
please see the FAQ <https://wiki.debian.org/Teams/Dpkg/FAQ>
+ echo 'g++-4.7 hold'
+ dpkg --set-selections
dpkg: warning: package not in status nor available database at line 1: g++-4.7
dpkg: warning: found unknown packages; this might mean the available database
is outdated, and needs to be updated through a frontend method;
please see the FAQ <https://wiki.debian.org/Teams/Dpkg/FAQ>
+ for VERSION in $VERSIONS
+ rm -f g++-4.8 gcc-4.8 cpp-4.8 gcc
+ ln -s clang++-9 g++-4.8
+ ln -s clang-9 gcc-4.8
+ ln -s clang-9 cpp-4.8
+ ln -s clang-9 gcc
+ echo 'gcc-4.8 hold'
+ dpkg --set-selections
dpkg: warning: package not in status nor available database at line 1: gcc-4.8
dpkg: warning: found unknown packages; this might mean the available database
is outdated, and needs to be updated through a frontend method;
please see the FAQ <https://wiki.debian.org/Teams/Dpkg/FAQ>
+ echo 'g++-4.8 hold'
+ dpkg --set-selections
dpkg: warning: package not in status nor available database at line 1: g++-4.8
dpkg: warning: found unknown packages; this might mean the available database
is outdated, and needs to be updated through a frontend method;
please see the FAQ <https://wiki.debian.org/Teams/Dpkg/FAQ>
+ for VERSION in $VERSIONS
+ rm -f g++-4.9 gcc-4.9 cpp-4.9 gcc
+ ln -s clang++-9 g++-4.9
+ ln -s clang-9 gcc-4.9
+ ln -s clang-9 cpp-4.9
+ ln -s clang-9 gcc
+ echo 'gcc-4.9 hold'
+ dpkg --set-selections
dpkg: warning: package not in status nor available database at line 1: gcc-4.9
dpkg: warning: found unknown packages; this might mean the available database
is outdated, and needs to be updated through a frontend method;
please see the FAQ <https://wiki.debian.org/Teams/Dpkg/FAQ>
+ echo 'g++-4.9 hold'
+ dpkg --set-selections
dpkg: warning: package not in status nor available database at line 1: g++-4.9
dpkg: warning: found unknown packages; this might mean the available database
is outdated, and needs to be updated through a frontend method;
please see the FAQ <https://wiki.debian.org/Teams/Dpkg/FAQ>
+ for VERSION in $VERSIONS
+ rm -f g++-5 gcc-5 cpp-5 gcc
+ ln -s clang++-9 g++-5
+ ln -s clang-9 gcc-5
+ ln -s clang-9 cpp-5
+ ln -s clang-9 gcc
+ echo 'gcc-5 hold'
+ dpkg --set-selections
dpkg: warning: package not in status nor available database at line 1: gcc-5
dpkg: warning: found unknown packages; this might mean the available database
is outdated, and needs to be updated through a frontend method;
please see the FAQ <https://wiki.debian.org/Teams/Dpkg/FAQ>
+ echo 'g++-5 hold'
+ dpkg --set-selections
dpkg: warning: package not in status nor available database at line 1: g++-5
dpkg: warning: found unknown packages; this might mean the available database
is outdated, and needs to be updated through a frontend method;
please see the FAQ <https://wiki.debian.org/Teams/Dpkg/FAQ>
+ for VERSION in $VERSIONS
+ rm -f g++-6 gcc-6 cpp-6 gcc
+ ln -s clang++-9 g++-6
+ ln -s clang-9 gcc-6
+ ln -s clang-9 cpp-6
+ ln -s clang-9 gcc
+ echo 'gcc-6 hold'
+ dpkg --set-selections
dpkg: warning: package not in status nor available database at line 1: gcc-6
dpkg: warning: found unknown packages; this might mean the available database
is outdated, and needs to be updated through a frontend method;
please see the FAQ <https://wiki.debian.org/Teams/Dpkg/FAQ>
+ echo 'g++-6 hold'
+ dpkg --set-selections
dpkg: warning: package not in status nor available database at line 1: g++-6
dpkg: warning: found unknown packages; this might mean the available database
is outdated, and needs to be updated through a frontend method;
please see the FAQ <https://wiki.debian.org/Teams/Dpkg/FAQ>
+ for VERSION in $VERSIONS
+ rm -f g++-7 gcc-7 cpp-7 gcc
+ ln -s clang++-9 g++-7
+ ln -s clang-9 gcc-7
+ ln -s clang-9 cpp-7
+ ln -s clang-9 gcc
+ echo 'gcc-7 hold'
+ dpkg --set-selections
dpkg: warning: package not in status nor available database at line 1: gcc-7
dpkg: warning: found unknown packages; this might mean the available database
is outdated, and needs to be updated through a frontend method;
please see the FAQ <https://wiki.debian.org/Teams/Dpkg/FAQ>
+ echo 'g++-7 hold'
+ dpkg --set-selections
dpkg: warning: package not in status nor available database at line 1: g++-7
dpkg: warning: found unknown packages; this might mean the available database
is outdated, and needs to be updated through a frontend method;
please see the FAQ <https://wiki.debian.org/Teams/Dpkg/FAQ>
+ for VERSION in $VERSIONS
+ rm -f g++-8 gcc-8 cpp-8 gcc
+ ln -s clang++-9 g++-8
+ ln -s clang-9 gcc-8
+ ln -s clang-9 cpp-8
+ ln -s clang-9 gcc
+ echo 'gcc-8 hold'
+ dpkg --set-selections
dpkg: warning: package not in status nor available database at line 1: gcc-8
dpkg: warning: found unknown packages; this might mean the available database
is outdated, and needs to be updated through a frontend method;
please see the FAQ <https://wiki.debian.org/Teams/Dpkg/FAQ>
+ echo 'g++-8 hold'
+ dpkg --set-selections
dpkg: warning: package not in status nor available database at line 1: g++-8
dpkg: warning: found unknown packages; this might mean the available database
is outdated, and needs to be updated through a frontend method;
please see the FAQ <https://wiki.debian.org/Teams/Dpkg/FAQ>
+ for VERSION in $VERSIONS
+ rm -f g++-9 gcc-9 cpp-9 gcc
+ ln -s clang++-9 g++-9
+ ln -s clang-9 gcc-9
+ ln -s clang-9 cpp-9
+ ln -s clang-9 gcc
+ echo 'gcc-9 hold'
+ dpkg --set-selections
+ echo 'g++-9 hold'
+ dpkg --set-selections
+ for VERSION in $VERSIONS
+ rm -f g++-10 gcc-10 cpp-10 gcc
+ ln -s clang++-9 g++-10
+ ln -s clang-9 gcc-10
+ ln -s clang-9 cpp-10
+ ln -s clang-9 gcc
+ echo 'gcc-10 hold'
+ dpkg --set-selections
dpkg: warning: package not in status nor available database at line 1: gcc-10
dpkg: warning: found unknown packages; this might mean the available database
is outdated, and needs to be updated through a frontend method;
please see the FAQ <https://wiki.debian.org/Teams/Dpkg/FAQ>
+ echo 'g++-10 hold'
+ dpkg --set-selections
dpkg: warning: package not in status nor available database at line 1: g++-10
dpkg: warning: found unknown packages; this might mean the available database
is outdated, and needs to be updated through a frontend method;
please see the FAQ <https://wiki.debian.org/Teams/Dpkg/FAQ>
+ cd -
/build/octave-interval-cwrx5Y
+ echo 'Check if gcc, g++ & cpp are actually clang'
Check if gcc, g++ & cpp are actually clang
+ gcc --version
+ grep clang
+ cpp --version
+ grep clang
+ g++ --version
+ grep clang

I: Finished running '/tmp/clang9'.

Finished processing commands.
--------------------------------------------------------------------------------
I: NOTICE: Log filtering will replace 'build/octave-interval-cwrx5Y/resolver-UEueMD' with '<<RESOLVERDIR>>'

+------------------------------------------------------------------------------+
| Update chroot                                                                |
+------------------------------------------------------------------------------+

Hit:1 http://127.0.0.1:12990/debian sid InRelease
Reading package lists...
Reading package lists...
Building dependency tree...
Reading state information...
Calculating upgrade...
The following packages will be upgraded:
  libgmp10 zlib1g
2 upgraded, 0 newly installed, 0 to remove and 0 not upgraded.
Need to get 343 kB of archives.
After this operation, 0 B of additional disk space will be used.
Get:1 http://127.0.0.1:12990/debian sid/main amd64 libgmp10 amd64 2:6.2.0+dfsg-4 [253 kB]
Get:2 http://127.0.0.1:12990/debian sid/main amd64 zlib1g amd64 1:1.2.11.dfsg-2 [90.4 kB]
debconf: delaying package configuration, since apt-utils is not installed
Fetched 343 kB in 0s (5976 kB/s)
(Reading database ... (Reading database ... 5%(Reading database ... 10%(Reading database ... 15%(Reading database ... 20%(Reading database ... 25%(Reading database ... 30%(Reading database ... 35%(Reading database ... 40%(Reading database ... 45%(Reading database ... 50%(Reading database ... 55%(Reading database ... 60%(Reading database ... 65%(Reading database ... 70%(Reading database ... 75%(Reading database ... 80%(Reading database ... 85%(Reading database ... 90%(Reading database ... 95%(Reading database ... 100%(Reading database ... 13921 files and directories currently installed.)
Preparing to unpack .../libgmp10_2%3a6.2.0+dfsg-4_amd64.deb ...
Unpacking libgmp10:amd64 (2:6.2.0+dfsg-4) over (2:6.2.0+dfsg-3) ...
Setting up libgmp10:amd64 (2:6.2.0+dfsg-4) ...
(Reading database ... (Reading database ... 5%(Reading database ... 10%(Reading database ... 15%(Reading database ... 20%(Reading database ... 25%(Reading database ... 30%(Reading database ... 35%(Reading database ... 40%(Reading database ... 45%(Reading database ... 50%(Reading database ... 55%(Reading database ... 60%(Reading database ... 65%(Reading database ... 70%(Reading database ... 75%(Reading database ... 80%(Reading database ... 85%(Reading database ... 90%(Reading database ... 95%(Reading database ... 100%(Reading database ... 13921 files and directories currently installed.)
Preparing to unpack .../zlib1g_1%3a1.2.11.dfsg-2_amd64.deb ...
Unpacking zlib1g:amd64 (1:1.2.11.dfsg-2) over (1:1.2.11.dfsg-1.2) ...
Setting up zlib1g:amd64 (1:1.2.11.dfsg-2) ...
Processing triggers for libc-bin (2.29-10) ...

+------------------------------------------------------------------------------+
| Fetch source files                                                           |
+------------------------------------------------------------------------------+


Check APT
---------

Checking available source versions...

Download source files with APT
------------------------------

Reading package lists...
NOTICE: 'octave-interval' packaging is maintained in the 'Git' version control system at:
https://salsa.debian.org/pkg-octave-team/octave-interval.git
Please use:
git clone https://salsa.debian.org/pkg-octave-team/octave-interval.git
to retrieve the latest (possibly unreleased) updates to the package.
Need to get 2682 kB of source archives.
Get:1 http://127.0.0.1:12990/debian sid/main octave-interval 3.2.0-5 (dsc) [2218 B]
Get:2 http://127.0.0.1:12990/debian sid/main octave-interval 3.2.0-5 (tar) [2672 kB]
Get:3 http://127.0.0.1:12990/debian sid/main octave-interval 3.2.0-5 (diff) [7688 B]
Fetched 2682 kB in 0s (24.5 MB/s)
Download complete and in download only mode
I: NOTICE: Log filtering will replace 'build/octave-interval-cwrx5Y/octave-interval-3.2.0' with '<<PKGBUILDDIR>>'
I: NOTICE: Log filtering will replace 'build/octave-interval-cwrx5Y' with '<<BUILDDIR>>'

+------------------------------------------------------------------------------+
| Install package build dependencies                                           |
+------------------------------------------------------------------------------+


Setup apt archive
-----------------

Merged Build-Depends: debhelper-compat (= 12), dh-octave (>= 0.7.1), ghostscript, libmpfr-dev (>= 3.1.0), build-essential, fakeroot, texinfo, imagemagick, gnuplot-nox
Filtered Build-Depends: debhelper-compat (= 12), dh-octave (>= 0.7.1), ghostscript, libmpfr-dev (>= 3.1.0), build-essential, fakeroot, texinfo, imagemagick, gnuplot-nox
dpkg-deb: building package 'sbuild-build-depends-main-dummy' in '/<<RESOLVERDIR>>/apt_archive/sbuild-build-depends-main-dummy.deb'.
Ign:1 copy:/<<RESOLVERDIR>>/apt_archive ./ InRelease
Get:2 copy:/<<RESOLVERDIR>>/apt_archive ./ Release [957 B]
Ign:3 copy:/<<RESOLVERDIR>>/apt_archive ./ Release.gpg
Get:4 copy:/<<RESOLVERDIR>>/apt_archive ./ Sources [440 B]
Get:5 copy:/<<RESOLVERDIR>>/apt_archive ./ Packages [511 B]
Fetched 1908 B in 0s (0 B/s)
Reading package lists...
Reading package lists...

Install main build dependencies (apt-based resolver)
----------------------------------------------------

Installing build dependencies
Reading package lists...
Building dependency tree...
Reading state information...
The following additional packages will be installed:
  aglfn autoconf automake autopoint autotools-dev bsdmainutils ca-certificates
  cme debhelper dh-autoreconf dh-octave dh-octave-autopkgtest
  dh-strip-nondeterminism diffstat dwz file fontconfig fontconfig-config
  fonts-dejavu-core fonts-freefont-otf fonts-urw-base35 gettext gettext-base
  gfortran gfortran-9 ghostscript gnuplot-data gnuplot-nox gpg gpgconf
  groff-base hdf5-helpers hicolor-icon-theme imagemagick imagemagick-6-common
  imagemagick-6.q16 intltool-debian libaec-dev libaec0 libalgorithm-c3-perl
  libamd2 libapp-cmd-perl libapt-pkg-perl libarchive-zip-perl libarpack2
  libarray-intspan-perl libasound2 libasound2-data libassuan0 libavahi-client3
  libavahi-common-data libavahi-common3 libb-hooks-endofscope-perl
  libb-hooks-op-check-perl libberkeleydb-perl libblas-dev libblas3
  libboolean-perl libbrotli1 libcairo2 libcamd2 libcapture-tiny-perl
  libcarp-assert-more-perl libcarp-assert-perl libccolamd2 libcgi-pm-perl
  libcholmod3 libclass-accessor-perl libclass-c3-perl libclass-load-perl
  libclass-method-modifiers-perl libclass-xsaccessor-perl libclone-choose-perl
  libclone-perl libcolamd2 libconfig-model-backend-yaml-perl
  libconfig-model-dpkg-perl libconfig-model-perl libconvert-binhex-perl
  libcroco3 libcups2 libcurl3-gnutls libcxsparse3 libdata-optlist-perl
  libdata-section-perl libdatrie1 libdbus-1-3 libde265-0 libdebhelper-perl
  libdevel-callchecker-perl libdevel-size-perl libdigest-hmac-perl
  libdouble-conversion3 libdrm-amdgpu1 libdrm-common libdrm-intel1
  libdrm-nouveau2 libdrm-radeon1 libdrm2 libdynaloader-functions-perl
  libegl-dev libegl-mesa0 libegl1 libelf1 libemail-valid-perl
  libencode-locale-perl liberror-perl libevdev2 libexpat1
  libexporter-lite-perl libexporter-tiny-perl libfftw3-bin libfftw3-dev
  libfftw3-double3 libfftw3-long3 libfftw3-quad3 libfftw3-single3
  libfile-basedir-perl libfile-find-rule-perl libfile-homedir-perl
  libfile-listing-perl libfile-stripnondeterminism-perl libfile-which-perl
  libflac8 libfltk-gl1.3 libfltk1.3 libfont-ttf-perl libfontconfig1
  libfreetype6 libfribidi0 libfuture-perl libgbm1 libgd3
  libgetopt-long-descriptive-perl libgfortran-9-dev libgfortran5 libgl-dev
  libgl1 libgl1-mesa-dev libgl1-mesa-dri libgl2ps1.4 libglapi-mesa libgles-dev
  libgles1 libgles2 libglib2.0-0 libglpk40 libglu1-mesa libglvnd-dev libglvnd0
  libglx-dev libglx-mesa0 libglx0 libgmp-dev libgmpxx4ldbl
  libgraphicsmagick++-q16-12 libgraphicsmagick-q16-3 libgraphite2-3 libgs9
  libgs9-common libgssapi-krb5-2 libgudev-1.0-0 libharfbuzz0b
  libhash-fieldhash-perl libhash-merge-perl libhdf5-103 libhdf5-cpp-103
  libhdf5-dev libheif1 libhtml-parser-perl libhtml-tagset-perl
  libhtml-tree-perl libhttp-cookies-perl libhttp-date-perl
  libhttp-message-perl libhttp-negotiate-perl libice6 libicu63 libidn11
  libijs-0.35 libimport-into-perl libinput-bin libinput10
  libio-async-loop-epoll-perl libio-async-perl libio-html-perl libio-pty-perl
  libio-socket-ssl-perl libio-string-perl libio-stringy-perl
  libio-tiecombine-perl libipc-run-perl libipc-system-simple-perl
  libjack-jackd2-0 libjbig0 libjbig2dec0 libjpeg-dev libjpeg62-turbo
  libjpeg62-turbo-dev libjson-perl libk5crypto3 libkeyutils1 libkrb5-3
  libkrb5support0 liblapack-dev liblapack3 liblcms2-2 libldap-2.4-2
  libldap-common liblinux-epoll-perl liblist-compare-perl
  liblist-moreutils-perl liblist-someutils-perl liblog-any-adapter-screen-perl
  liblog-any-perl liblog-log4perl-perl liblqr-1-0 libltdl7 liblua5.3-0
  liblwp-mediatypes-perl liblwp-protocol-https-perl libmagic-mgc libmagic1
  libmagickcore-6.q16-6 libmagickwand-6.q16-6 libmailtools-perl libmetis5
  libmime-tools-perl libmldbm-perl libmodule-implementation-perl
  libmodule-pluggable-perl libmodule-runtime-perl libmoo-perl
  libmoox-aliases-perl libmoox-struct-perl libmouse-perl
  libmousex-nativetraits-perl libmousex-strictconstructor-perl libmpfr-dev
  libmro-compat-perl libmtdev1 libnamespace-clean-perl libncurses-dev
  libncurses6 libnet-dns-perl libnet-domain-tld-perl libnet-http-perl
  libnet-ip-perl libnet-smtp-ssl-perl libnet-ssleay-perl libnghttp2-14
  libnuma1 libnumber-compare-perl libnumber-range-perl libobject-id-perl
  liboctave-dev liboctave7 libogg0 libopengl-dev libopengl0 libopenjp2-7
  libopus0 libpackage-stash-perl libpango-1.0-0 libpangocairo-1.0-0
  libpangoft2-1.0-0 libpaper1 libparams-classify-perl libparams-util-perl
  libparams-validate-perl libparse-debcontrol-perl libparse-recdescent-perl
  libpath-iterator-rule-perl libpath-tiny-perl libpciaccess0 libpcre2-16-0
  libpipeline1 libpixman-1-0 libpng16-16 libpod-constants-perl libpod-pom-perl
  libportaudio2 libpsl5 libpthread-stubs0-dev libqhull7 libqrupdate1
  libqscintilla2-qt5-15 libqscintilla2-qt5-l10n libqt5core5a libqt5dbus5
  libqt5gui5 libqt5help5 libqt5network5 libqt5printsupport5 libqt5sql5
  libqt5widgets5 libqt5xml5 libre-engine-re2-perl libre2-5 libreadline-dev
  libreadline8 libregexp-common-perl libregexp-pattern-license-perl
  libregexp-pattern-perl librole-tiny-perl librtmp1 libsamplerate0 libsasl2-2
  libsasl2-modules-db libsensors-config libsensors5 libsigsegv2 libsm6
  libsndfile1 libsoftware-license-perl libsoftware-licensemoreutils-perl
  libsort-key-perl libsort-versions-perl libsqlite3-0 libssh2-1 libssl1.1
  libstrictures-perl libstring-copyright-perl libstring-escape-perl
  libstring-rewriteprefix-perl libstruct-dumb-perl libsub-exporter-perl
  libsub-exporter-progressive-perl libsub-identify-perl libsub-install-perl
  libsub-name-perl libsub-override-perl libsub-quote-perl libsub-uplevel-perl
  libsuitesparseconfig5 libsz2 libtest-exception-perl libtext-autoformat-perl
  libtext-glob-perl libtext-levenshtein-damerau-perl libtext-levenshtein-perl
  libtext-reform-perl libtext-template-perl libtext-unidecode-perl
  libthai-data libthai0 libtiff5 libtimedate-perl libtool libtry-tiny-perl
  libtype-tiny-perl libuchardet0 libumfpack5 liburi-perl
  libvariable-magic-perl libvorbis0a libvorbisenc2 libvulkan1 libwacom-common
  libwacom2 libwayland-client0 libwayland-server0 libwebp6 libwebpmux3
  libwmf0.2-7 libwww-perl libwww-robotrules-perl libx11-6 libx11-data
  libx11-dev libx11-xcb1 libx265-179 libxau-dev libxau6 libxcb-dri2-0
  libxcb-dri3-0 libxcb-glx0 libxcb-icccm4 libxcb-image0 libxcb-keysyms1
  libxcb-present0 libxcb-randr0 libxcb-render-util0 libxcb-render0
  libxcb-shape0 libxcb-shm0 libxcb-sync1 libxcb-util0 libxcb-xfixes0
  libxcb-xinerama0 libxcb-xinput0 libxcb-xkb1 libxcb1 libxcb1-dev libxcursor1
  libxdamage1 libxdmcp-dev libxdmcp6 libxext6 libxfixes3 libxft2 libxinerama1
  libxkbcommon-x11-0 libxkbcommon0 libxml-libxml-perl
  libxml-namespacesupport-perl libxml-sax-base-perl libxml-sax-perl libxml2
  libxpm4 libxrender1 libxshmfence1 libxxf86vm1 libyaml-0-2
  libyaml-libyaml-perl libyaml-perl libyaml-tiny-perl licensecheck lintian m4
  man-db netbase octave octave-common openssl patchutils perl-openssl-defaults
  po-debconf poppler-data readline-common sensible-utils t1utils tex-common
  texinfo ucf x11-common x11proto-core-dev x11proto-dev xkb-data
  xorg-sgml-doctools xtrans-dev zlib1g-dev
Suggested packages:
  autoconf-archive gnu-standards autoconf-doc wamerican | wordlist whois
  vacation libconfig-model-cursesui-perl libconfig-model-itself-perl dh-make
  fonts-texgyre gettext-doc libasprintf-dev libgettextpo-dev gfortran-multilib
  gfortran-doc gfortran-9-multilib gfortran-9-doc libcoarrays-dev
  ghostscript-x gnuplot-doc groff imagemagick-doc autotrace cups-bsd | lpr
  | lprng curl enscript ffmpeg gimp grads graphviz hp2xx html2ps libwmf-bin
  mplayer povray radiance sane-utils texlive-base-bin transfig ufraw-batch
  xdg-utils libasound2-plugins alsa-utils liblapack-doc
  libconfig-model-openssh-perl libterm-readline-perl-perl
  | libterm-readline-gnu-perl cups-common libfftw3-doc libxml-parser-perl
  libgd-tools libiodbc2-dev default-libmysqlclient-dev gmp-doc libgmp10-doc
  graphicsmagick-dbg krb5-doc krb5-user libhdf5-doc libdata-dump-perl jackd2
  liblcms2-utils libdbd-csv-perl liblog-dispatch-filerotate-perl librrds-perl
  libxml-dom-perl libcrypt-ssleay-perl libmagickcore-6.q16-6-extra libmpfr-doc
  ncurses-doc opus-tools libscalar-number-perl pciutils libqscintilla2-doc
  qt5-image-formats-plugins qtwayland5 readline-doc lm-sensors
  libbareword-filehandles-perl libindirect-perl libmultidimensional-perl
  libtool-doc gcj-jdk libdevel-lexalias-perl libdevel-stacktrace-perl
  libwmf0.2-7-gtk libauthen-ntlm-perl libx11-doc libxcb-doc libyaml-shell-perl
  bash-completion binutils-multiarch m4-doc apparmor less www-browser
  libmail-box-perl poppler-utils fonts-japanese-mincho | fonts-ipafont-mincho
  fonts-japanese-gothic | fonts-ipafont-gothic fonts-arphic-ukai
  fonts-arphic-uming fonts-nanum texlive-base texlive-latex-base
  texlive-plain-generic texlive-fonts-recommended
Recommended packages:
  libconfig-model-approx-perl libconfig-model-lcdproc-perl
  libconfig-model-openssh-perl libconfig-model-systemd-perl
  libconfig-model-tkui-perl curl | wget | lynx fonts-liberation groff gnupg
  libmagickcore-6.q16-6-extra netpbm alsa-ucm-conf alsa-topology-conf
  libcgi-fast-perl libclass-c3-xs-perl bash-completion fuse libfuse-perl dbus
  libarchive-cpio-perl libglib2.0-data shared-mime-info xdg-user-dirs gsfonts
  fonts-droid-fallback libhtml-format-perl libasync-mergepoint-perl
  libsereal-perl libtest-fatal-perl libtest-refcount-perl libjson-xs-perl
  krb5-locales liblist-someutils-xs-perl liblog-dispatch-perl
  libipc-shareable-perl libfreezethaw-perl libgpm2 libdigest-bubblebabble-perl
  libnet-dns-sec-perl libnet-libidn-perl libperl4-corelibs-perl
  libauthen-sasl-perl libossp-uuid-perl libpackage-stash-xs-perl
  libpaper-utils libtie-ixhash-perl libunicode-utf8-perl publicsuffix
  qttranslations5-l10n libqt5svg5 qt5-gtk-platformtheme libqt5sql5-sqlite
  | libqt5sql5-mysql | libqt5sql5-odbc | libqt5sql5-psql | libqt5sql5-tds
  | libqt5sql5-ibase libsasl2-modules libltdl-dev libref-util-perl
  libtype-tiny-xs-perl mesa-vulkan-drivers | vulkan-icd libwacom-bin
  libdata-dump-perl libhtml-form-perl libhttp-daemon-perl
  libxml-sax-expat-perl libperlio-gzip-perl libopenblas0 | libatlas3-base
  pstoedit epstool default-jre-headless octave-doc libmail-sendmail-perl
The following NEW packages will be installed:
  aglfn autoconf automake autopoint autotools-dev bsdmainutils ca-certificates
  cme debhelper dh-autoreconf dh-octave dh-octave-autopkgtest
  dh-strip-nondeterminism diffstat dwz file fontconfig fontconfig-config
  fonts-dejavu-core fonts-freefont-otf fonts-urw-base35 gettext gettext-base
  gfortran gfortran-9 ghostscript gnuplot-data gnuplot-nox gpg gpgconf
  groff-base hdf5-helpers hicolor-icon-theme imagemagick imagemagick-6-common
  imagemagick-6.q16 intltool-debian libaec-dev libaec0 libalgorithm-c3-perl
  libamd2 libapp-cmd-perl libapt-pkg-perl libarchive-zip-perl libarpack2
  libarray-intspan-perl libasound2 libasound2-data libassuan0 libavahi-client3
  libavahi-common-data libavahi-common3 libb-hooks-endofscope-perl
  libb-hooks-op-check-perl libberkeleydb-perl libblas-dev libblas3
  libboolean-perl libbrotli1 libcairo2 libcamd2 libcapture-tiny-perl
  libcarp-assert-more-perl libcarp-assert-perl libccolamd2 libcgi-pm-perl
  libcholmod3 libclass-accessor-perl libclass-c3-perl libclass-load-perl
  libclass-method-modifiers-perl libclass-xsaccessor-perl libclone-choose-perl
  libclone-perl libcolamd2 libconfig-model-backend-yaml-perl
  libconfig-model-dpkg-perl libconfig-model-perl libconvert-binhex-perl
  libcroco3 libcups2 libcurl3-gnutls libcxsparse3 libdata-optlist-perl
  libdata-section-perl libdatrie1 libdbus-1-3 libde265-0 libdebhelper-perl
  libdevel-callchecker-perl libdevel-size-perl libdigest-hmac-perl
  libdouble-conversion3 libdrm-amdgpu1 libdrm-common libdrm-intel1
  libdrm-nouveau2 libdrm-radeon1 libdrm2 libdynaloader-functions-perl
  libegl-dev libegl-mesa0 libegl1 libelf1 libemail-valid-perl
  libencode-locale-perl liberror-perl libevdev2 libexpat1
  libexporter-lite-perl libexporter-tiny-perl libfftw3-bin libfftw3-dev
  libfftw3-double3 libfftw3-long3 libfftw3-quad3 libfftw3-single3
  libfile-basedir-perl libfile-find-rule-perl libfile-homedir-perl
  libfile-listing-perl libfile-stripnondeterminism-perl libfile-which-perl
  libflac8 libfltk-gl1.3 libfltk1.3 libfont-ttf-perl libfontconfig1
  libfreetype6 libfribidi0 libfuture-perl libgbm1 libgd3
  libgetopt-long-descriptive-perl libgfortran-9-dev libgfortran5 libgl-dev
  libgl1 libgl1-mesa-dev libgl1-mesa-dri libgl2ps1.4 libglapi-mesa libgles-dev
  libgles1 libgles2 libglib2.0-0 libglpk40 libglu1-mesa libglvnd-dev libglvnd0
  libglx-dev libglx-mesa0 libglx0 libgmp-dev libgmpxx4ldbl
  libgraphicsmagick++-q16-12 libgraphicsmagick-q16-3 libgraphite2-3 libgs9
  libgs9-common libgssapi-krb5-2 libgudev-1.0-0 libharfbuzz0b
  libhash-fieldhash-perl libhash-merge-perl libhdf5-103 libhdf5-cpp-103
  libhdf5-dev libheif1 libhtml-parser-perl libhtml-tagset-perl
  libhtml-tree-perl libhttp-cookies-perl libhttp-date-perl
  libhttp-message-perl libhttp-negotiate-perl libice6 libicu63 libidn11
  libijs-0.35 libimport-into-perl libinput-bin libinput10
  libio-async-loop-epoll-perl libio-async-perl libio-html-perl libio-pty-perl
  libio-socket-ssl-perl libio-string-perl libio-stringy-perl
  libio-tiecombine-perl libipc-run-perl libipc-system-simple-perl
  libjack-jackd2-0 libjbig0 libjbig2dec0 libjpeg-dev libjpeg62-turbo
  libjpeg62-turbo-dev libjson-perl libk5crypto3 libkeyutils1 libkrb5-3
  libkrb5support0 liblapack-dev liblapack3 liblcms2-2 libldap-2.4-2
  libldap-common liblinux-epoll-perl liblist-compare-perl
  liblist-moreutils-perl liblist-someutils-perl liblog-any-adapter-screen-perl
  liblog-any-perl liblog-log4perl-perl liblqr-1-0 libltdl7 liblua5.3-0
  liblwp-mediatypes-perl liblwp-protocol-https-perl libmagic-mgc libmagic1
  libmagickcore-6.q16-6 libmagickwand-6.q16-6 libmailtools-perl libmetis5
  libmime-tools-perl libmldbm-perl libmodule-implementation-perl
  libmodule-pluggable-perl libmodule-runtime-perl libmoo-perl
  libmoox-aliases-perl libmoox-struct-perl libmouse-perl
  libmousex-nativetraits-perl libmousex-strictconstructor-perl libmpfr-dev
  libmro-compat-perl libmtdev1 libnamespace-clean-perl libncurses-dev
  libncurses6 libnet-dns-perl libnet-domain-tld-perl libnet-http-perl
  libnet-ip-perl libnet-smtp-ssl-perl libnet-ssleay-perl libnghttp2-14
  libnuma1 libnumber-compare-perl libnumber-range-perl libobject-id-perl
  liboctave-dev liboctave7 libogg0 libopengl-dev libopengl0 libopenjp2-7
  libopus0 libpackage-stash-perl libpango-1.0-0 libpangocairo-1.0-0
  libpangoft2-1.0-0 libpaper1 libparams-classify-perl libparams-util-perl
  libparams-validate-perl libparse-debcontrol-perl libparse-recdescent-perl
  libpath-iterator-rule-perl libpath-tiny-perl libpciaccess0 libpcre2-16-0
  libpipeline1 libpixman-1-0 libpng16-16 libpod-constants-perl libpod-pom-perl
  libportaudio2 libpsl5 libpthread-stubs0-dev libqhull7 libqrupdate1
  libqscintilla2-qt5-15 libqscintilla2-qt5-l10n libqt5core5a libqt5dbus5
  libqt5gui5 libqt5help5 libqt5network5 libqt5printsupport5 libqt5sql5
  libqt5widgets5 libqt5xml5 libre-engine-re2-perl libre2-5 libreadline-dev
  libreadline8 libregexp-common-perl libregexp-pattern-license-perl
  libregexp-pattern-perl librole-tiny-perl librtmp1 libsamplerate0 libsasl2-2
  libsasl2-modules-db libsensors-config libsensors5 libsigsegv2 libsm6
  libsndfile1 libsoftware-license-perl libsoftware-licensemoreutils-perl
  libsort-key-perl libsort-versions-perl libsqlite3-0 libssh2-1 libssl1.1
  libstrictures-perl libstring-copyright-perl libstring-escape-perl
  libstring-rewriteprefix-perl libstruct-dumb-perl libsub-exporter-perl
  libsub-exporter-progressive-perl libsub-identify-perl libsub-install-perl
  libsub-name-perl libsub-override-perl libsub-quote-perl libsub-uplevel-perl
  libsuitesparseconfig5 libsz2 libtest-exception-perl libtext-autoformat-perl
  libtext-glob-perl libtext-levenshtein-damerau-perl libtext-levenshtein-perl
  libtext-reform-perl libtext-template-perl libtext-unidecode-perl
  libthai-data libthai0 libtiff5 libtimedate-perl libtool libtry-tiny-perl
  libtype-tiny-perl libuchardet0 libumfpack5 liburi-perl
  libvariable-magic-perl libvorbis0a libvorbisenc2 libvulkan1 libwacom-common
  libwacom2 libwayland-client0 libwayland-server0 libwebp6 libwebpmux3
  libwmf0.2-7 libwww-perl libwww-robotrules-perl libx11-6 libx11-data
  libx11-dev libx11-xcb1 libx265-179 libxau-dev libxau6 libxcb-dri2-0
  libxcb-dri3-0 libxcb-glx0 libxcb-icccm4 libxcb-image0 libxcb-keysyms1
  libxcb-present0 libxcb-randr0 libxcb-render-util0 libxcb-render0
  libxcb-shape0 libxcb-shm0 libxcb-sync1 libxcb-util0 libxcb-xfixes0
  libxcb-xinerama0 libxcb-xinput0 libxcb-xkb1 libxcb1 libxcb1-dev libxcursor1
  libxdamage1 libxdmcp-dev libxdmcp6 libxext6 libxfixes3 libxft2 libxinerama1
  libxkbcommon-x11-0 libxkbcommon0 libxml-libxml-perl
  libxml-namespacesupport-perl libxml-sax-base-perl libxml-sax-perl libxml2
  libxpm4 libxrender1 libxshmfence1 libxxf86vm1 libyaml-0-2
  libyaml-libyaml-perl libyaml-perl libyaml-tiny-perl licensecheck lintian m4
  man-db netbase octave octave-common openssl patchutils perl-openssl-defaults
  po-debconf poppler-data readline-common sbuild-build-depends-main-dummy
  sensible-utils t1utils tex-common texinfo ucf x11-common x11proto-core-dev
  x11proto-dev xkb-data xorg-sgml-doctools xtrans-dev zlib1g-dev
0 upgraded, 443 newly installed, 0 to remove and 0 not upgraded.
Need to get 147 MB of archives.
After this operation, 777 MB of additional disk space will be used.
Get:1 copy:/<<RESOLVERDIR>>/apt_archive ./ sbuild-build-depends-main-dummy 0.invalid.0 [940 B]
Get:2 http://127.0.0.1:12990/debian sid/main amd64 bsdmainutils amd64 11.1.2+b1 [191 kB]
Get:3 http://127.0.0.1:12990/debian sid/main amd64 libuchardet0 amd64 0.0.6-3 [64.9 kB]
Get:4 http://127.0.0.1:12990/debian sid/main amd64 groff-base amd64 1.22.4-4 [919 kB]
Get:5 http://127.0.0.1:12990/debian sid/main amd64 libpipeline1 amd64 1.5.2-2 [33.9 kB]
Get:6 http://127.0.0.1:12990/debian sid/main amd64 man-db amd64 2.9.0-2 [1307 kB]
Get:7 http://127.0.0.1:12990/debian sid/main amd64 libfftw3-double3 amd64 3.3.8-2 [733 kB]
Get:8 http://127.0.0.1:12990/debian sid/main amd64 libexpat1 amd64 2.2.9-1 [94.3 kB]
Get:9 http://127.0.0.1:12990/debian sid/main amd64 libpng16-16 amd64 1.6.37-2 [292 kB]
Get:10 http://127.0.0.1:12990/debian sid/main amd64 libfreetype6 amd64 2.10.1-2 [392 kB]
Get:11 http://127.0.0.1:12990/debian sid/main amd64 sensible-utils all 0.0.12+nmu1 [16.0 kB]
Get:12 http://127.0.0.1:12990/debian sid/main amd64 ucf all 3.0038+nmu1 [69.0 kB]
Get:13 http://127.0.0.1:12990/debian sid/main amd64 fonts-dejavu-core all 2.37-1 [1068 kB]
Get:14 http://127.0.0.1:12990/debian sid/main amd64 fontconfig-config all 2.13.1-2 [280 kB]
Get:15 http://127.0.0.1:12990/debian sid/main amd64 libfontconfig1 amd64 2.13.1-2+b1 [347 kB]
Get:16 http://127.0.0.1:12990/debian sid/main amd64 libde265-0 amd64 1.0.4-1 [239 kB]
Get:17 http://127.0.0.1:12990/debian sid/main amd64 libnuma1 amd64 2.0.12-1+b1 [26.3 kB]
Get:18 http://127.0.0.1:12990/debian sid/main amd64 libx265-179 amd64 3.2.1-1 [1071 kB]
Get:19 http://127.0.0.1:12990/debian sid/main amd64 libheif1 amd64 1.6.1-1 [164 kB]
Get:20 http://127.0.0.1:12990/debian sid/main amd64 libjbig0 amd64 2.1-3.1+b2 [31.0 kB]
Get:21 http://127.0.0.1:12990/debian sid/main amd64 libjpeg62-turbo amd64 1:1.5.2-2+b1 [134 kB]
Get:22 http://127.0.0.1:12990/debian sid/main amd64 liblcms2-2 amd64 2.9-4 [146 kB]
Get:23 http://127.0.0.1:12990/debian sid/main amd64 libglib2.0-0 amd64 2.62.4-2 [1319 kB]
Get:24 http://127.0.0.1:12990/debian sid/main amd64 liblqr-1-0 amd64 0.4.2-2.1 [29.1 kB]
Get:25 http://127.0.0.1:12990/debian sid/main amd64 libltdl7 amd64 2.4.6-13 [390 kB]
Get:26 http://127.0.0.1:12990/debian sid/main amd64 libopenjp2-7 amd64 2.3.1-1 [159 kB]
Get:27 http://127.0.0.1:12990/debian sid/main amd64 libwebp6 amd64 0.6.1-2+b1 [261 kB]
Get:28 http://127.0.0.1:12990/debian sid/main amd64 libtiff5 amd64 4.1.0+git191117-2 [271 kB]
Get:29 http://127.0.0.1:12990/debian sid/main amd64 libwebpmux3 amd64 0.6.1-2+b1 [97.9 kB]
Get:30 http://127.0.0.1:12990/debian sid/main amd64 libxau6 amd64 1:1.0.8-1+b2 [19.9 kB]
Get:31 http://127.0.0.1:12990/debian sid/main amd64 libxdmcp6 amd64 1:1.1.2-3 [26.3 kB]
Get:32 http://127.0.0.1:12990/debian sid/main amd64 libxcb1 amd64 1.13.1-5 [137 kB]
Get:33 http://127.0.0.1:12990/debian sid/main amd64 libx11-data all 2:1.6.8-1 [298 kB]
Get:34 http://127.0.0.1:12990/debian sid/main amd64 libx11-6 amd64 2:1.6.8-1 [756 kB]
Get:35 http://127.0.0.1:12990/debian sid/main amd64 libxext6 amd64 2:1.3.3-1+b2 [52.5 kB]
Get:36 http://127.0.0.1:12990/debian sid/main amd64 libicu63 amd64 63.2-2 [8301 kB]
Get:37 http://127.0.0.1:12990/debian sid/main amd64 libxml2 amd64 2.9.10+dfsg-3 [709 kB]
Get:38 http://127.0.0.1:12990/debian sid/main amd64 imagemagick-6-common all 8:6.9.10.23+dfsg-2.1 [200 kB]
Get:39 http://127.0.0.1:12990/debian sid/main amd64 libmagickcore-6.q16-6 amd64 8:6.9.10.23+dfsg-2.1+b2 [1787 kB]
Get:40 http://127.0.0.1:12990/debian sid/main amd64 libmagickwand-6.q16-6 amd64 8:6.9.10.23+dfsg-2.1+b2 [446 kB]
Get:41 http://127.0.0.1:12990/debian sid/main amd64 poppler-data all 0.4.9-2 [1473 kB]
Get:42 http://127.0.0.1:12990/debian sid/main amd64 tex-common all 6.13 [53.2 kB]
Get:43 http://127.0.0.1:12990/debian sid/main amd64 readline-common all 8.0-3 [72.5 kB]
Get:44 http://127.0.0.1:12990/debian sid/main amd64 libreadline8 amd64 8.0-3 [160 kB]
Get:45 http://127.0.0.1:12990/debian sid/main amd64 netbase all 6.1 [19.9 kB]
Get:46 http://127.0.0.1:12990/debian sid/main amd64 libmagic-mgc amd64 1:5.38-4 [262 kB]
Get:47 http://127.0.0.1:12990/debian sid/main amd64 libmagic1 amd64 1:5.38-4 [120 kB]
Get:48 http://127.0.0.1:12990/debian sid/main amd64 file amd64 1:5.38-4 [67.9 kB]
Get:49 http://127.0.0.1:12990/debian sid/main amd64 gettext-base amd64 0.19.8.1-10 [123 kB]
Get:50 http://127.0.0.1:12990/debian sid/main amd64 aglfn all 1.7+git20191031.4036a9c-2 [30.5 kB]
Get:51 http://127.0.0.1:12990/debian sid/main amd64 libsigsegv2 amd64 2.12-2 [32.8 kB]
Get:52 http://127.0.0.1:12990/debian sid/main amd64 m4 amd64 1.4.18-4 [203 kB]
Get:53 http://127.0.0.1:12990/debian sid/main amd64 autoconf all 2.69-11.1 [341 kB]
Get:54 http://127.0.0.1:12990/debian sid/main amd64 autotools-dev all 20180224.1 [77.0 kB]
Get:55 http://127.0.0.1:12990/debian sid/main amd64 automake all 1:1.16.1-4 [771 kB]
Get:56 http://127.0.0.1:12990/debian sid/main amd64 autopoint all 0.19.8.1-10 [435 kB]
Get:57 http://127.0.0.1:12990/debian sid/main amd64 libssl1.1 amd64 1.1.1d-2 [1540 kB]
Get:58 http://127.0.0.1:12990/debian sid/main amd64 openssl amd64 1.1.1d-2 [840 kB]
Get:59 http://127.0.0.1:12990/debian sid/main amd64 ca-certificates all 20190110 [157 kB]
Get:60 http://127.0.0.1:12990/debian sid/main amd64 libcapture-tiny-perl all 0.48-1 [26.0 kB]
Get:61 http://127.0.0.1:12990/debian sid/main amd64 libparams-util-perl amd64 1.07-3+b5 [22.9 kB]
Get:62 http://127.0.0.1:12990/debian sid/main amd64 libsub-install-perl all 0.928-1 [11.4 kB]
Get:63 http://127.0.0.1:12990/debian sid/main amd64 libdata-optlist-perl all 0.110-1 [10.6 kB]
Get:64 http://127.0.0.1:12990/debian sid/main amd64 libb-hooks-op-check-perl amd64 0.22-1+b2 [11.3 kB]
Get:65 http://127.0.0.1:12990/debian sid/main amd64 libdynaloader-functions-perl all 0.003-1 [12.6 kB]
Get:66 http://127.0.0.1:12990/debian sid/main amd64 libdevel-callchecker-perl amd64 0.008-1+b1 [15.9 kB]
Get:67 http://127.0.0.1:12990/debian sid/main amd64 libparams-classify-perl amd64 0.015-1+b2 [25.6 kB]
Get:68 http://127.0.0.1:12990/debian sid/main amd64 libmodule-runtime-perl all 0.016-1 [19.4 kB]
Get:69 http://127.0.0.1:12990/debian sid/main amd64 libtry-tiny-perl all 0.30-1 [23.3 kB]
Get:70 http://127.0.0.1:12990/debian sid/main amd64 libmodule-implementation-perl all 0.09-1 [12.9 kB]
Get:71 http://127.0.0.1:12990/debian sid/main amd64 libpackage-stash-perl all 0.38-1 [21.7 kB]
Get:72 http://127.0.0.1:12990/debian sid/main amd64 libclass-load-perl all 0.25-1 [16.1 kB]
Get:73 http://127.0.0.1:12990/debian sid/main amd64 libio-stringy-perl all 2.111-3 [56.5 kB]
Get:74 http://127.0.0.1:12990/debian sid/main amd64 libparams-validate-perl amd64 1.29-3 [67.3 kB]
Get:75 http://127.0.0.1:12990/debian sid/main amd64 libsub-exporter-perl all 0.987-1 [47.2 kB]
Get:76 http://127.0.0.1:12990/debian sid/main amd64 libgetopt-long-descriptive-perl all 0.104-1 [28.1 kB]
Get:77 http://127.0.0.1:12990/debian sid/main amd64 libio-tiecombine-perl all 1.005-1 [13.0 kB]
Get:78 http://127.0.0.1:12990/debian sid/main amd64 libmodule-pluggable-perl all 5.2-1 [25.7 kB]
Get:79 http://127.0.0.1:12990/debian sid/main amd64 libstring-rewriteprefix-perl all 0.008-1 [6980 B]
Get:80 http://127.0.0.1:12990/debian sid/main amd64 libapp-cmd-perl all 0.331-1 [63.9 kB]
Get:81 http://127.0.0.1:12990/debian sid/main amd64 libboolean-perl all 0.46-1 [11.1 kB]
Get:82 http://127.0.0.1:12990/debian sid/main amd64 libcarp-assert-perl all 0.21-1 [18.2 kB]
Get:83 http://127.0.0.1:12990/debian sid/main amd64 libsub-uplevel-perl all 0.2800-1 [16.3 kB]
Get:84 http://127.0.0.1:12990/debian sid/main amd64 libtest-exception-perl all 0.43-1 [18.7 kB]
Get:85 http://127.0.0.1:12990/debian sid/main amd64 libcarp-assert-more-perl all 1.20-1 [16.4 kB]
Get:86 http://127.0.0.1:12990/debian sid/main amd64 libfile-which-perl all 1.23-1 [16.6 kB]
Get:87 http://127.0.0.1:12990/debian sid/main amd64 libfile-homedir-perl all 1.004-1 [42.7 kB]
Get:88 http://127.0.0.1:12990/debian sid/main amd64 libclone-choose-perl all 0.010-1 [8424 B]
Get:89 http://127.0.0.1:12990/debian sid/main amd64 libhash-merge-perl all 0.300-1 [14.3 kB]
Get:90 http://127.0.0.1:12990/debian sid/main amd64 libjson-perl all 4.02000-2 [88.8 kB]
Get:91 http://127.0.0.1:12990/debian sid/main amd64 libexporter-tiny-perl all 1.002001-1 [36.9 kB]
Get:92 http://127.0.0.1:12990/debian sid/main amd64 liblist-moreutils-perl amd64 0.416-1+b5 [63.6 kB]
Get:93 http://127.0.0.1:12990/debian sid/main amd64 liblog-log4perl-perl all 1.49-1 [377 kB]
Get:94 http://127.0.0.1:12990/debian sid/main amd64 libmouse-perl amd64 2.5.9-1 [173 kB]
Get:95 http://127.0.0.1:12990/debian sid/main amd64 libmousex-nativetraits-perl all 1.09-2 [67.4 kB]
Get:96 http://127.0.0.1:12990/debian sid/main amd64 libmousex-strictconstructor-perl all 0.02-2 [4996 B]
Get:97 http://127.0.0.1:12990/debian sid/main amd64 libparse-recdescent-perl all 1.967015+dfsg-2 [159 kB]
Get:98 http://127.0.0.1:12990/debian sid/main amd64 libpath-tiny-perl all 0.108-1 [53.3 kB]
Get:99 http://127.0.0.1:12990/debian sid/main amd64 libpod-pom-perl all 2.01-3 [67.0 kB]
Get:100 http://127.0.0.1:12990/debian sid/main amd64 libregexp-common-perl all 2017060201-1 [177 kB]
Get:101 http://127.0.0.1:12990/debian sid/main amd64 libconfig-model-perl all 2.138-2 [461 kB]
Get:102 http://127.0.0.1:12990/debian sid/main amd64 libyaml-perl all 1.30-1 [67.7 kB]
Get:103 http://127.0.0.1:12990/debian sid/main amd64 cme all 1.031-1 [81.9 kB]
Get:104 http://127.0.0.1:12990/debian sid/main amd64 libtool all 2.4.6-13 [513 kB]
Get:105 http://127.0.0.1:12990/debian sid/main amd64 dh-autoreconf all 19 [16.9 kB]
Get:106 http://127.0.0.1:12990/debian sid/main amd64 libdebhelper-perl all 12.9 [183 kB]
Get:107 http://127.0.0.1:12990/debian sid/main amd64 libarchive-zip-perl all 1.67-1 [104 kB]
Get:108 http://127.0.0.1:12990/debian sid/main amd64 libsub-override-perl all 0.09-2 [10.2 kB]
Get:109 http://127.0.0.1:12990/debian sid/main amd64 libfile-stripnondeterminism-perl all 1.6.3-2 [23.7 kB]
Get:110 http://127.0.0.1:12990/debian sid/main amd64 dh-strip-nondeterminism all 1.6.3-2 [14.7 kB]
Get:111 http://127.0.0.1:12990/debian sid/main amd64 libelf1 amd64 0.176-1.1 [161 kB]
Get:112 http://127.0.0.1:12990/debian sid/main amd64 dwz amd64 0.13-5 [151 kB]
Get:113 http://127.0.0.1:12990/debian sid/main amd64 libcroco3 amd64 0.6.13-1 [146 kB]
Get:114 http://127.0.0.1:12990/debian sid/main amd64 gettext amd64 0.19.8.1-10 [1303 kB]
Get:115 http://127.0.0.1:12990/debian sid/main amd64 intltool-debian all 0.35.0+20060710.5 [26.8 kB]
Get:116 http://127.0.0.1:12990/debian sid/main amd64 po-debconf all 1.0.21 [248 kB]
Get:117 http://127.0.0.1:12990/debian sid/main amd64 debhelper all 12.9 [994 kB]
Get:118 http://127.0.0.1:12990/debian sid/main amd64 libblas3 amd64 3.9.0-1 [153 kB]
Get:119 http://127.0.0.1:12990/debian sid/main amd64 libgfortran5 amd64 10-20200222-1 [721 kB]
Get:120 http://127.0.0.1:12990/debian sid/main amd64 liblapack3 amd64 3.9.0-1 [2168 kB]
Get:121 http://127.0.0.1:12990/debian sid/main amd64 libarpack2 amd64 3.7.0-3 [103 kB]
Get:122 http://127.0.0.1:12990/debian sid/main amd64 libsuitesparseconfig5 amd64 1:5.6.0+dfsg-2 [22.1 kB]
Get:123 http://127.0.0.1:12990/debian sid/main amd64 libamd2 amd64 1:5.6.0+dfsg-2 [34.5 kB]
Get:124 http://127.0.0.1:12990/debian sid/main amd64 libcamd2 amd64 1:5.6.0+dfsg-2 [36.1 kB]
Get:125 http://127.0.0.1:12990/debian sid/main amd64 libccolamd2 amd64 1:5.6.0+dfsg-2 [37.7 kB]
Get:126 http://127.0.0.1:12990/debian sid/main amd64 libcolamd2 amd64 1:5.6.0+dfsg-2 [31.4 kB]
Get:127 http://127.0.0.1:12990/debian sid/main amd64 libmetis5 amd64 5.1.0.dfsg-5+b2 [175 kB]
Get:128 http://127.0.0.1:12990/debian sid/main amd64 libcholmod3 amd64 1:5.6.0+dfsg-2 [323 kB]
Get:129 http://127.0.0.1:12990/debian sid/main amd64 libbrotli1 amd64 1.0.7-6 [266 kB]
Get:130 http://127.0.0.1:12990/debian sid/main amd64 libkeyutils1 amd64 1.6.1-2 [15.4 kB]
Get:131 http://127.0.0.1:12990/debian sid/main amd64 libkrb5support0 amd64 1.17-6 [64.6 kB]
Get:132 http://127.0.0.1:12990/debian sid/main amd64 libk5crypto3 amd64 1.17-6 [116 kB]
Get:133 http://127.0.0.1:12990/debian sid/main amd64 libkrb5-3 amd64 1.17-6 [366 kB]
Get:134 http://127.0.0.1:12990/debian sid/main amd64 libgssapi-krb5-2 amd64 1.17-6 [156 kB]
Get:135 http://127.0.0.1:12990/debian sid/main amd64 libsasl2-modules-db amd64 2.1.27+dfsg-2 [69.0 kB]
Get:136 http://127.0.0.1:12990/debian sid/main amd64 libsasl2-2 amd64 2.1.27+dfsg-2 [106 kB]
Get:137 http://127.0.0.1:12990/debian sid/main amd64 libldap-common all 2.4.49+dfsg-1 [91.9 kB]
Get:138 http://127.0.0.1:12990/debian sid/main amd64 libldap-2.4-2 amd64 2.4.49+dfsg-1 [226 kB]
Get:139 http://127.0.0.1:12990/debian sid/main amd64 libnghttp2-14 amd64 1.40.0-1 [85.0 kB]
Get:140 http://127.0.0.1:12990/debian sid/main amd64 libpsl5 amd64 0.20.2-2 [53.7 kB]
Get:141 http://127.0.0.1:12990/debian sid/main amd64 librtmp1 amd64 2.4+20151223.gitfa8646d.1-2+b1 [60.8 kB]
Get:142 http://127.0.0.1:12990/debian sid/main amd64 libssh2-1 amd64 1.8.0-2.1 [140 kB]
Get:143 http://127.0.0.1:12990/debian sid/main amd64 libcurl3-gnutls amd64 7.68.0-1 [319 kB]
Get:144 http://127.0.0.1:12990/debian sid/main amd64 libcxsparse3 amd64 1:5.6.0+dfsg-2 [78.4 kB]
Get:145 http://127.0.0.1:12990/debian sid/main amd64 libfftw3-single3 amd64 3.3.8-2 [762 kB]
Get:146 http://127.0.0.1:12990/debian sid/main amd64 libglvnd0 amd64 1.3.1-1 [51.1 kB]
Get:147 http://127.0.0.1:12990/debian sid/main amd64 libdrm-common all 2.4.100-4 [14.2 kB]
Get:148 http://127.0.0.1:12990/debian sid/main amd64 libdrm2 amd64 2.4.100-4 [40.7 kB]
Get:149 http://127.0.0.1:12990/debian sid/main amd64 libglapi-mesa amd64 19.3.3-1 [69.7 kB]
Get:150 http://127.0.0.1:12990/debian sid/main amd64 libx11-xcb1 amd64 2:1.6.8-1 [190 kB]
Get:151 http://127.0.0.1:12990/debian sid/main amd64 libxcb-dri2-0 amd64 1.13.1-5 [101 kB]
Get:152 http://127.0.0.1:12990/debian sid/main amd64 libxcb-dri3-0 amd64 1.13.1-5 [100 kB]
Get:153 http://127.0.0.1:12990/debian sid/main amd64 libxcb-glx0 amd64 1.13.1-5 [116 kB]
Get:154 http://127.0.0.1:12990/debian sid/main amd64 libxcb-present0 amd64 1.13.1-5 [99.3 kB]
Get:155 http://127.0.0.1:12990/debian sid/main amd64 libxcb-sync1 amd64 1.13.1-5 [103 kB]
Get:156 http://127.0.0.1:12990/debian sid/main amd64 libxfixes3 amd64 1:5.0.3-1 [21.9 kB]
Get:157 http://127.0.0.1:12990/debian sid/main amd64 libxdamage1 amd64 1:1.1.5-1 [15.7 kB]
Get:158 http://127.0.0.1:12990/debian sid/main amd64 libxshmfence1 amd64 1.3-1 [8820 B]
Get:159 http://127.0.0.1:12990/debian sid/main amd64 libxxf86vm1 amd64 1:1.1.4-1+b2 [20.8 kB]
Get:160 http://127.0.0.1:12990/debian sid/main amd64 libdrm-amdgpu1 amd64 2.4.100-4 [28.0 kB]
Get:161 http://127.0.0.1:12990/debian sid/main amd64 libpciaccess0 amd64 0.14-1 [53.5 kB]
Get:162 http://127.0.0.1:12990/debian sid/main amd64 libdrm-intel1 amd64 2.4.100-4 [70.1 kB]
Get:163 http://127.0.0.1:12990/debian sid/main amd64 libdrm-nouveau2 amd64 2.4.100-4 [26.3 kB]
Get:164 http://127.0.0.1:12990/debian sid/main amd64 libdrm-radeon1 amd64 2.4.100-4 [29.5 kB]
Get:165 http://127.0.0.1:12990/debian sid/main amd64 libsensors-config all 1:3.6.0-2 [32.0 kB]
Get:166 http://127.0.0.1:12990/debian sid/main amd64 libsensors5 amd64 1:3.6.0-2 [53.1 kB]
Get:167 http://127.0.0.1:12990/debian sid/main amd64 libvulkan1 amd64 1.2.131.2-1 [98.2 kB]
Get:168 http://127.0.0.1:12990/debian sid/main amd64 libgl1-mesa-dri amd64 19.3.3-1 [9219 kB]
Get:169 http://127.0.0.1:12990/debian sid/main amd64 libglx-mesa0 amd64 19.3.3-1 [183 kB]
Get:170 http://127.0.0.1:12990/debian sid/main amd64 libglx0 amd64 1.3.1-1 [34.6 kB]
Get:171 http://127.0.0.1:12990/debian sid/main amd64 libgl1 amd64 1.3.1-1 [89.3 kB]
Get:172 http://127.0.0.1:12990/debian sid/main amd64 libgl2ps1.4 amd64 1.4.0+dfsg1-2 [39.0 kB]
Get:173 http://127.0.0.1:12990/debian sid/main amd64 libglu1-mesa amd64 9.0.1-1 [168 kB]
Get:174 http://127.0.0.1:12990/debian sid/main amd64 libwmf0.2-7 amd64 0.2.8.4-17 [165 kB]
Get:175 http://127.0.0.1:12990/debian sid/main amd64 libgraphicsmagick-q16-3 amd64 1.4+really1.3.35-1 [1158 kB]
Get:176 http://127.0.0.1:12990/debian sid/main amd64 libgraphicsmagick++-q16-12 amd64 1.4+really1.3.35-1 [132 kB]
Get:177 http://127.0.0.1:12990/debian sid/main amd64 libaec0 amd64 1.0.4-1 [20.3 kB]
Get:178 http://127.0.0.1:12990/debian sid/main amd64 libsz2 amd64 1.0.4-1 [6760 B]
Get:179 http://127.0.0.1:12990/debian sid/main amd64 libhdf5-103 amd64 1.10.4+repack-11 [1339 kB]
Get:180 http://127.0.0.1:12990/debian sid/main amd64 libqrupdate1 amd64 1.1.2-3 [37.4 kB]
Get:181 http://127.0.0.1:12990/debian sid/main amd64 libumfpack5 amd64 1:5.6.0+dfsg-2 [245 kB]
Get:182 http://127.0.0.1:12990/debian sid/main amd64 liboctave7 amd64 5.2.0-1 [7895 kB]
Get:183 http://127.0.0.1:12990/debian sid/main amd64 libxrender1 amd64 1:0.9.10-1 [33.0 kB]
Get:184 http://127.0.0.1:12990/debian sid/main amd64 libxcursor1 amd64 1:1.2.0-2 [37.3 kB]
Get:185 http://127.0.0.1:12990/debian sid/main amd64 libxft2 amd64 2.3.2-2 [57.2 kB]
Get:186 http://127.0.0.1:12990/debian sid/main amd64 libxinerama1 amd64 2:1.1.4-2 [17.7 kB]
Get:187 http://127.0.0.1:12990/debian sid/main amd64 libfltk1.3 amd64 1.3.4-10 [560 kB]
Get:188 http://127.0.0.1:12990/debian sid/main amd64 libfltk-gl1.3 amd64 1.3.4-10 [73.6 kB]
Get:189 http://127.0.0.1:12990/debian sid/main amd64 libglpk40 amd64 4.65-2 [418 kB]
Get:190 http://127.0.0.1:12990/debian sid/main amd64 libasound2-data all 1.2.1.2-2 [38.2 kB]
Get:191 http://127.0.0.1:12990/debian sid/main amd64 libasound2 amd64 1.2.1.2-2 [348 kB]
Get:192 http://127.0.0.1:12990/debian sid/main amd64 libopus0 amd64 1.3-1+b1 [191 kB]
Get:193 http://127.0.0.1:12990/debian sid/main amd64 libsamplerate0 amd64 0.1.9-2 [949 kB]
Get:194 http://127.0.0.1:12990/debian sid/main amd64 libjack-jackd2-0 amd64 1.9.12~dfsg-2+b1 [303 kB]
Get:195 http://127.0.0.1:12990/debian sid/main amd64 libportaudio2 amd64 19.6.0-1 [66.6 kB]
Get:196 http://127.0.0.1:12990/debian sid/main amd64 libqhull7 amd64 2015.2-4 [196 kB]
Get:197 http://127.0.0.1:12990/debian sid/main amd64 libqscintilla2-qt5-l10n all 2.11.2+dfsg-5 [56.1 kB]
Get:198 http://127.0.0.1:12990/debian sid/main amd64 libdouble-conversion3 amd64 3.1.5-5 [40.4 kB]
Get:199 http://127.0.0.1:12990/debian sid/main amd64 libpcre2-16-0 amd64 10.34-7 [219 kB]
Get:200 http://127.0.0.1:12990/debian sid/main amd64 libqt5core5a amd64 5.12.5+dfsg-8 [2029 kB]
Get:201 http://127.0.0.1:12990/debian sid/main amd64 fontconfig amd64 2.13.1-2+b1 [405 kB]
Get:202 http://127.0.0.1:12990/debian sid/main amd64 libwayland-server0 amd64 1.18.0-1 [34.2 kB]
Get:203 http://127.0.0.1:12990/debian sid/main amd64 libgbm1 amd64 19.3.3-1 [70.6 kB]
Get:204 http://127.0.0.1:12990/debian sid/main amd64 libwayland-client0 amd64 1.18.0-1 [26.6 kB]
Get:205 http://127.0.0.1:12990/debian sid/main amd64 libxcb-xfixes0 amd64 1.13.1-5 [103 kB]
Get:206 http://127.0.0.1:12990/debian sid/main amd64 libegl-mesa0 amd64 19.3.3-1 [139 kB]
Get:207 http://127.0.0.1:12990/debian sid/main amd64 libegl1 amd64 1.3.1-1 [34.0 kB]
Get:208 http://127.0.0.1:12990/debian sid/main amd64 libgraphite2-3 amd64 1.3.13-11 [80.9 kB]
Get:209 http://127.0.0.1:12990/debian sid/main amd64 libharfbuzz0b amd64 2.6.4-1 [1360 kB]
Get:210 http://127.0.0.1:12990/debian sid/main amd64 x11-common all 1:7.7+20 [252 kB]
Get:211 http://127.0.0.1:12990/debian sid/main amd64 libice6 amd64 2:1.0.9-2 [58.7 kB]
Get:212 http://127.0.0.1:12990/debian sid/main amd64 libevdev2 amd64 1.8.901+dfsg-1 [33.3 kB]
Get:213 http://127.0.0.1:12990/debian sid/main amd64 libmtdev1 amd64 1.1.5-1.1 [22.4 kB]
Get:214 http://127.0.0.1:12990/debian sid/main amd64 libgudev-1.0-0 amd64 233-1 [13.8 kB]
Get:215 http://127.0.0.1:12990/debian sid/main amd64 libwacom-common all 1.1-2 [41.9 kB]
Get:216 http://127.0.0.1:12990/debian sid/main amd64 libwacom2 amd64 1.1-2 [20.3 kB]
Get:217 http://127.0.0.1:12990/debian sid/main amd64 libinput-bin amd64 1.15.2-1 [22.2 kB]
Get:218 http://127.0.0.1:12990/debian sid/main amd64 libinput10 amd64 1.15.2-1 [116 kB]
Get:219 http://127.0.0.1:12990/debian sid/main amd64 libdbus-1-3 amd64 1.12.16-2 [214 kB]
Get:220 http://127.0.0.1:12990/debian sid/main amd64 libqt5dbus5 amd64 5.12.5+dfsg-8 [239 kB]
Get:221 http://127.0.0.1:12990/debian sid/main amd64 libqt5network5 amd64 5.12.5+dfsg-8 [704 kB]
Get:222 http://127.0.0.1:12990/debian sid/main amd64 libsm6 amd64 2:1.2.3-1 [35.1 kB]
Get:223 http://127.0.0.1:12990/debian sid/main amd64 libxcb-icccm4 amd64 0.4.1-1.1 [27.4 kB]
Get:224 http://127.0.0.1:12990/debian sid/main amd64 libxcb-shm0 amd64 1.13.1-5 [99.3 kB]
Get:225 http://127.0.0.1:12990/debian sid/main amd64 libxcb-util0 amd64 0.3.8-3+b2 [23.0 kB]
Get:226 http://127.0.0.1:12990/debian sid/main amd64 libxcb-image0 amd64 0.4.0-1+b2 [24.4 kB]
Get:227 http://127.0.0.1:12990/debian sid/main amd64 libxcb-keysyms1 amd64 0.4.0-1+b2 [16.4 kB]
Get:228 http://127.0.0.1:12990/debian sid/main amd64 libxcb-randr0 amd64 1.13.1-5 [111 kB]
Get:229 http://127.0.0.1:12990/debian sid/main amd64 libxcb-render0 amd64 1.13.1-5 [109 kB]
Get:230 http://127.0.0.1:12990/debian sid/main amd64 libxcb-render-util0 amd64 0.3.9-1+b1 [18.3 kB]
Get:231 http://127.0.0.1:12990/debian sid/main amd64 libxcb-shape0 amd64 1.13.1-5 [99.7 kB]
Get:232 http://127.0.0.1:12990/debian sid/main amd64 libxcb-xinerama0 amd64 1.13.1-5 [99.0 kB]
Get:233 http://127.0.0.1:12990/debian sid/main amd64 libxcb-xinput0 amd64 1.13.1-5 [124 kB]
Get:234 http://127.0.0.1:12990/debian sid/main amd64 libxcb-xkb1 amd64 1.13.1-5 [124 kB]
Get:235 http://127.0.0.1:12990/debian sid/main amd64 xkb-data all 2.26-2 [681 kB]
Get:236 http://127.0.0.1:12990/debian sid/main amd64 libxkbcommon0 amd64 0.10.0-1 [123 kB]
Get:237 http://127.0.0.1:12990/debian sid/main amd64 libxkbcommon-x11-0 amd64 0.10.0-1 [39.4 kB]
Get:238 http://127.0.0.1:12990/debian sid/main amd64 libqt5gui5 amd64 5.12.5+dfsg-8 [2986 kB]
Get:239 http://127.0.0.1:12990/debian sid/main amd64 libavahi-common-data amd64 0.7-5 [122 kB]
Get:240 http://127.0.0.1:12990/debian sid/main amd64 libavahi-common3 amd64 0.7-5 [54.6 kB]
Get:241 http://127.0.0.1:12990/debian sid/main amd64 libavahi-client3 amd64 0.7-5 [58.2 kB]
Get:242 http://127.0.0.1:12990/debian sid/main amd64 libcups2 amd64 2.3.1-11 [349 kB]
Get:243 http://127.0.0.1:12990/debian sid/main amd64 libqt5widgets5 amd64 5.12.5+dfsg-8 [2321 kB]
Get:244 http://127.0.0.1:12990/debian sid/main amd64 libqt5printsupport5 amd64 5.12.5+dfsg-8 [224 kB]
Get:245 http://127.0.0.1:12990/debian sid/main amd64 libqscintilla2-qt5-15 amd64 2.11.2+dfsg-5 [1234 kB]
Get:246 http://127.0.0.1:12990/debian sid/main amd64 libqt5sql5 amd64 5.12.5+dfsg-8 [152 kB]
Get:247 http://127.0.0.1:12990/debian sid/main amd64 libqt5help5 amd64 5.12.5-2+b2 [141 kB]
Get:248 http://127.0.0.1:12990/debian sid/main amd64 libqt5xml5 amd64 5.12.5+dfsg-8 [136 kB]
Get:249 http://127.0.0.1:12990/debian sid/main amd64 libogg0 amd64 1.3.2-1+b1 [21.3 kB]
Get:250 http://127.0.0.1:12990/debian sid/main amd64 libflac8 amd64 1.3.3-1 [112 kB]
Get:251 http://127.0.0.1:12990/debian sid/main amd64 libvorbis0a amd64 1.3.6-2 [93.5 kB]
Get:252 http://127.0.0.1:12990/debian sid/main amd64 libvorbisenc2 amd64 1.3.6-2 [80.2 kB]
Get:253 http://127.0.0.1:12990/debian sid/main amd64 libsndfile1 amd64 1.0.28-7 [252 kB]
Get:254 http://127.0.0.1:12990/debian sid/main amd64 libtext-unidecode-perl all 1.30-1 [103 kB]
Get:255 http://127.0.0.1:12990/debian sid/main amd64 libxml-namespacesupport-perl all 1.12-1 [14.8 kB]
Get:256 http://127.0.0.1:12990/debian sid/main amd64 libxml-sax-base-perl all 1.09-1 [20.4 kB]
Get:257 http://127.0.0.1:12990/debian sid/main amd64 libxml-sax-perl all 1.02+dfsg-1 [59.0 kB]
Get:258 http://127.0.0.1:12990/debian sid/main amd64 libxml-libxml-perl amd64 2.0134+dfsg-1+b1 [344 kB]
Get:259 http://127.0.0.1:12990/debian sid/main amd64 texinfo amd64 6.7.0.dfsg.2-5 [1761 kB]
Get:260 http://127.0.0.1:12990/debian sid/main amd64 octave-common all 5.2.0-1 [5545 kB]
Get:261 http://127.0.0.1:12990/debian sid/main amd64 octave amd64 5.2.0-1 [2323 kB]
Get:262 http://127.0.0.1:12990/debian sid/main amd64 libncurses6 amd64 6.1+20191019-1 [102 kB]
Get:263 http://127.0.0.1:12990/debian sid/main amd64 libncurses-dev amd64 6.1+20191019-1 [337 kB]
Get:264 http://127.0.0.1:12990/debian sid/main amd64 libreadline-dev amd64 8.0-3 [140 kB]
Get:265 http://127.0.0.1:12990/debian sid/main amd64 zlib1g-dev amd64 1:1.2.11.dfsg-2 [190 kB]
Get:266 http://127.0.0.1:12990/debian sid/main amd64 libjpeg62-turbo-dev amd64 1:1.5.2-2+b1 [208 kB]
Get:267 http://127.0.0.1:12990/debian sid/main amd64 libjpeg-dev all 1:1.5.2-2 [57.5 kB]
Get:268 http://127.0.0.1:12990/debian sid/main amd64 libaec-dev amd64 1.0.4-1 [18.7 kB]
Get:269 http://127.0.0.1:12990/debian sid/main amd64 hdf5-helpers amd64 1.10.4+repack-11 [35.2 kB]
Get:270 http://127.0.0.1:12990/debian sid/main amd64 libhdf5-cpp-103 amd64 1.10.4+repack-11 [143 kB]
Get:271 http://127.0.0.1:12990/debian sid/main amd64 libhdf5-dev amd64 1.10.4+repack-11 [2608 kB]
Get:272 http://127.0.0.1:12990/debian sid/main amd64 xorg-sgml-doctools all 1:1.11-1 [21.9 kB]
Get:273 http://127.0.0.1:12990/debian sid/main amd64 x11proto-dev all 2018.4-4 [251 kB]
Get:274 http://127.0.0.1:12990/debian sid/main amd64 x11proto-core-dev all 2018.4-4 [3128 B]
Get:275 http://127.0.0.1:12990/debian sid/main amd64 libxau-dev amd64 1:1.0.8-1+b2 [23.1 kB]
Get:276 http://127.0.0.1:12990/debian sid/main amd64 libxdmcp-dev amd64 1:1.1.2-3 [42.2 kB]
Get:277 http://127.0.0.1:12990/debian sid/main amd64 xtrans-dev all 1.3.5-1 [100 kB]
Get:278 http://127.0.0.1:12990/debian sid/main amd64 libpthread-stubs0-dev amd64 0.4-1 [5344 B]
Get:279 http://127.0.0.1:12990/debian sid/main amd64 libxcb1-dev amd64 1.13.1-5 [174 kB]
Get:280 http://127.0.0.1:12990/debian sid/main amd64 libx11-dev amd64 2:1.6.8-1 [822 kB]
Get:281 http://127.0.0.1:12990/debian sid/main amd64 libglx-dev amd64 1.3.1-1 [16.2 kB]
Get:282 http://127.0.0.1:12990/debian sid/main amd64 libgl-dev amd64 1.3.1-1 [100 kB]
Get:283 http://127.0.0.1:12990/debian sid/main amd64 libegl-dev amd64 1.3.1-1 [19.2 kB]
Get:284 http://127.0.0.1:12990/debian sid/main amd64 libgles1 amd64 1.3.1-1 [12.5 kB]
Get:285 http://127.0.0.1:12990/debian sid/main amd64 libgles2 amd64 1.3.1-1 [17.8 kB]
Get:286 http://127.0.0.1:12990/debian sid/main amd64 libgles-dev amd64 1.3.1-1 [50.3 kB]
Get:287 http://127.0.0.1:12990/debian sid/main amd64 libopengl0 amd64 1.3.1-1 [31.5 kB]
Get:288 http://127.0.0.1:12990/debian sid/main amd64 libopengl-dev amd64 1.3.1-1 [5824 B]
Get:289 http://127.0.0.1:12990/debian sid/main amd64 libglvnd-dev amd64 1.3.1-1 [13.8 kB]
Get:290 http://127.0.0.1:12990/debian sid/main amd64 libgl1-mesa-dev amd64 19.3.3-1 [49.2 kB]
Get:291 http://127.0.0.1:12990/debian sid/main amd64 libblas-dev amd64 3.9.0-1 [160 kB]
Get:292 http://127.0.0.1:12990/debian sid/main amd64 liblapack-dev amd64 3.9.0-1 [4256 kB]
Get:293 http://127.0.0.1:12990/debian sid/main amd64 libfftw3-long3 amd64 3.3.8-2 [319 kB]
Get:294 http://127.0.0.1:12990/debian sid/main amd64 libfftw3-quad3 amd64 3.3.8-2 [558 kB]
Get:295 http://127.0.0.1:12990/debian sid/main amd64 libfftw3-bin amd64 3.3.8-2 [50.7 kB]
Get:296 http://127.0.0.1:12990/debian sid/main amd64 libfftw3-dev amd64 3.3.8-2 [2106 kB]
Get:297 http://127.0.0.1:12990/debian sid/main amd64 libgfortran-9-dev amd64 9.2.1-30 [676 kB]
Get:298 http://127.0.0.1:12990/debian sid/main amd64 gfortran-9 amd64 9.2.1-30 [10.4 MB]
Get:299 http://127.0.0.1:12990/debian sid/main amd64 gfortran amd64 4:9.2.1-3.1 [1432 B]
Get:300 http://127.0.0.1:12990/debian sid/main amd64 liboctave-dev amd64 5.2.0-1 [833 kB]
Get:301 http://127.0.0.1:12990/debian sid/main amd64 libapt-pkg-perl amd64 0.1.36+b2 [71.3 kB]
Get:302 http://127.0.0.1:12990/debian sid/main amd64 libarray-intspan-perl all 2.003-1 [24.1 kB]
Get:303 http://127.0.0.1:12990/debian sid/main amd64 libyaml-0-2 amd64 0.2.2-1 [49.6 kB]
Get:304 http://127.0.0.1:12990/debian sid/main amd64 libyaml-libyaml-perl amd64 0.81+repack-1 [35.4 kB]
Get:305 http://127.0.0.1:12990/debian sid/main amd64 libconfig-model-backend-yaml-perl all 2.133-2 [10.8 kB]
Get:306 http://127.0.0.1:12990/debian sid/main amd64 libexporter-lite-perl all 0.08-1 [11.1 kB]
Get:307 http://127.0.0.1:12990/debian sid/main amd64 libalgorithm-c3-perl all 0.10-1 [12.0 kB]
Get:308 http://127.0.0.1:12990/debian sid/main amd64 libclass-c3-perl all 0.34-1 [22.4 kB]
Get:309 http://127.0.0.1:12990/debian sid/main amd64 libmro-compat-perl all 0.13-1 [12.2 kB]
Get:310 http://127.0.0.1:12990/debian sid/main amd64 libdata-section-perl all 0.200007-1 [13.4 kB]
Get:311 http://127.0.0.1:12990/debian sid/main amd64 libtext-template-perl all 1.58-1 [54.1 kB]
Get:312 http://127.0.0.1:12990/debian sid/main amd64 libsoftware-license-perl all 0.103014-2 [113 kB]
Get:313 http://127.0.0.1:12990/debian sid/main amd64 libyaml-tiny-perl all 1.73-1 [32.3 kB]
Get:314 http://127.0.0.1:12990/debian sid/main amd64 libsoftware-licensemoreutils-perl all 1.004-1 [20.2 kB]
Get:315 http://127.0.0.1:12990/debian sid/main amd64 libsort-versions-perl all 1.62-1 [11.0 kB]
Get:316 http://127.0.0.1:12990/debian sid/main amd64 libtext-reform-perl all 1.20-3 [37.3 kB]
Get:317 http://127.0.0.1:12990/debian sid/main amd64 libtext-autoformat-perl all 1.750000-1 [35.1 kB]
Get:318 http://127.0.0.1:12990/debian sid/main amd64 libtext-levenshtein-damerau-perl all 0.41-1 [13.2 kB]
Get:319 http://127.0.0.1:12990/debian sid/main amd64 liburi-perl all 1.76-2 [90.2 kB]
Get:320 http://127.0.0.1:12990/debian sid/main amd64 libencode-locale-perl all 1.05-1 [13.7 kB]
Get:321 http://127.0.0.1:12990/debian sid/main amd64 libtimedate-perl all 2.3100-1 [39.0 kB]
Get:322 http://127.0.0.1:12990/debian sid/main amd64 libhttp-date-perl all 6.05-1 [10.4 kB]
Get:323 http://127.0.0.1:12990/debian sid/main amd64 libfile-listing-perl all 6.04-1 [10.3 kB]
Get:324 http://127.0.0.1:12990/debian sid/main amd64 libhtml-tagset-perl all 3.20-4 [13.0 kB]
Get:325 http://127.0.0.1:12990/debian sid/main amd64 libhtml-parser-perl amd64 3.72-5 [105 kB]
Get:326 http://127.0.0.1:12990/debian sid/main amd64 libhtml-tree-perl all 5.07-2 [213 kB]
Get:327 http://127.0.0.1:12990/debian sid/main amd64 libio-html-perl all 1.001-1 [17.6 kB]
Get:328 http://127.0.0.1:12990/debian sid/main amd64 liblwp-mediatypes-perl all 6.04-1 [19.9 kB]
Get:329 http://127.0.0.1:12990/debian sid/main amd64 libhttp-message-perl all 6.18-1 [77.8 kB]
Get:330 http://127.0.0.1:12990/debian sid/main amd64 libhttp-cookies-perl all 6.08-1 [19.3 kB]
Get:331 http://127.0.0.1:12990/debian sid/main amd64 libhttp-negotiate-perl all 6.01-1 [12.8 kB]
Get:332 http://127.0.0.1:12990/debian sid/main amd64 perl-openssl-defaults amd64 4 [7148 B]
Get:333 http://127.0.0.1:12990/debian sid/main amd64 libnet-ssleay-perl amd64 1.88-2 [321 kB]
Get:334 http://127.0.0.1:12990/debian sid/main amd64 libio-socket-ssl-perl all 2.067-1 [212 kB]
Get:335 http://127.0.0.1:12990/debian sid/main amd64 libnet-http-perl all 6.19-1 [24.8 kB]
Get:336 http://127.0.0.1:12990/debian sid/main amd64 liblwp-protocol-https-perl all 6.07-2 [9242 B]
Get:337 http://127.0.0.1:12990/debian sid/main amd64 libwww-robotrules-perl all 6.02-1 [12.9 kB]
Get:338 http://127.0.0.1:12990/debian sid/main amd64 libwww-perl all 6.43-1 [191 kB]
Get:339 http://127.0.0.1:12990/debian sid/main amd64 liblist-someutils-perl all 0.58-1 [36.5 kB]
Get:340 http://127.0.0.1:12990/debian sid/main amd64 liblog-any-perl all 1.708-1 [73.4 kB]
Get:341 http://127.0.0.1:12990/debian sid/main amd64 liblog-any-adapter-screen-perl all 0.140-1 [13.1 kB]
Get:342 http://127.0.0.1:12990/debian sid/main amd64 libclass-method-modifiers-perl all 2.13-1 [19.2 kB]
Get:343 http://127.0.0.1:12990/debian sid/main amd64 libimport-into-perl all 1.002005-1 [11.6 kB]
Get:344 http://127.0.0.1:12990/debian sid/main amd64 librole-tiny-perl all 2.001004-1 [20.8 kB]
Get:345 http://127.0.0.1:12990/debian sid/main amd64 libstrictures-perl all 2.000006-1 [18.6 kB]
Get:346 http://127.0.0.1:12990/debian sid/main amd64 libsub-quote-perl all 2.006006-1 [21.0 kB]
Get:347 http://127.0.0.1:12990/debian sid/main amd64 libmoo-perl all 2.003006-1 [58.7 kB]
Get:348 http://127.0.0.1:12990/debian sid/main amd64 libsub-exporter-progressive-perl all 0.001013-1 [7588 B]
Get:349 http://127.0.0.1:12990/debian sid/main amd64 libvariable-magic-perl amd64 0.62-1+b2 [46.0 kB]
Get:350 http://127.0.0.1:12990/debian sid/main amd64 libb-hooks-endofscope-perl all 0.24-1 [18.6 kB]
Get:351 http://127.0.0.1:12990/debian sid/main amd64 libsub-identify-perl amd64 0.14-1+b2 [12.0 kB]
Get:352 http://127.0.0.1:12990/debian sid/main amd64 libsub-name-perl amd64 0.26-1 [13.5 kB]
Get:353 http://127.0.0.1:12990/debian sid/main amd64 libnamespace-clean-perl all 0.27-1 [17.3 kB]
Get:354 http://127.0.0.1:12990/debian sid/main amd64 libhash-fieldhash-perl amd64 0.15-1+b2 [18.0 kB]
Get:355 http://127.0.0.1:12990/debian sid/main amd64 libobject-id-perl all 0.1.2-2 [16.5 kB]
Get:356 http://127.0.0.1:12990/debian sid/main amd64 libtype-tiny-perl all 1.008001-2 [331 kB]
Get:357 http://127.0.0.1:12990/debian sid/main amd64 libmoox-struct-perl all 0.017-1 [25.0 kB]
Get:358 http://127.0.0.1:12990/debian sid/main amd64 libnumber-compare-perl all 0.03-1 [7642 B]
Get:359 http://127.0.0.1:12990/debian sid/main amd64 libtext-glob-perl all 0.10-1 [8362 B]
Get:360 http://127.0.0.1:12990/debian sid/main amd64 libpath-iterator-rule-perl all 1.014-1 [54.0 kB]
Get:361 http://127.0.0.1:12990/debian sid/main amd64 libpod-constants-perl all 0.19-1 [16.9 kB]
Get:362 http://127.0.0.1:12990/debian sid/main amd64 libre2-5 amd64 20200101+dfsg-1 [164 kB]
Get:363 http://127.0.0.1:12990/debian sid/main amd64 libre-engine-re2-perl amd64 0.13-5 [17.0 kB]
Get:364 http://127.0.0.1:12990/debian sid/main amd64 libregexp-pattern-license-perl all 3.2.0-1 [40.2 kB]
Get:365 http://127.0.0.1:12990/debian sid/main amd64 libregexp-pattern-perl all 0.2.12-1 [18.3 kB]
Get:366 http://127.0.0.1:12990/debian sid/main amd64 libsort-key-perl amd64 1.33-2+b2 [37.1 kB]
Get:367 http://127.0.0.1:12990/debian sid/main amd64 libnumber-range-perl all 0.12-1 [9274 B]
Get:368 http://127.0.0.1:12990/debian sid/main amd64 libstring-copyright-perl all 0.003006-1 [11.6 kB]
Get:369 http://127.0.0.1:12990/debian sid/main amd64 libstring-escape-perl all 2010.002-2 [19.1 kB]
Get:370 http://127.0.0.1:12990/debian sid/main amd64 licensecheck all 3.0.45-1 [35.3 kB]
Get:371 http://127.0.0.1:12990/debian sid/main amd64 diffstat amd64 1.63-1 [35.6 kB]
Get:372 http://127.0.0.1:12990/debian sid/main amd64 libassuan0 amd64 2.5.3-7 [50.4 kB]
Get:373 http://127.0.0.1:12990/debian sid/main amd64 gpgconf amd64 2.2.19-1 [529 kB]
Get:374 http://127.0.0.1:12990/debian sid/main amd64 libsqlite3-0 amd64 3.31.1-3 [661 kB]
Get:375 http://127.0.0.1:12990/debian sid/main amd64 gpg amd64 2.2.19-1 [889 kB]
Get:376 http://127.0.0.1:12990/debian sid/main amd64 libberkeleydb-perl amd64 0.62-1+b1 [124 kB]
Get:377 http://127.0.0.1:12990/debian sid/main amd64 libcgi-pm-perl all 4.46-1 [223 kB]
Get:378 http://127.0.0.1:12990/debian sid/main amd64 libclass-accessor-perl all 0.51-1 [23.2 kB]
Get:379 http://127.0.0.1:12990/debian sid/main amd64 libclass-xsaccessor-perl amd64 1.19-3+b3 [38.4 kB]
Get:380 http://127.0.0.1:12990/debian sid/main amd64 libclone-perl amd64 0.43-2 [15.0 kB]
Get:381 http://127.0.0.1:12990/debian sid/main amd64 libdevel-size-perl amd64 0.83-1+b1 [26.0 kB]
Get:382 http://127.0.0.1:12990/debian sid/main amd64 libnet-smtp-ssl-perl all 1.04-1 [6184 B]
Get:383 http://127.0.0.1:12990/debian sid/main amd64 libmailtools-perl all 2.21-1 [95.5 kB]
Get:384 http://127.0.0.1:12990/debian sid/main amd64 libdigest-hmac-perl all 1.03+dfsg-2 [10.6 kB]
Get:385 http://127.0.0.1:12990/debian sid/main amd64 libnet-ip-perl all 1.26-2 [29.0 kB]
Get:386 http://127.0.0.1:12990/debian sid/main amd64 libnet-dns-perl all 1.22-1 [369 kB]
Get:387 http://127.0.0.1:12990/debian sid/main amd64 libnet-domain-tld-perl all 1.75-1 [33.3 kB]
Get:388 http://127.0.0.1:12990/debian sid/main amd64 libemail-valid-perl all 1.202-1 [23.0 kB]
Get:389 http://127.0.0.1:12990/debian sid/main amd64 libipc-system-simple-perl all 1.26-1 [27.1 kB]
Get:390 http://127.0.0.1:12990/debian sid/main amd64 libfile-basedir-perl all 0.08-1 [17.7 kB]
Get:391 http://127.0.0.1:12990/debian sid/main amd64 libfile-find-rule-perl all 0.34-1 [30.6 kB]
Get:392 http://127.0.0.1:12990/debian sid/main amd64 libio-string-perl all 1.08-3 [12.3 kB]
Get:393 http://127.0.0.1:12990/debian sid/main amd64 libfont-ttf-perl all 1.06-1 [317 kB]
Get:394 http://127.0.0.1:12990/debian sid/main amd64 libfuture-perl all 0.43-1 [83.2 kB]
Get:395 http://127.0.0.1:12990/debian sid/main amd64 libstruct-dumb-perl all 0.09-1 [11.1 kB]
Get:396 http://127.0.0.1:12990/debian sid/main amd64 libio-async-perl all 0.75-1 [269 kB]
Get:397 http://127.0.0.1:12990/debian sid/main amd64 liblinux-epoll-perl amd64 0.017-1 [16.8 kB]
Get:398 http://127.0.0.1:12990/debian sid/main amd64 libio-async-loop-epoll-perl all 0.20-1 [11.9 kB]
Get:399 http://127.0.0.1:12990/debian sid/main amd64 libio-pty-perl amd64 1:1.12-1 [36.3 kB]
Get:400 http://127.0.0.1:12990/debian sid/main amd64 libipc-run-perl all 20180523.0-2 [101 kB]
Get:401 http://127.0.0.1:12990/debian sid/main amd64 liblist-compare-perl all 0.53-1 [68.9 kB]
Get:402 http://127.0.0.1:12990/debian sid/main amd64 libmldbm-perl all 2.05-2 [18.4 kB]
Get:403 http://127.0.0.1:12990/debian sid/main amd64 libmoox-aliases-perl all 0.001006-1 [10.2 kB]
Get:404 http://127.0.0.1:12990/debian sid/main amd64 libtext-levenshtein-perl all 0.13-1 [11.1 kB]
Get:405 http://127.0.0.1:12990/debian sid/main amd64 patchutils amd64 0.3.4-2+b1 [91.4 kB]
Get:406 http://127.0.0.1:12990/debian sid/main amd64 t1utils amd64 1.41-3 [62.3 kB]
Get:407 http://127.0.0.1:12990/debian sid/main amd64 lintian all 2.55.0 [1312 kB]
Get:408 http://127.0.0.1:12990/debian sid/main amd64 libconfig-model-dpkg-perl all 2.129 [204 kB]
Get:409 http://127.0.0.1:12990/debian sid/main amd64 liberror-perl all 0.17029-1 [31.0 kB]
Get:410 http://127.0.0.1:12990/debian sid/main amd64 libparse-debcontrol-perl all 2.005-4 [25.7 kB]
Get:411 http://127.0.0.1:12990/debian sid/main amd64 libconvert-binhex-perl all 1.125-1 [30.5 kB]
Get:412 http://127.0.0.1:12990/debian sid/main amd64 libmime-tools-perl all 5.509-1 [212 kB]
Get:413 http://127.0.0.1:12990/debian sid/main amd64 gnuplot-data all 5.2.8+dfsg1-1 [182 kB]
Get:414 http://127.0.0.1:12990/debian sid/main amd64 libpixman-1-0 amd64 0.36.0-1 [537 kB]
Get:415 http://127.0.0.1:12990/debian sid/main amd64 libcairo2 amd64 1.16.0-4 [689 kB]
Get:416 http://127.0.0.1:12990/debian sid/main amd64 libxpm4 amd64 1:3.5.12-1 [49.1 kB]
Get:417 http://127.0.0.1:12990/debian sid/main amd64 libgd3 amd64 2.2.5-5.2 [136 kB]
Get:418 http://127.0.0.1:12990/debian sid/main amd64 liblua5.3-0 amd64 5.3.3-1.1+b1 [120 kB]
Get:419 http://127.0.0.1:12990/debian sid/main amd64 libfribidi0 amd64 1.0.8-2 [64.8 kB]
Get:420 http://127.0.0.1:12990/debian sid/main amd64 libthai-data all 0.1.28-3 [170 kB]
Get:421 http://127.0.0.1:12990/debian sid/main amd64 libdatrie1 amd64 0.2.12-3 [39.5 kB]
Get:422 http://127.0.0.1:12990/debian sid/main amd64 libthai0 amd64 0.1.28-3 [54.2 kB]
Get:423 http://127.0.0.1:12990/debian sid/main amd64 libpango-1.0-0 amd64 1.42.4-8 [186 kB]
Get:424 http://127.0.0.1:12990/debian sid/main amd64 libpangoft2-1.0-0 amd64 1.42.4-8 [68.2 kB]
Get:425 http://127.0.0.1:12990/debian sid/main amd64 libpangocairo-1.0-0 amd64 1.42.4-8 [55.7 kB]
Get:426 http://127.0.0.1:12990/debian sid/main amd64 gnuplot-nox amd64 5.2.8+dfsg1-1 [931 kB]
Get:427 http://127.0.0.1:12990/debian sid/main amd64 fonts-freefont-otf all 20120503-9 [3169 kB]
Get:428 http://127.0.0.1:12990/debian sid/main amd64 dh-octave-autopkgtest all 0.7.3 [8852 B]
Get:429 http://127.0.0.1:12990/debian sid/main amd64 dh-octave all 0.7.3 [21.2 kB]
Get:430 http://127.0.0.1:12990/debian sid/main amd64 fonts-urw-base35 all 20170801.1-3 [6333 kB]
Get:431 http://127.0.0.1:12990/debian sid/main amd64 libgs9-common all 9.50~dfsg-5 [725 kB]
Get:432 http://127.0.0.1:12990/debian sid/main amd64 libidn11 amd64 1.33-2.2 [116 kB]
Get:433 http://127.0.0.1:12990/debian sid/main amd64 libijs-0.35 amd64 0.35-15 [16.4 kB]
Get:434 http://127.0.0.1:12990/debian sid/main amd64 libjbig2dec0 amd64 0.17-1 [63.5 kB]
Get:435 http://127.0.0.1:12990/debian sid/main amd64 libpaper1 amd64 1.1.28+b1 [21.6 kB]
Get:436 http://127.0.0.1:12990/debian sid/main amd64 libgs9 amd64 9.50~dfsg-5 [2227 kB]
Get:437 http://127.0.0.1:12990/debian sid/main amd64 ghostscript amd64 9.50~dfsg-5 [95.8 kB]
Get:438 http://127.0.0.1:12990/debian sid/main amd64 hicolor-icon-theme all 0.17-2 [11.4 kB]
Get:439 http://127.0.0.1:12990/debian sid/main amd64 imagemagick-6.q16 amd64 8:6.9.10.23+dfsg-2.1+b2 [580 kB]
Get:440 http://127.0.0.1:12990/debian sid/main amd64 imagemagick amd64 8:6.9.10.23+dfsg-2.1+b2 [156 kB]
Get:441 http://127.0.0.1:12990/debian sid/main amd64 libgmpxx4ldbl amd64 2:6.2.0+dfsg-4 [23.0 kB]
Get:442 http://127.0.0.1:12990/debian sid/main amd64 libgmp-dev amd64 2:6.2.0+dfsg-4 [643 kB]
Get:443 http://127.0.0.1:12990/debian sid/main amd64 libmpfr-dev amd64 4.0.2-1 [246 kB]
debconf: delaying package configuration, since apt-utils is not installed
Fetched 147 MB in 2s (84.4 MB/s)
Selecting previously unselected package bsdmainutils.
(Reading database ... 13921 files and directories currently installed.)
Preparing to unpack .../000-bsdmainutils_11.1.2+b1_amd64.deb ...
Unpacking bsdmainutils (11.1.2+b1) ...
Selecting previously unselected package libuchardet0:amd64.
Preparing to unpack .../001-libuchardet0_0.0.6-3_amd64.deb ...
Unpacking libuchardet0:amd64 (0.0.6-3) ...
Selecting previously unselected package groff-base.
Preparing to unpack .../002-groff-base_1.22.4-4_amd64.deb ...
Unpacking groff-base (1.22.4-4) ...
Selecting previously unselected package libpipeline1:amd64.
Preparing to unpack .../003-libpipeline1_1.5.2-2_amd64.deb ...
Unpacking libpipeline1:amd64 (1.5.2-2) ...
Selecting previously unselected package man-db.
Preparing to unpack .../004-man-db_2.9.0-2_amd64.deb ...
Unpacking man-db (2.9.0-2) ...
Selecting previously unselected package libfftw3-double3:amd64.
Preparing to unpack .../005-libfftw3-double3_3.3.8-2_amd64.deb ...
Unpacking libfftw3-double3:amd64 (3.3.8-2) ...
Selecting previously unselected package libexpat1:amd64.
Preparing to unpack .../006-libexpat1_2.2.9-1_amd64.deb ...
Unpacking libexpat1:amd64 (2.2.9-1) ...
Selecting previously unselected package libpng16-16:amd64.
Preparing to unpack .../007-libpng16-16_1.6.37-2_amd64.deb ...
Unpacking libpng16-16:amd64 (1.6.37-2) ...
Selecting previously unselected package libfreetype6:amd64.
Preparing to unpack .../008-libfreetype6_2.10.1-2_amd64.deb ...
Unpacking libfreetype6:amd64 (2.10.1-2) ...
Selecting previously unselected package sensible-utils.
Preparing to unpack .../009-sensible-utils_0.0.12+nmu1_all.deb ...
Unpacking sensible-utils (0.0.12+nmu1) ...
Selecting previously unselected package ucf.
Preparing to unpack .../010-ucf_3.0038+nmu1_all.deb ...
Moving old data out of the way
Unpacking ucf (3.0038+nmu1) ...
Selecting previously unselected package fonts-dejavu-core.
Preparing to unpack .../011-fonts-dejavu-core_2.37-1_all.deb ...
Unpacking fonts-dejavu-core (2.37-1) ...
Selecting previously unselected package fontconfig-config.
Preparing to unpack .../012-fontconfig-config_2.13.1-2_all.deb ...
Unpacking fontconfig-config (2.13.1-2) ...
Selecting previously unselected package libfontconfig1:amd64.
Preparing to unpack .../013-libfontconfig1_2.13.1-2+b1_amd64.deb ...
Unpacking libfontconfig1:amd64 (2.13.1-2+b1) ...
Selecting previously unselected package libde265-0:amd64.
Preparing to unpack .../014-libde265-0_1.0.4-1_amd64.deb ...
Unpacking libde265-0:amd64 (1.0.4-1) ...
Selecting previously unselected package libnuma1:amd64.
Preparing to unpack .../015-libnuma1_2.0.12-1+b1_amd64.deb ...
Unpacking libnuma1:amd64 (2.0.12-1+b1) ...
Selecting previously unselected package libx265-179:amd64.
Preparing to unpack .../016-libx265-179_3.2.1-1_amd64.deb ...
Unpacking libx265-179:amd64 (3.2.1-1) ...
Selecting previously unselected package libheif1:amd64.
Preparing to unpack .../017-libheif1_1.6.1-1_amd64.deb ...
Unpacking libheif1:amd64 (1.6.1-1) ...
Selecting previously unselected package libjbig0:amd64.
Preparing to unpack .../018-libjbig0_2.1-3.1+b2_amd64.deb ...
Unpacking libjbig0:amd64 (2.1-3.1+b2) ...
Selecting previously unselected package libjpeg62-turbo:amd64.
Preparing to unpack .../019-libjpeg62-turbo_1%3a1.5.2-2+b1_amd64.deb ...
Unpacking libjpeg62-turbo:amd64 (1:1.5.2-2+b1) ...
Selecting previously unselected package liblcms2-2:amd64.
Preparing to unpack .../020-liblcms2-2_2.9-4_amd64.deb ...
Unpacking liblcms2-2:amd64 (2.9-4) ...
Selecting previously unselected package libglib2.0-0:amd64.
Preparing to unpack .../021-libglib2.0-0_2.62.4-2_amd64.deb ...
Unpacking libglib2.0-0:amd64 (2.62.4-2) ...
Selecting previously unselected package liblqr-1-0:amd64.
Preparing to unpack .../022-liblqr-1-0_0.4.2-2.1_amd64.deb ...
Unpacking liblqr-1-0:amd64 (0.4.2-2.1) ...
Selecting previously unselected package libltdl7:amd64.
Preparing to unpack .../023-libltdl7_2.4.6-13_amd64.deb ...
Unpacking libltdl7:amd64 (2.4.6-13) ...
Selecting previously unselected package libopenjp2-7:amd64.
Preparing to unpack .../024-libopenjp2-7_2.3.1-1_amd64.deb ...
Unpacking libopenjp2-7:amd64 (2.3.1-1) ...
Selecting previously unselected package libwebp6:amd64.
Preparing to unpack .../025-libwebp6_0.6.1-2+b1_amd64.deb ...
Unpacking libwebp6:amd64 (0.6.1-2+b1) ...
Selecting previously unselected package libtiff5:amd64.
Preparing to unpack .../026-libtiff5_4.1.0+git191117-2_amd64.deb ...
Unpacking libtiff5:amd64 (4.1.0+git191117-2) ...
Selecting previously unselected package libwebpmux3:amd64.
Preparing to unpack .../027-libwebpmux3_0.6.1-2+b1_amd64.deb ...
Unpacking libwebpmux3:amd64 (0.6.1-2+b1) ...
Selecting previously unselected package libxau6:amd64.
Preparing to unpack .../028-libxau6_1%3a1.0.8-1+b2_amd64.deb ...
Unpacking libxau6:amd64 (1:1.0.8-1+b2) ...
Selecting previously unselected package libxdmcp6:amd64.
Preparing to unpack .../029-libxdmcp6_1%3a1.1.2-3_amd64.deb ...
Unpacking libxdmcp6:amd64 (1:1.1.2-3) ...
Selecting previously unselected package libxcb1:amd64.
Preparing to unpack .../030-libxcb1_1.13.1-5_amd64.deb ...
Unpacking libxcb1:amd64 (1.13.1-5) ...
Selecting previously unselected package libx11-data.
Preparing to unpack .../031-libx11-data_2%3a1.6.8-1_all.deb ...
Unpacking libx11-data (2:1.6.8-1) ...
Selecting previously unselected package libx11-6:amd64.
Preparing to unpack .../032-libx11-6_2%3a1.6.8-1_amd64.deb ...
Unpacking libx11-6:amd64 (2:1.6.8-1) ...
Selecting previously unselected package libxext6:amd64.
Preparing to unpack .../033-libxext6_2%3a1.3.3-1+b2_amd64.deb ...
Unpacking libxext6:amd64 (2:1.3.3-1+b2) ...
Selecting previously unselected package libicu63:amd64.
Preparing to unpack .../034-libicu63_63.2-2_amd64.deb ...
Unpacking libicu63:amd64 (63.2-2) ...
Selecting previously unselected package libxml2:amd64.
Preparing to unpack .../035-libxml2_2.9.10+dfsg-3_amd64.deb ...
Unpacking libxml2:amd64 (2.9.10+dfsg-3) ...
Selecting previously unselected package imagemagick-6-common.
Preparing to unpack .../036-imagemagick-6-common_8%3a6.9.10.23+dfsg-2.1_all.deb ...
Unpacking imagemagick-6-common (8:6.9.10.23+dfsg-2.1) ...
Selecting previously unselected package libmagickcore-6.q16-6:amd64.
Preparing to unpack .../037-libmagickcore-6.q16-6_8%3a6.9.10.23+dfsg-2.1+b2_amd64.deb ...
Unpacking libmagickcore-6.q16-6:amd64 (8:6.9.10.23+dfsg-2.1+b2) ...
Selecting previously unselected package libmagickwand-6.q16-6:amd64.
Preparing to unpack .../038-libmagickwand-6.q16-6_8%3a6.9.10.23+dfsg-2.1+b2_amd64.deb ...
Unpacking libmagickwand-6.q16-6:amd64 (8:6.9.10.23+dfsg-2.1+b2) ...
Selecting previously unselected package poppler-data.
Preparing to unpack .../039-poppler-data_0.4.9-2_all.deb ...
Unpacking poppler-data (0.4.9-2) ...
Selecting previously unselected package tex-common.
Preparing to unpack .../040-tex-common_6.13_all.deb ...
Unpacking tex-common (6.13) ...
Selecting previously unselected package readline-common.
Preparing to unpack .../041-readline-common_8.0-3_all.deb ...
Unpacking readline-common (8.0-3) ...
Selecting previously unselected package libreadline8:amd64.
Preparing to unpack .../042-libreadline8_8.0-3_amd64.deb ...
Unpacking libreadline8:amd64 (8.0-3) ...
Selecting previously unselected package netbase.
Preparing to unpack .../043-netbase_6.1_all.deb ...
Unpacking netbase (6.1) ...
Selecting previously unselected package libmagic-mgc.
Preparing to unpack .../044-libmagic-mgc_1%3a5.38-4_amd64.deb ...
Unpacking libmagic-mgc (1:5.38-4) ...
Selecting previously unselected package libmagic1:amd64.
Preparing to unpack .../045-libmagic1_1%3a5.38-4_amd64.deb ...
Unpacking libmagic1:amd64 (1:5.38-4) ...
Selecting previously unselected package file.
Preparing to unpack .../046-file_1%3a5.38-4_amd64.deb ...
Unpacking file (1:5.38-4) ...
Selecting previously unselected package gettext-base.
Preparing to unpack .../047-gettext-base_0.19.8.1-10_amd64.deb ...
Unpacking gettext-base (0.19.8.1-10) ...
Selecting previously unselected package aglfn.
Preparing to unpack .../048-aglfn_1.7+git20191031.4036a9c-2_all.deb ...
Unpacking aglfn (1.7+git20191031.4036a9c-2) ...
Selecting previously unselected package libsigsegv2:amd64.
Preparing to unpack .../049-libsigsegv2_2.12-2_amd64.deb ...
Unpacking libsigsegv2:amd64 (2.12-2) ...
Selecting previously unselected package m4.
Preparing to unpack .../050-m4_1.4.18-4_amd64.deb ...
Unpacking m4 (1.4.18-4) ...
Selecting previously unselected package autoconf.
Preparing to unpack .../051-autoconf_2.69-11.1_all.deb ...
Unpacking autoconf (2.69-11.1) ...
Selecting previously unselected package autotools-dev.
Preparing to unpack .../052-autotools-dev_20180224.1_all.deb ...
Unpacking autotools-dev (20180224.1) ...
Selecting previously unselected package automake.
Preparing to unpack .../053-automake_1%3a1.16.1-4_all.deb ...
Unpacking automake (1:1.16.1-4) ...
Selecting previously unselected package autopoint.
Preparing to unpack .../054-autopoint_0.19.8.1-10_all.deb ...
Unpacking autopoint (0.19.8.1-10) ...
Selecting previously unselected package libssl1.1:amd64.
Preparing to unpack .../055-libssl1.1_1.1.1d-2_amd64.deb ...
Unpacking libssl1.1:amd64 (1.1.1d-2) ...
Selecting previously unselected package openssl.
Preparing to unpack .../056-openssl_1.1.1d-2_amd64.deb ...
Unpacking openssl (1.1.1d-2) ...
Selecting previously unselected package ca-certificates.
Preparing to unpack .../057-ca-certificates_20190110_all.deb ...
Unpacking ca-certificates (20190110) ...
Selecting previously unselected package libcapture-tiny-perl.
Preparing to unpack .../058-libcapture-tiny-perl_0.48-1_all.deb ...
Unpacking libcapture-tiny-perl (0.48-1) ...
Selecting previously unselected package libparams-util-perl.
Preparing to unpack .../059-libparams-util-perl_1.07-3+b5_amd64.deb ...
Unpacking libparams-util-perl (1.07-3+b5) ...
Selecting previously unselected package libsub-install-perl.
Preparing to unpack .../060-libsub-install-perl_0.928-1_all.deb ...
Unpacking libsub-install-perl (0.928-1) ...
Selecting previously unselected package libdata-optlist-perl.
Preparing to unpack .../061-libdata-optlist-perl_0.110-1_all.deb ...
Unpacking libdata-optlist-perl (0.110-1) ...
Selecting previously unselected package libb-hooks-op-check-perl.
Preparing to unpack .../062-libb-hooks-op-check-perl_0.22-1+b2_amd64.deb ...
Unpacking libb-hooks-op-check-perl (0.22-1+b2) ...
Selecting previously unselected package libdynaloader-functions-perl.
Preparing to unpack .../063-libdynaloader-functions-perl_0.003-1_all.deb ...
Unpacking libdynaloader-functions-perl (0.003-1) ...
Selecting previously unselected package libdevel-callchecker-perl.
Preparing to unpack .../064-libdevel-callchecker-perl_0.008-1+b1_amd64.deb ...
Unpacking libdevel-callchecker-perl (0.008-1+b1) ...
Selecting previously unselected package libparams-classify-perl.
Preparing to unpack .../065-libparams-classify-perl_0.015-1+b2_amd64.deb ...
Unpacking libparams-classify-perl (0.015-1+b2) ...
Selecting previously unselected package libmodule-runtime-perl.
Preparing to unpack .../066-libmodule-runtime-perl_0.016-1_all.deb ...
Unpacking libmodule-runtime-perl (0.016-1) ...
Selecting previously unselected package libtry-tiny-perl.
Preparing to unpack .../067-libtry-tiny-perl_0.30-1_all.deb ...
Unpacking libtry-tiny-perl (0.30-1) ...
Selecting previously unselected package libmodule-implementation-perl.
Preparing to unpack .../068-libmodule-implementation-perl_0.09-1_all.deb ...
Unpacking libmodule-implementation-perl (0.09-1) ...
Selecting previously unselected package libpackage-stash-perl.
Preparing to unpack .../069-libpackage-stash-perl_0.38-1_all.deb ...
Unpacking libpackage-stash-perl (0.38-1) ...
Selecting previously unselected package libclass-load-perl.
Preparing to unpack .../070-libclass-load-perl_0.25-1_all.deb ...
Unpacking libclass-load-perl (0.25-1) ...
Selecting previously unselected package libio-stringy-perl.
Preparing to unpack .../071-libio-stringy-perl_2.111-3_all.deb ...
Unpacking libio-stringy-perl (2.111-3) ...
Selecting previously unselected package libparams-validate-perl.
Preparing to unpack .../072-libparams-validate-perl_1.29-3_amd64.deb ...
Unpacking libparams-validate-perl (1.29-3) ...
Selecting previously unselected package libsub-exporter-perl.
Preparing to unpack .../073-libsub-exporter-perl_0.987-1_all.deb ...
Unpacking libsub-exporter-perl (0.987-1) ...
Selecting previously unselected package libgetopt-long-descriptive-perl.
Preparing to unpack .../074-libgetopt-long-descriptive-perl_0.104-1_all.deb ...
Unpacking libgetopt-long-descriptive-perl (0.104-1) ...
Selecting previously unselected package libio-tiecombine-perl.
Preparing to unpack .../075-libio-tiecombine-perl_1.005-1_all.deb ...
Unpacking libio-tiecombine-perl (1.005-1) ...
Selecting previously unselected package libmodule-pluggable-perl.
Preparing to unpack .../076-libmodule-pluggable-perl_5.2-1_all.deb ...
Unpacking libmodule-pluggable-perl (5.2-1) ...
Selecting previously unselected package libstring-rewriteprefix-perl.
Preparing to unpack .../077-libstring-rewriteprefix-perl_0.008-1_all.deb ...
Unpacking libstring-rewriteprefix-perl (0.008-1) ...
Selecting previously unselected package libapp-cmd-perl.
Preparing to unpack .../078-libapp-cmd-perl_0.331-1_all.deb ...
Unpacking libapp-cmd-perl (0.331-1) ...
Selecting previously unselected package libboolean-perl.
Preparing to unpack .../079-libboolean-perl_0.46-1_all.deb ...
Unpacking libboolean-perl (0.46-1) ...
Selecting previously unselected package libcarp-assert-perl.
Preparing to unpack .../080-libcarp-assert-perl_0.21-1_all.deb ...
Unpacking libcarp-assert-perl (0.21-1) ...
Selecting previously unselected package libsub-uplevel-perl.
Preparing to unpack .../081-libsub-uplevel-perl_0.2800-1_all.deb ...
Unpacking libsub-uplevel-perl (0.2800-1) ...
Selecting previously unselected package libtest-exception-perl.
Preparing to unpack .../082-libtest-exception-perl_0.43-1_all.deb ...
Unpacking libtest-exception-perl (0.43-1) ...
Selecting previously unselected package libcarp-assert-more-perl.
Preparing to unpack .../083-libcarp-assert-more-perl_1.20-1_all.deb ...
Unpacking libcarp-assert-more-perl (1.20-1) ...
Selecting previously unselected package libfile-which-perl.
Preparing to unpack .../084-libfile-which-perl_1.23-1_all.deb ...
Unpacking libfile-which-perl (1.23-1) ...
Selecting previously unselected package libfile-homedir-perl.
Preparing to unpack .../085-libfile-homedir-perl_1.004-1_all.deb ...
Unpacking libfile-homedir-perl (1.004-1) ...
Selecting previously unselected package libclone-choose-perl.
Preparing to unpack .../086-libclone-choose-perl_0.010-1_all.deb ...
Unpacking libclone-choose-perl (0.010-1) ...
Selecting previously unselected package libhash-merge-perl.
Preparing to unpack .../087-libhash-merge-perl_0.300-1_all.deb ...
Unpacking libhash-merge-perl (0.300-1) ...
Selecting previously unselected package libjson-perl.
Preparing to unpack .../088-libjson-perl_4.02000-2_all.deb ...
Unpacking libjson-perl (4.02000-2) ...
Selecting previously unselected package libexporter-tiny-perl.
Preparing to unpack .../089-libexporter-tiny-perl_1.002001-1_all.deb ...
Unpacking libexporter-tiny-perl (1.002001-1) ...
Selecting previously unselected package liblist-moreutils-perl.
Preparing to unpack .../090-liblist-moreutils-perl_0.416-1+b5_amd64.deb ...
Unpacking liblist-moreutils-perl (0.416-1+b5) ...
Selecting previously unselected package liblog-log4perl-perl.
Preparing to unpack .../091-liblog-log4perl-perl_1.49-1_all.deb ...
Unpacking liblog-log4perl-perl (1.49-1) ...
Selecting previously unselected package libmouse-perl.
Preparing to unpack .../092-libmouse-perl_2.5.9-1_amd64.deb ...
Unpacking libmouse-perl (2.5.9-1) ...
Selecting previously unselected package libmousex-nativetraits-perl.
Preparing to unpack .../093-libmousex-nativetraits-perl_1.09-2_all.deb ...
Unpacking libmousex-nativetraits-perl (1.09-2) ...
Selecting previously unselected package libmousex-strictconstructor-perl.
Preparing to unpack .../094-libmousex-strictconstructor-perl_0.02-2_all.deb ...
Unpacking libmousex-strictconstructor-perl (0.02-2) ...
Selecting previously unselected package libparse-recdescent-perl.
Preparing to unpack .../095-libparse-recdescent-perl_1.967015+dfsg-2_all.deb ...
Unpacking libparse-recdescent-perl (1.967015+dfsg-2) ...
Selecting previously unselected package libpath-tiny-perl.
Preparing to unpack .../096-libpath-tiny-perl_0.108-1_all.deb ...
Unpacking libpath-tiny-perl (0.108-1) ...
Selecting previously unselected package libpod-pom-perl.
Preparing to unpack .../097-libpod-pom-perl_2.01-3_all.deb ...
Unpacking libpod-pom-perl (2.01-3) ...
Selecting previously unselected package libregexp-common-perl.
Preparing to unpack .../098-libregexp-common-perl_2017060201-1_all.deb ...
Unpacking libregexp-common-perl (2017060201-1) ...
Selecting previously unselected package libconfig-model-perl.
Preparing to unpack .../099-libconfig-model-perl_2.138-2_all.deb ...
Unpacking libconfig-model-perl (2.138-2) ...
Selecting previously unselected package libyaml-perl.
Preparing to unpack .../100-libyaml-perl_1.30-1_all.deb ...
Unpacking libyaml-perl (1.30-1) ...
Selecting previously unselected package cme.
Preparing to unpack .../101-cme_1.031-1_all.deb ...
Unpacking cme (1.031-1) ...
Selecting previously unselected package libtool.
Preparing to unpack .../102-libtool_2.4.6-13_all.deb ...
Unpacking libtool (2.4.6-13) ...
Selecting previously unselected package dh-autoreconf.
Preparing to unpack .../103-dh-autoreconf_19_all.deb ...
Unpacking dh-autoreconf (19) ...
Selecting previously unselected package libdebhelper-perl.
Preparing to unpack .../104-libdebhelper-perl_12.9_all.deb ...
Unpacking libdebhelper-perl (12.9) ...
Selecting previously unselected package libarchive-zip-perl.
Preparing to unpack .../105-libarchive-zip-perl_1.67-1_all.deb ...
Unpacking libarchive-zip-perl (1.67-1) ...
Selecting previously unselected package libsub-override-perl.
Preparing to unpack .../106-libsub-override-perl_0.09-2_all.deb ...
Unpacking libsub-override-perl (0.09-2) ...
Selecting previously unselected package libfile-stripnondeterminism-perl.
Preparing to unpack .../107-libfile-stripnondeterminism-perl_1.6.3-2_all.deb ...
Unpacking libfile-stripnondeterminism-perl (1.6.3-2) ...
Selecting previously unselected package dh-strip-nondeterminism.
Preparing to unpack .../108-dh-strip-nondeterminism_1.6.3-2_all.deb ...
Unpacking dh-strip-nondeterminism (1.6.3-2) ...
Selecting previously unselected package libelf1:amd64.
Preparing to unpack .../109-libelf1_0.176-1.1_amd64.deb ...
Unpacking libelf1:amd64 (0.176-1.1) ...
Selecting previously unselected package dwz.
Preparing to unpack .../110-dwz_0.13-5_amd64.deb ...
Unpacking dwz (0.13-5) ...
Selecting previously unselected package libcroco3:amd64.
Preparing to unpack .../111-libcroco3_0.6.13-1_amd64.deb ...
Unpacking libcroco3:amd64 (0.6.13-1) ...
Selecting previously unselected package gettext.
Preparing to unpack .../112-gettext_0.19.8.1-10_amd64.deb ...
Unpacking gettext (0.19.8.1-10) ...
Selecting previously unselected package intltool-debian.
Preparing to unpack .../113-intltool-debian_0.35.0+20060710.5_all.deb ...
Unpacking intltool-debian (0.35.0+20060710.5) ...
Selecting previously unselected package po-debconf.
Preparing to unpack .../114-po-debconf_1.0.21_all.deb ...
Unpacking po-debconf (1.0.21) ...
Selecting previously unselected package debhelper.
Preparing to unpack .../115-debhelper_12.9_all.deb ...
Unpacking debhelper (12.9) ...
Selecting previously unselected package libblas3:amd64.
Preparing to unpack .../116-libblas3_3.9.0-1_amd64.deb ...
Unpacking libblas3:amd64 (3.9.0-1) ...
Selecting previously unselected package libgfortran5:amd64.
Preparing to unpack .../117-libgfortran5_10-20200222-1_amd64.deb ...
Unpacking libgfortran5:amd64 (10-20200222-1) ...
Selecting previously unselected package liblapack3:amd64.
Preparing to unpack .../118-liblapack3_3.9.0-1_amd64.deb ...
Unpacking liblapack3:amd64 (3.9.0-1) ...
Selecting previously unselected package libarpack2:amd64.
Preparing to unpack .../119-libarpack2_3.7.0-3_amd64.deb ...
Unpacking libarpack2:amd64 (3.7.0-3) ...
Selecting previously unselected package libsuitesparseconfig5:amd64.
Preparing to unpack .../120-libsuitesparseconfig5_1%3a5.6.0+dfsg-2_amd64.deb ...
Unpacking libsuitesparseconfig5:amd64 (1:5.6.0+dfsg-2) ...
Selecting previously unselected package libamd2:amd64.
Preparing to unpack .../121-libamd2_1%3a5.6.0+dfsg-2_amd64.deb ...
Unpacking libamd2:amd64 (1:5.6.0+dfsg-2) ...
Selecting previously unselected package libcamd2:amd64.
Preparing to unpack .../122-libcamd2_1%3a5.6.0+dfsg-2_amd64.deb ...
Unpacking libcamd2:amd64 (1:5.6.0+dfsg-2) ...
Selecting previously unselected package libccolamd2:amd64.
Preparing to unpack .../123-libccolamd2_1%3a5.6.0+dfsg-2_amd64.deb ...
Unpacking libccolamd2:amd64 (1:5.6.0+dfsg-2) ...
Selecting previously unselected package libcolamd2:amd64.
Preparing to unpack .../124-libcolamd2_1%3a5.6.0+dfsg-2_amd64.deb ...
Unpacking libcolamd2:amd64 (1:5.6.0+dfsg-2) ...
Selecting previously unselected package libmetis5:amd64.
Preparing to unpack .../125-libmetis5_5.1.0.dfsg-5+b2_amd64.deb ...
Unpacking libmetis5:amd64 (5.1.0.dfsg-5+b2) ...
Selecting previously unselected package libcholmod3:amd64.
Preparing to unpack .../126-libcholmod3_1%3a5.6.0+dfsg-2_amd64.deb ...
Unpacking libcholmod3:amd64 (1:5.6.0+dfsg-2) ...
Selecting previously unselected package libbrotli1:amd64.
Preparing to unpack .../127-libbrotli1_1.0.7-6_amd64.deb ...
Unpacking libbrotli1:amd64 (1.0.7-6) ...
Selecting previously unselected package libkeyutils1:amd64.
Preparing to unpack .../128-libkeyutils1_1.6.1-2_amd64.deb ...
Unpacking libkeyutils1:amd64 (1.6.1-2) ...
Selecting previously unselected package libkrb5support0:amd64.
Preparing to unpack .../129-libkrb5support0_1.17-6_amd64.deb ...
Unpacking libkrb5support0:amd64 (1.17-6) ...
Selecting previously unselected package libk5crypto3:amd64.
Preparing to unpack .../130-libk5crypto3_1.17-6_amd64.deb ...
Unpacking libk5crypto3:amd64 (1.17-6) ...
Selecting previously unselected package libkrb5-3:amd64.
Preparing to unpack .../131-libkrb5-3_1.17-6_amd64.deb ...
Unpacking libkrb5-3:amd64 (1.17-6) ...
Selecting previously unselected package libgssapi-krb5-2:amd64.
Preparing to unpack .../132-libgssapi-krb5-2_1.17-6_amd64.deb ...
Unpacking libgssapi-krb5-2:amd64 (1.17-6) ...
Selecting previously unselected package libsasl2-modules-db:amd64.
Preparing to unpack .../133-libsasl2-modules-db_2.1.27+dfsg-2_amd64.deb ...
Unpacking libsasl2-modules-db:amd64 (2.1.27+dfsg-2) ...
Selecting previously unselected package libsasl2-2:amd64.
Preparing to unpack .../134-libsasl2-2_2.1.27+dfsg-2_amd64.deb ...
Unpacking libsasl2-2:amd64 (2.1.27+dfsg-2) ...
Selecting previously unselected package libldap-common.
Preparing to unpack .../135-libldap-common_2.4.49+dfsg-1_all.deb ...
Unpacking libldap-common (2.4.49+dfsg-1) ...
Selecting previously unselected package libldap-2.4-2:amd64.
Preparing to unpack .../136-libldap-2.4-2_2.4.49+dfsg-1_amd64.deb ...
Unpacking libldap-2.4-2:amd64 (2.4.49+dfsg-1) ...
Selecting previously unselected package libnghttp2-14:amd64.
Preparing to unpack .../137-libnghttp2-14_1.40.0-1_amd64.deb ...
Unpacking libnghttp2-14:amd64 (1.40.0-1) ...
Selecting previously unselected package libpsl5:amd64.
Preparing to unpack .../138-libpsl5_0.20.2-2_amd64.deb ...
Unpacking libpsl5:amd64 (0.20.2-2) ...
Selecting previously unselected package librtmp1:amd64.
Preparing to unpack .../139-librtmp1_2.4+20151223.gitfa8646d.1-2+b1_amd64.deb ...
Unpacking librtmp1:amd64 (2.4+20151223.gitfa8646d.1-2+b1) ...
Selecting previously unselected package libssh2-1:amd64.
Preparing to unpack .../140-libssh2-1_1.8.0-2.1_amd64.deb ...
Unpacking libssh2-1:amd64 (1.8.0-2.1) ...
Selecting previously unselected package libcurl3-gnutls:amd64.
Preparing to unpack .../141-libcurl3-gnutls_7.68.0-1_amd64.deb ...
Unpacking libcurl3-gnutls:amd64 (7.68.0-1) ...
Selecting previously unselected package libcxsparse3:amd64.
Preparing to unpack .../142-libcxsparse3_1%3a5.6.0+dfsg-2_amd64.deb ...
Unpacking libcxsparse3:amd64 (1:5.6.0+dfsg-2) ...
Selecting previously unselected package libfftw3-single3:amd64.
Preparing to unpack .../143-libfftw3-single3_3.3.8-2_amd64.deb ...
Unpacking libfftw3-single3:amd64 (3.3.8-2) ...
Selecting previously unselected package libglvnd0:amd64.
Preparing to unpack .../144-libglvnd0_1.3.1-1_amd64.deb ...
Unpacking libglvnd0:amd64 (1.3.1-1) ...
Selecting previously unselected package libdrm-common.
Preparing to unpack .../145-libdrm-common_2.4.100-4_all.deb ...
Unpacking libdrm-common (2.4.100-4) ...
Selecting previously unselected package libdrm2:amd64.
Preparing to unpack .../146-libdrm2_2.4.100-4_amd64.deb ...
Unpacking libdrm2:amd64 (2.4.100-4) ...
Selecting previously unselected package libglapi-mesa:amd64.
Preparing to unpack .../147-libglapi-mesa_19.3.3-1_amd64.deb ...
Unpacking libglapi-mesa:amd64 (19.3.3-1) ...
Selecting previously unselected package libx11-xcb1:amd64.
Preparing to unpack .../148-libx11-xcb1_2%3a1.6.8-1_amd64.deb ...
Unpacking libx11-xcb1:amd64 (2:1.6.8-1) ...
Selecting previously unselected package libxcb-dri2-0:amd64.
Preparing to unpack .../149-libxcb-dri2-0_1.13.1-5_amd64.deb ...
Unpacking libxcb-dri2-0:amd64 (1.13.1-5) ...
Selecting previously unselected package libxcb-dri3-0:amd64.
Preparing to unpack .../150-libxcb-dri3-0_1.13.1-5_amd64.deb ...
Unpacking libxcb-dri3-0:amd64 (1.13.1-5) ...
Selecting previously unselected package libxcb-glx0:amd64.
Preparing to unpack .../151-libxcb-glx0_1.13.1-5_amd64.deb ...
Unpacking libxcb-glx0:amd64 (1.13.1-5) ...
Selecting previously unselected package libxcb-present0:amd64.
Preparing to unpack .../152-libxcb-present0_1.13.1-5_amd64.deb ...
Unpacking libxcb-present0:amd64 (1.13.1-5) ...
Selecting previously unselected package libxcb-sync1:amd64.
Preparing to unpack .../153-libxcb-sync1_1.13.1-5_amd64.deb ...
Unpacking libxcb-sync1:amd64 (1.13.1-5) ...
Selecting previously unselected package libxfixes3:amd64.
Preparing to unpack .../154-libxfixes3_1%3a5.0.3-1_amd64.deb ...
Unpacking libxfixes3:amd64 (1:5.0.3-1) ...
Selecting previously unselected package libxdamage1:amd64.
Preparing to unpack .../155-libxdamage1_1%3a1.1.5-1_amd64.deb ...
Unpacking libxdamage1:amd64 (1:1.1.5-1) ...
Selecting previously unselected package libxshmfence1:amd64.
Preparing to unpack .../156-libxshmfence1_1.3-1_amd64.deb ...
Unpacking libxshmfence1:amd64 (1.3-1) ...
Selecting previously unselected package libxxf86vm1:amd64.
Preparing to unpack .../157-libxxf86vm1_1%3a1.1.4-1+b2_amd64.deb ...
Unpacking libxxf86vm1:amd64 (1:1.1.4-1+b2) ...
Selecting previously unselected package libdrm-amdgpu1:amd64.
Preparing to unpack .../158-libdrm-amdgpu1_2.4.100-4_amd64.deb ...
Unpacking libdrm-amdgpu1:amd64 (2.4.100-4) ...
Selecting previously unselected package libpciaccess0:amd64.
Preparing to unpack .../159-libpciaccess0_0.14-1_amd64.deb ...
Unpacking libpciaccess0:amd64 (0.14-1) ...
Selecting previously unselected package libdrm-intel1:amd64.
Preparing to unpack .../160-libdrm-intel1_2.4.100-4_amd64.deb ...
Unpacking libdrm-intel1:amd64 (2.4.100-4) ...
Selecting previously unselected package libdrm-nouveau2:amd64.
Preparing to unpack .../161-libdrm-nouveau2_2.4.100-4_amd64.deb ...
Unpacking libdrm-nouveau2:amd64 (2.4.100-4) ...
Selecting previously unselected package libdrm-radeon1:amd64.
Preparing to unpack .../162-libdrm-radeon1_2.4.100-4_amd64.deb ...
Unpacking libdrm-radeon1:amd64 (2.4.100-4) ...
Selecting previously unselected package libsensors-config.
Preparing to unpack .../163-libsensors-config_1%3a3.6.0-2_all.deb ...
Unpacking libsensors-config (1:3.6.0-2) ...
Selecting previously unselected package libsensors5:amd64.
Preparing to unpack .../164-libsensors5_1%3a3.6.0-2_amd64.deb ...
Unpacking libsensors5:amd64 (1:3.6.0-2) ...
Selecting previously unselected package libvulkan1:amd64.
Preparing to unpack .../165-libvulkan1_1.2.131.2-1_amd64.deb ...
Unpacking libvulkan1:amd64 (1.2.131.2-1) ...
Selecting previously unselected package libgl1-mesa-dri:amd64.
Preparing to unpack .../166-libgl1-mesa-dri_19.3.3-1_amd64.deb ...
Unpacking libgl1-mesa-dri:amd64 (19.3.3-1) ...
Selecting previously unselected package libglx-mesa0:amd64.
Preparing to unpack .../167-libglx-mesa0_19.3.3-1_amd64.deb ...
Unpacking libglx-mesa0:amd64 (19.3.3-1) ...
Selecting previously unselected package libglx0:amd64.
Preparing to unpack .../168-libglx0_1.3.1-1_amd64.deb ...
Unpacking libglx0:amd64 (1.3.1-1) ...
Selecting previously unselected package libgl1:amd64.
Preparing to unpack .../169-libgl1_1.3.1-1_amd64.deb ...
Unpacking libgl1:amd64 (1.3.1-1) ...
Selecting previously unselected package libgl2ps1.4.
Preparing to unpack .../170-libgl2ps1.4_1.4.0+dfsg1-2_amd64.deb ...
Unpacking libgl2ps1.4 (1.4.0+dfsg1-2) ...
Selecting previously unselected package libglu1-mesa:amd64.
Preparing to unpack .../171-libglu1-mesa_9.0.1-1_amd64.deb ...
Unpacking libglu1-mesa:amd64 (9.0.1-1) ...
Selecting previously unselected package libwmf0.2-7:amd64.
Preparing to unpack .../172-libwmf0.2-7_0.2.8.4-17_amd64.deb ...
Unpacking libwmf0.2-7:amd64 (0.2.8.4-17) ...
Selecting previously unselected package libgraphicsmagick-q16-3.
Preparing to unpack .../173-libgraphicsmagick-q16-3_1.4+really1.3.35-1_amd64.deb ...
Unpacking libgraphicsmagick-q16-3 (1.4+really1.3.35-1) ...
Selecting previously unselected package libgraphicsmagick++-q16-12.
Preparing to unpack .../174-libgraphicsmagick++-q16-12_1.4+really1.3.35-1_amd64.deb ...
Unpacking libgraphicsmagick++-q16-12 (1.4+really1.3.35-1) ...
Selecting previously unselected package libaec0:amd64.
Preparing to unpack .../175-libaec0_1.0.4-1_amd64.deb ...
Unpacking libaec0:amd64 (1.0.4-1) ...
Selecting previously unselected package libsz2:amd64.
Preparing to unpack .../176-libsz2_1.0.4-1_amd64.deb ...
Unpacking libsz2:amd64 (1.0.4-1) ...
Selecting previously unselected package libhdf5-103:amd64.
Preparing to unpack .../177-libhdf5-103_1.10.4+repack-11_amd64.deb ...
Unpacking libhdf5-103:amd64 (1.10.4+repack-11) ...
Selecting previously unselected package libqrupdate1:amd64.
Preparing to unpack .../178-libqrupdate1_1.1.2-3_amd64.deb ...
Unpacking libqrupdate1:amd64 (1.1.2-3) ...
Selecting previously unselected package libumfpack5:amd64.
Preparing to unpack .../179-libumfpack5_1%3a5.6.0+dfsg-2_amd64.deb ...
Unpacking libumfpack5:amd64 (1:5.6.0+dfsg-2) ...
Selecting previously unselected package liboctave7:amd64.
Preparing to unpack .../180-liboctave7_5.2.0-1_amd64.deb ...
Unpacking liboctave7:amd64 (5.2.0-1) ...
Selecting previously unselected package libxrender1:amd64.
Preparing to unpack .../181-libxrender1_1%3a0.9.10-1_amd64.deb ...
Unpacking libxrender1:amd64 (1:0.9.10-1) ...
Selecting previously unselected package libxcursor1:amd64.
Preparing to unpack .../182-libxcursor1_1%3a1.2.0-2_amd64.deb ...
Unpacking libxcursor1:amd64 (1:1.2.0-2) ...
Selecting previously unselected package libxft2:amd64.
Preparing to unpack .../183-libxft2_2.3.2-2_amd64.deb ...
Unpacking libxft2:amd64 (2.3.2-2) ...
Selecting previously unselected package libxinerama1:amd64.
Preparing to unpack .../184-libxinerama1_2%3a1.1.4-2_amd64.deb ...
Unpacking libxinerama1:amd64 (2:1.1.4-2) ...
Selecting previously unselected package libfltk1.3:amd64.
Preparing to unpack .../185-libfltk1.3_1.3.4-10_amd64.deb ...
Unpacking libfltk1.3:amd64 (1.3.4-10) ...
Selecting previously unselected package libfltk-gl1.3:amd64.
Preparing to unpack .../186-libfltk-gl1.3_1.3.4-10_amd64.deb ...
Unpacking libfltk-gl1.3:amd64 (1.3.4-10) ...
Selecting previously unselected package libglpk40:amd64.
Preparing to unpack .../187-libglpk40_4.65-2_amd64.deb ...
Unpacking libglpk40:amd64 (4.65-2) ...
Selecting previously unselected package libasound2-data.
Preparing to unpack .../188-libasound2-data_1.2.1.2-2_all.deb ...
Unpacking libasound2-data (1.2.1.2-2) ...
Selecting previously unselected package libasound2:amd64.
Preparing to unpack .../189-libasound2_1.2.1.2-2_amd64.deb ...
Unpacking libasound2:amd64 (1.2.1.2-2) ...
Selecting previously unselected package libopus0:amd64.
Preparing to unpack .../190-libopus0_1.3-1+b1_amd64.deb ...
Unpacking libopus0:amd64 (1.3-1+b1) ...
Selecting previously unselected package libsamplerate0:amd64.
Preparing to unpack .../191-libsamplerate0_0.1.9-2_amd64.deb ...
Unpacking libsamplerate0:amd64 (0.1.9-2) ...
Selecting previously unselected package libjack-jackd2-0:amd64.
Preparing to unpack .../192-libjack-jackd2-0_1.9.12~dfsg-2+b1_amd64.deb ...
Unpacking libjack-jackd2-0:amd64 (1.9.12~dfsg-2+b1) ...
Selecting previously unselected package libportaudio2:amd64.
Preparing to unpack .../193-libportaudio2_19.6.0-1_amd64.deb ...
Unpacking libportaudio2:amd64 (19.6.0-1) ...
Selecting previously unselected package libqhull7:amd64.
Preparing to unpack .../194-libqhull7_2015.2-4_amd64.deb ...
Unpacking libqhull7:amd64 (2015.2-4) ...
Selecting previously unselected package libqscintilla2-qt5-l10n.
Preparing to unpack .../195-libqscintilla2-qt5-l10n_2.11.2+dfsg-5_all.deb ...
Unpacking libqscintilla2-qt5-l10n (2.11.2+dfsg-5) ...
Selecting previously unselected package libdouble-conversion3:amd64.
Preparing to unpack .../196-libdouble-conversion3_3.1.5-5_amd64.deb ...
Unpacking libdouble-conversion3:amd64 (3.1.5-5) ...
Selecting previously unselected package libpcre2-16-0:amd64.
Preparing to unpack .../197-libpcre2-16-0_10.34-7_amd64.deb ...
Unpacking libpcre2-16-0:amd64 (10.34-7) ...
Selecting previously unselected package libqt5core5a:amd64.
Preparing to unpack .../198-libqt5core5a_5.12.5+dfsg-8_amd64.deb ...
Unpacking libqt5core5a:amd64 (5.12.5+dfsg-8) ...
Selecting previously unselected package fontconfig.
Preparing to unpack .../199-fontconfig_2.13.1-2+b1_amd64.deb ...
Unpacking fontconfig (2.13.1-2+b1) ...
Selecting previously unselected package libwayland-server0:amd64.
Preparing to unpack .../200-libwayland-server0_1.18.0-1_amd64.deb ...
Unpacking libwayland-server0:amd64 (1.18.0-1) ...
Selecting previously unselected package libgbm1:amd64.
Preparing to unpack .../201-libgbm1_19.3.3-1_amd64.deb ...
Unpacking libgbm1:amd64 (19.3.3-1) ...
Selecting previously unselected package libwayland-client0:amd64.
Preparing to unpack .../202-libwayland-client0_1.18.0-1_amd64.deb ...
Unpacking libwayland-client0:amd64 (1.18.0-1) ...
Selecting previously unselected package libxcb-xfixes0:amd64.
Preparing to unpack .../203-libxcb-xfixes0_1.13.1-5_amd64.deb ...
Unpacking libxcb-xfixes0:amd64 (1.13.1-5) ...
Selecting previously unselected package libegl-mesa0:amd64.
Preparing to unpack .../204-libegl-mesa0_19.3.3-1_amd64.deb ...
Unpacking libegl-mesa0:amd64 (19.3.3-1) ...
Selecting previously unselected package libegl1:amd64.
Preparing to unpack .../205-libegl1_1.3.1-1_amd64.deb ...
Unpacking libegl1:amd64 (1.3.1-1) ...
Selecting previously unselected package libgraphite2-3:amd64.
Preparing to unpack .../206-libgraphite2-3_1.3.13-11_amd64.deb ...
Unpacking libgraphite2-3:amd64 (1.3.13-11) ...
Selecting previously unselected package libharfbuzz0b:amd64.
Preparing to unpack .../207-libharfbuzz0b_2.6.4-1_amd64.deb ...
Unpacking libharfbuzz0b:amd64 (2.6.4-1) ...
Selecting previously unselected package x11-common.
Preparing to unpack .../208-x11-common_1%3a7.7+20_all.deb ...
Unpacking x11-common (1:7.7+20) ...
Selecting previously unselected package libice6:amd64.
Preparing to unpack .../209-libice6_2%3a1.0.9-2_amd64.deb ...
Unpacking libice6:amd64 (2:1.0.9-2) ...
Selecting previously unselected package libevdev2:amd64.
Preparing to unpack .../210-libevdev2_1.8.901+dfsg-1_amd64.deb ...
Unpacking libevdev2:amd64 (1.8.901+dfsg-1) ...
Selecting previously unselected package libmtdev1:amd64.
Preparing to unpack .../211-libmtdev1_1.1.5-1.1_amd64.deb ...
Unpacking libmtdev1:amd64 (1.1.5-1.1) ...
Selecting previously unselected package libgudev-1.0-0:amd64.
Preparing to unpack .../212-libgudev-1.0-0_233-1_amd64.deb ...
Unpacking libgudev-1.0-0:amd64 (233-1) ...
Selecting previously unselected package libwacom-common.
Preparing to unpack .../213-libwacom-common_1.1-2_all.deb ...
Unpacking libwacom-common (1.1-2) ...
Selecting previously unselected package libwacom2:amd64.
Preparing to unpack .../214-libwacom2_1.1-2_amd64.deb ...
Unpacking libwacom2:amd64 (1.1-2) ...
Selecting previously unselected package libinput-bin.
Preparing to unpack .../215-libinput-bin_1.15.2-1_amd64.deb ...
Unpacking libinput-bin (1.15.2-1) ...
Selecting previously unselected package libinput10:amd64.
Preparing to unpack .../216-libinput10_1.15.2-1_amd64.deb ...
Unpacking libinput10:amd64 (1.15.2-1) ...
Selecting previously unselected package libdbus-1-3:amd64.
Preparing to unpack .../217-libdbus-1-3_1.12.16-2_amd64.deb ...
Unpacking libdbus-1-3:amd64 (1.12.16-2) ...
Selecting previously unselected package libqt5dbus5:amd64.
Preparing to unpack .../218-libqt5dbus5_5.12.5+dfsg-8_amd64.deb ...
Unpacking libqt5dbus5:amd64 (5.12.5+dfsg-8) ...
Selecting previously unselected package libqt5network5:amd64.
Preparing to unpack .../219-libqt5network5_5.12.5+dfsg-8_amd64.deb ...
Unpacking libqt5network5:amd64 (5.12.5+dfsg-8) ...
Selecting previously unselected package libsm6:amd64.
Preparing to unpack .../220-libsm6_2%3a1.2.3-1_amd64.deb ...
Unpacking libsm6:amd64 (2:1.2.3-1) ...
Selecting previously unselected package libxcb-icccm4:amd64.
Preparing to unpack .../221-libxcb-icccm4_0.4.1-1.1_amd64.deb ...
Unpacking libxcb-icccm4:amd64 (0.4.1-1.1) ...
Selecting previously unselected package libxcb-shm0:amd64.
Preparing to unpack .../222-libxcb-shm0_1.13.1-5_amd64.deb ...
Unpacking libxcb-shm0:amd64 (1.13.1-5) ...
Selecting previously unselected package libxcb-util0:amd64.
Preparing to unpack .../223-libxcb-util0_0.3.8-3+b2_amd64.deb ...
Unpacking libxcb-util0:amd64 (0.3.8-3+b2) ...
Selecting previously unselected package libxcb-image0:amd64.
Preparing to unpack .../224-libxcb-image0_0.4.0-1+b2_amd64.deb ...
Unpacking libxcb-image0:amd64 (0.4.0-1+b2) ...
Selecting previously unselected package libxcb-keysyms1:amd64.
Preparing to unpack .../225-libxcb-keysyms1_0.4.0-1+b2_amd64.deb ...
Unpacking libxcb-keysyms1:amd64 (0.4.0-1+b2) ...
Selecting previously unselected package libxcb-randr0:amd64.
Preparing to unpack .../226-libxcb-randr0_1.13.1-5_amd64.deb ...
Unpacking libxcb-randr0:amd64 (1.13.1-5) ...
Selecting previously unselected package libxcb-render0:amd64.
Preparing to unpack .../227-libxcb-render0_1.13.1-5_amd64.deb ...
Unpacking libxcb-render0:amd64 (1.13.1-5) ...
Selecting previously unselected package libxcb-render-util0:amd64.
Preparing to unpack .../228-libxcb-render-util0_0.3.9-1+b1_amd64.deb ...
Unpacking libxcb-render-util0:amd64 (0.3.9-1+b1) ...
Selecting previously unselected package libxcb-shape0:amd64.
Preparing to unpack .../229-libxcb-shape0_1.13.1-5_amd64.deb ...
Unpacking libxcb-shape0:amd64 (1.13.1-5) ...
Selecting previously unselected package libxcb-xinerama0:amd64.
Preparing to unpack .../230-libxcb-xinerama0_1.13.1-5_amd64.deb ...
Unpacking libxcb-xinerama0:amd64 (1.13.1-5) ...
Selecting previously unselected package libxcb-xinput0:amd64.
Preparing to unpack .../231-libxcb-xinput0_1.13.1-5_amd64.deb ...
Unpacking libxcb-xinput0:amd64 (1.13.1-5) ...
Selecting previously unselected package libxcb-xkb1:amd64.
Preparing to unpack .../232-libxcb-xkb1_1.13.1-5_amd64.deb ...
Unpacking libxcb-xkb1:amd64 (1.13.1-5) ...
Selecting previously unselected package xkb-data.
Preparing to unpack .../233-xkb-data_2.26-2_all.deb ...
Unpacking xkb-data (2.26-2) ...
Selecting previously unselected package libxkbcommon0:amd64.
Preparing to unpack .../234-libxkbcommon0_0.10.0-1_amd64.deb ...
Unpacking libxkbcommon0:amd64 (0.10.0-1) ...
Selecting previously unselected package libxkbcommon-x11-0:amd64.
Preparing to unpack .../235-libxkbcommon-x11-0_0.10.0-1_amd64.deb ...
Unpacking libxkbcommon-x11-0:amd64 (0.10.0-1) ...
Selecting previously unselected package libqt5gui5:amd64.
Preparing to unpack .../236-libqt5gui5_5.12.5+dfsg-8_amd64.deb ...
Unpacking libqt5gui5:amd64 (5.12.5+dfsg-8) ...
Selecting previously unselected package libavahi-common-data:amd64.
Preparing to unpack .../237-libavahi-common-data_0.7-5_amd64.deb ...
Unpacking libavahi-common-data:amd64 (0.7-5) ...
Selecting previously unselected package libavahi-common3:amd64.
Preparing to unpack .../238-libavahi-common3_0.7-5_amd64.deb ...
Unpacking libavahi-common3:amd64 (0.7-5) ...
Selecting previously unselected package libavahi-client3:amd64.
Preparing to unpack .../239-libavahi-client3_0.7-5_amd64.deb ...
Unpacking libavahi-client3:amd64 (0.7-5) ...
Selecting previously unselected package libcups2:amd64.
Preparing to unpack .../240-libcups2_2.3.1-11_amd64.deb ...
Unpacking libcups2:amd64 (2.3.1-11) ...
Selecting previously unselected package libqt5widgets5:amd64.
Preparing to unpack .../241-libqt5widgets5_5.12.5+dfsg-8_amd64.deb ...
Unpacking libqt5widgets5:amd64 (5.12.5+dfsg-8) ...
Selecting previously unselected package libqt5printsupport5:amd64.
Preparing to unpack .../242-libqt5printsupport5_5.12.5+dfsg-8_amd64.deb ...
Unpacking libqt5printsupport5:amd64 (5.12.5+dfsg-8) ...
Selecting previously unselected package libqscintilla2-qt5-15.
Preparing to unpack .../243-libqscintilla2-qt5-15_2.11.2+dfsg-5_amd64.deb ...
Unpacking libqscintilla2-qt5-15 (2.11.2+dfsg-5) ...
Selecting previously unselected package libqt5sql5:amd64.
Preparing to unpack .../244-libqt5sql5_5.12.5+dfsg-8_amd64.deb ...
Unpacking libqt5sql5:amd64 (5.12.5+dfsg-8) ...
Selecting previously unselected package libqt5help5:amd64.
Preparing to unpack .../245-libqt5help5_5.12.5-2+b2_amd64.deb ...
Unpacking libqt5help5:amd64 (5.12.5-2+b2) ...
Selecting previously unselected package libqt5xml5:amd64.
Preparing to unpack .../246-libqt5xml5_5.12.5+dfsg-8_amd64.deb ...
Unpacking libqt5xml5:amd64 (5.12.5+dfsg-8) ...
Selecting previously unselected package libogg0:amd64.
Preparing to unpack .../247-libogg0_1.3.2-1+b1_amd64.deb ...
Unpacking libogg0:amd64 (1.3.2-1+b1) ...
Selecting previously unselected package libflac8:amd64.
Preparing to unpack .../248-libflac8_1.3.3-1_amd64.deb ...
Unpacking libflac8:amd64 (1.3.3-1) ...
Selecting previously unselected package libvorbis0a:amd64.
Preparing to unpack .../249-libvorbis0a_1.3.6-2_amd64.deb ...
Unpacking libvorbis0a:amd64 (1.3.6-2) ...
Selecting previously unselected package libvorbisenc2:amd64.
Preparing to unpack .../250-libvorbisenc2_1.3.6-2_amd64.deb ...
Unpacking libvorbisenc2:amd64 (1.3.6-2) ...
Selecting previously unselected package libsndfile1:amd64.
Preparing to unpack .../251-libsndfile1_1.0.28-7_amd64.deb ...
Unpacking libsndfile1:amd64 (1.0.28-7) ...
Selecting previously unselected package libtext-unidecode-perl.
Preparing to unpack .../252-libtext-unidecode-perl_1.30-1_all.deb ...
Unpacking libtext-unidecode-perl (1.30-1) ...
Selecting previously unselected package libxml-namespacesupport-perl.
Preparing to unpack .../253-libxml-namespacesupport-perl_1.12-1_all.deb ...
Unpacking libxml-namespacesupport-perl (1.12-1) ...
Selecting previously unselected package libxml-sax-base-perl.
Preparing to unpack .../254-libxml-sax-base-perl_1.09-1_all.deb ...
Unpacking libxml-sax-base-perl (1.09-1) ...
Selecting previously unselected package libxml-sax-perl.
Preparing to unpack .../255-libxml-sax-perl_1.02+dfsg-1_all.deb ...
Unpacking libxml-sax-perl (1.02+dfsg-1) ...
Selecting previously unselected package libxml-libxml-perl.
Preparing to unpack .../256-libxml-libxml-perl_2.0134+dfsg-1+b1_amd64.deb ...
Unpacking libxml-libxml-perl (2.0134+dfsg-1+b1) ...
Selecting previously unselected package texinfo.
Preparing to unpack .../257-texinfo_6.7.0.dfsg.2-5_amd64.deb ...
Unpacking texinfo (6.7.0.dfsg.2-5) ...
Selecting previously unselected package octave-common.
Preparing to unpack .../258-octave-common_5.2.0-1_all.deb ...
Unpacking octave-common (5.2.0-1) ...
Selecting previously unselected package octave.
Preparing to unpack .../259-octave_5.2.0-1_amd64.deb ...
Unpacking octave (5.2.0-1) ...
Selecting previously unselected package libncurses6:amd64.
Preparing to unpack .../260-libncurses6_6.1+20191019-1_amd64.deb ...
Unpacking libncurses6:amd64 (6.1+20191019-1) ...
Selecting previously unselected package libncurses-dev:amd64.
Preparing to unpack .../261-libncurses-dev_6.1+20191019-1_amd64.deb ...
Unpacking libncurses-dev:amd64 (6.1+20191019-1) ...
Selecting previously unselected package libreadline-dev:amd64.
Preparing to unpack .../262-libreadline-dev_8.0-3_amd64.deb ...
Unpacking libreadline-dev:amd64 (8.0-3) ...
Selecting previously unselected package zlib1g-dev:amd64.
Preparing to unpack .../263-zlib1g-dev_1%3a1.2.11.dfsg-2_amd64.deb ...
Unpacking zlib1g-dev:amd64 (1:1.2.11.dfsg-2) ...
Selecting previously unselected package libjpeg62-turbo-dev:amd64.
Preparing to unpack .../264-libjpeg62-turbo-dev_1%3a1.5.2-2+b1_amd64.deb ...
Unpacking libjpeg62-turbo-dev:amd64 (1:1.5.2-2+b1) ...
Selecting previously unselected package libjpeg-dev.
Preparing to unpack .../265-libjpeg-dev_1%3a1.5.2-2_all.deb ...
Unpacking libjpeg-dev (1:1.5.2-2) ...
Selecting previously unselected package libaec-dev:amd64.
Preparing to unpack .../266-libaec-dev_1.0.4-1_amd64.deb ...
Unpacking libaec-dev:amd64 (1.0.4-1) ...
Selecting previously unselected package hdf5-helpers.
Preparing to unpack .../267-hdf5-helpers_1.10.4+repack-11_amd64.deb ...
Unpacking hdf5-helpers (1.10.4+repack-11) ...
Selecting previously unselected package libhdf5-cpp-103:amd64.
Preparing to unpack .../268-libhdf5-cpp-103_1.10.4+repack-11_amd64.deb ...
Unpacking libhdf5-cpp-103:amd64 (1.10.4+repack-11) ...
Selecting previously unselected package libhdf5-dev.
Preparing to unpack .../269-libhdf5-dev_1.10.4+repack-11_amd64.deb ...
Unpacking libhdf5-dev (1.10.4+repack-11) ...
Selecting previously unselected package xorg-sgml-doctools.
Preparing to unpack .../270-xorg-sgml-doctools_1%3a1.11-1_all.deb ...
Unpacking xorg-sgml-doctools (1:1.11-1) ...
Selecting previously unselected package x11proto-dev.
Preparing to unpack .../271-x11proto-dev_2018.4-4_all.deb ...
Unpacking x11proto-dev (2018.4-4) ...
Selecting previously unselected package x11proto-core-dev.
Preparing to unpack .../272-x11proto-core-dev_2018.4-4_all.deb ...
Unpacking x11proto-core-dev (2018.4-4) ...
Selecting previously unselected package libxau-dev:amd64.
Preparing to unpack .../273-libxau-dev_1%3a1.0.8-1+b2_amd64.deb ...
Unpacking libxau-dev:amd64 (1:1.0.8-1+b2) ...
Selecting previously unselected package libxdmcp-dev:amd64.
Preparing to unpack .../274-libxdmcp-dev_1%3a1.1.2-3_amd64.deb ...
Unpacking libxdmcp-dev:amd64 (1:1.1.2-3) ...
Selecting previously unselected package xtrans-dev.
Preparing to unpack .../275-xtrans-dev_1.3.5-1_all.deb ...
Unpacking xtrans-dev (1.3.5-1) ...
Selecting previously unselected package libpthread-stubs0-dev:amd64.
Preparing to unpack .../276-libpthread-stubs0-dev_0.4-1_amd64.deb ...
Unpacking libpthread-stubs0-dev:amd64 (0.4-1) ...
Selecting previously unselected package libxcb1-dev:amd64.
Preparing to unpack .../277-libxcb1-dev_1.13.1-5_amd64.deb ...
Unpacking libxcb1-dev:amd64 (1.13.1-5) ...
Selecting previously unselected package libx11-dev:amd64.
Preparing to unpack .../278-libx11-dev_2%3a1.6.8-1_amd64.deb ...
Unpacking libx11-dev:amd64 (2:1.6.8-1) ...
Selecting previously unselected package libglx-dev:amd64.
Preparing to unpack .../279-libglx-dev_1.3.1-1_amd64.deb ...
Unpacking libglx-dev:amd64 (1.3.1-1) ...
Selecting previously unselected package libgl-dev:amd64.
Preparing to unpack .../280-libgl-dev_1.3.1-1_amd64.deb ...
Unpacking libgl-dev:amd64 (1.3.1-1) ...
Selecting previously unselected package libegl-dev:amd64.
Preparing to unpack .../281-libegl-dev_1.3.1-1_amd64.deb ...
Unpacking libegl-dev:amd64 (1.3.1-1) ...
Selecting previously unselected package libgles1:amd64.
Preparing to unpack .../282-libgles1_1.3.1-1_amd64.deb ...
Unpacking libgles1:amd64 (1.3.1-1) ...
Selecting previously unselected package libgles2:amd64.
Preparing to unpack .../283-libgles2_1.3.1-1_amd64.deb ...
Unpacking libgles2:amd64 (1.3.1-1) ...
Selecting previously unselected package libgles-dev:amd64.
Preparing to unpack .../284-libgles-dev_1.3.1-1_amd64.deb ...
Unpacking libgles-dev:amd64 (1.3.1-1) ...
Selecting previously unselected package libopengl0:amd64.
Preparing to unpack .../285-libopengl0_1.3.1-1_amd64.deb ...
Unpacking libopengl0:amd64 (1.3.1-1) ...
Selecting previously unselected package libopengl-dev:amd64.
Preparing to unpack .../286-libopengl-dev_1.3.1-1_amd64.deb ...
Unpacking libopengl-dev:amd64 (1.3.1-1) ...
Selecting previously unselected package libglvnd-dev:amd64.
Preparing to unpack .../287-libglvnd-dev_1.3.1-1_amd64.deb ...
Unpacking libglvnd-dev:amd64 (1.3.1-1) ...
Selecting previously unselected package libgl1-mesa-dev:amd64.
Preparing to unpack .../288-libgl1-mesa-dev_19.3.3-1_amd64.deb ...
Unpacking libgl1-mesa-dev:amd64 (19.3.3-1) ...
Selecting previously unselected package libblas-dev:amd64.
Preparing to unpack .../289-libblas-dev_3.9.0-1_amd64.deb ...
Unpacking libblas-dev:amd64 (3.9.0-1) ...
Selecting previously unselected package liblapack-dev:amd64.
Preparing to unpack .../290-liblapack-dev_3.9.0-1_amd64.deb ...
Unpacking liblapack-dev:amd64 (3.9.0-1) ...
Selecting previously unselected package libfftw3-long3:amd64.
Preparing to unpack .../291-libfftw3-long3_3.3.8-2_amd64.deb ...
Unpacking libfftw3-long3:amd64 (3.3.8-2) ...
Selecting previously unselected package libfftw3-quad3:amd64.
Preparing to unpack .../292-libfftw3-quad3_3.3.8-2_amd64.deb ...
Unpacking libfftw3-quad3:amd64 (3.3.8-2) ...
Selecting previously unselected package libfftw3-bin.
Preparing to unpack .../293-libfftw3-bin_3.3.8-2_amd64.deb ...
Unpacking libfftw3-bin (3.3.8-2) ...
Selecting previously unselected package libfftw3-dev:amd64.
Preparing to unpack .../294-libfftw3-dev_3.3.8-2_amd64.deb ...
Unpacking libfftw3-dev:amd64 (3.3.8-2) ...
Selecting previously unselected package libgfortran-9-dev:amd64.
Preparing to unpack .../295-libgfortran-9-dev_9.2.1-30_amd64.deb ...
Unpacking libgfortran-9-dev:amd64 (9.2.1-30) ...
Selecting previously unselected package gfortran-9.
Preparing to unpack .../296-gfortran-9_9.2.1-30_amd64.deb ...
Unpacking gfortran-9 (9.2.1-30) ...
Selecting previously unselected package gfortran.
Preparing to unpack .../297-gfortran_4%3a9.2.1-3.1_amd64.deb ...
Unpacking gfortran (4:9.2.1-3.1) ...
Selecting previously unselected package liboctave-dev.
Preparing to unpack .../298-liboctave-dev_5.2.0-1_amd64.deb ...
Unpacking liboctave-dev (5.2.0-1) ...
Selecting previously unselected package libapt-pkg-perl.
Preparing to unpack .../299-libapt-pkg-perl_0.1.36+b2_amd64.deb ...
Unpacking libapt-pkg-perl (0.1.36+b2) ...
Selecting previously unselected package libarray-intspan-perl.
Preparing to unpack .../300-libarray-intspan-perl_2.003-1_all.deb ...
Unpacking libarray-intspan-perl (2.003-1) ...
Selecting previously unselected package libyaml-0-2:amd64.
Preparing to unpack .../301-libyaml-0-2_0.2.2-1_amd64.deb ...
Unpacking libyaml-0-2:amd64 (0.2.2-1) ...
Selecting previously unselected package libyaml-libyaml-perl.
Preparing to unpack .../302-libyaml-libyaml-perl_0.81+repack-1_amd64.deb ...
Unpacking libyaml-libyaml-perl (0.81+repack-1) ...
Selecting previously unselected package libconfig-model-backend-yaml-perl.
Preparing to unpack .../303-libconfig-model-backend-yaml-perl_2.133-2_all.deb ...
Unpacking libconfig-model-backend-yaml-perl (2.133-2) ...
Selecting previously unselected package libexporter-lite-perl.
Preparing to unpack .../304-libexporter-lite-perl_0.08-1_all.deb ...
Unpacking libexporter-lite-perl (0.08-1) ...
Selecting previously unselected package libalgorithm-c3-perl.
Preparing to unpack .../305-libalgorithm-c3-perl_0.10-1_all.deb ...
Unpacking libalgorithm-c3-perl (0.10-1) ...
Selecting previously unselected package libclass-c3-perl.
Preparing to unpack .../306-libclass-c3-perl_0.34-1_all.deb ...
Unpacking libclass-c3-perl (0.34-1) ...
Selecting previously unselected package libmro-compat-perl.
Preparing to unpack .../307-libmro-compat-perl_0.13-1_all.deb ...
Unpacking libmro-compat-perl (0.13-1) ...
Selecting previously unselected package libdata-section-perl.
Preparing to unpack .../308-libdata-section-perl_0.200007-1_all.deb ...
Unpacking libdata-section-perl (0.200007-1) ...
Selecting previously unselected package libtext-template-perl.
Preparing to unpack .../309-libtext-template-perl_1.58-1_all.deb ...
Unpacking libtext-template-perl (1.58-1) ...
Selecting previously unselected package libsoftware-license-perl.
Preparing to unpack .../310-libsoftware-license-perl_0.103014-2_all.deb ...
Unpacking libsoftware-license-perl (0.103014-2) ...
Selecting previously unselected package libyaml-tiny-perl.
Preparing to unpack .../311-libyaml-tiny-perl_1.73-1_all.deb ...
Unpacking libyaml-tiny-perl (1.73-1) ...
Selecting previously unselected package libsoftware-licensemoreutils-perl.
Preparing to unpack .../312-libsoftware-licensemoreutils-perl_1.004-1_all.deb ...
Unpacking libsoftware-licensemoreutils-perl (1.004-1) ...
Selecting previously unselected package libsort-versions-perl.
Preparing to unpack .../313-libsort-versions-perl_1.62-1_all.deb ...
Unpacking libsort-versions-perl (1.62-1) ...
Selecting previously unselected package libtext-reform-perl.
Preparing to unpack .../314-libtext-reform-perl_1.20-3_all.deb ...
Unpacking libtext-reform-perl (1.20-3) ...
Selecting previously unselected package libtext-autoformat-perl.
Preparing to unpack .../315-libtext-autoformat-perl_1.750000-1_all.deb ...
Unpacking libtext-autoformat-perl (1.750000-1) ...
Selecting previously unselected package libtext-levenshtein-damerau-perl.
Preparing to unpack .../316-libtext-levenshtein-damerau-perl_0.41-1_all.deb ...
Unpacking libtext-levenshtein-damerau-perl (0.41-1) ...
Selecting previously unselected package liburi-perl.
Preparing to unpack .../317-liburi-perl_1.76-2_all.deb ...
Unpacking liburi-perl (1.76-2) ...
Selecting previously unselected package libencode-locale-perl.
Preparing to unpack .../318-libencode-locale-perl_1.05-1_all.deb ...
Unpacking libencode-locale-perl (1.05-1) ...
Selecting previously unselected package libtimedate-perl.
Preparing to unpack .../319-libtimedate-perl_2.3100-1_all.deb ...
Unpacking libtimedate-perl (2.3100-1) ...
Selecting previously unselected package libhttp-date-perl.
Preparing to unpack .../320-libhttp-date-perl_6.05-1_all.deb ...
Unpacking libhttp-date-perl (6.05-1) ...
Selecting previously unselected package libfile-listing-perl.
Preparing to unpack .../321-libfile-listing-perl_6.04-1_all.deb ...
Unpacking libfile-listing-perl (6.04-1) ...
Selecting previously unselected package libhtml-tagset-perl.
Preparing to unpack .../322-libhtml-tagset-perl_3.20-4_all.deb ...
Unpacking libhtml-tagset-perl (3.20-4) ...
Selecting previously unselected package libhtml-parser-perl.
Preparing to unpack .../323-libhtml-parser-perl_3.72-5_amd64.deb ...
Unpacking libhtml-parser-perl (3.72-5) ...
Selecting previously unselected package libhtml-tree-perl.
Preparing to unpack .../324-libhtml-tree-perl_5.07-2_all.deb ...
Unpacking libhtml-tree-perl (5.07-2) ...
Selecting previously unselected package libio-html-perl.
Preparing to unpack .../325-libio-html-perl_1.001-1_all.deb ...
Unpacking libio-html-perl (1.001-1) ...
Selecting previously unselected package liblwp-mediatypes-perl.
Preparing to unpack .../326-liblwp-mediatypes-perl_6.04-1_all.deb ...
Unpacking liblwp-mediatypes-perl (6.04-1) ...
Selecting previously unselected package libhttp-message-perl.
Preparing to unpack .../327-libhttp-message-perl_6.18-1_all.deb ...
Unpacking libhttp-message-perl (6.18-1) ...
Selecting previously unselected package libhttp-cookies-perl.
Preparing to unpack .../328-libhttp-cookies-perl_6.08-1_all.deb ...
Unpacking libhttp-cookies-perl (6.08-1) ...
Selecting previously unselected package libhttp-negotiate-perl.
Preparing to unpack .../329-libhttp-negotiate-perl_6.01-1_all.deb ...
Unpacking libhttp-negotiate-perl (6.01-1) ...
Selecting previously unselected package perl-openssl-defaults:amd64.
Preparing to unpack .../330-perl-openssl-defaults_4_amd64.deb ...
Unpacking perl-openssl-defaults:amd64 (4) ...
Selecting previously unselected package libnet-ssleay-perl.
Preparing to unpack .../331-libnet-ssleay-perl_1.88-2_amd64.deb ...
Unpacking libnet-ssleay-perl (1.88-2) ...
Selecting previously unselected package libio-socket-ssl-perl.
Preparing to unpack .../332-libio-socket-ssl-perl_2.067-1_all.deb ...
Unpacking libio-socket-ssl-perl (2.067-1) ...
Selecting previously unselected package libnet-http-perl.
Preparing to unpack .../333-libnet-http-perl_6.19-1_all.deb ...
Unpacking libnet-http-perl (6.19-1) ...
Selecting previously unselected package liblwp-protocol-https-perl.
Preparing to unpack .../334-liblwp-protocol-https-perl_6.07-2_all.deb ...
Unpacking liblwp-protocol-https-perl (6.07-2) ...
Selecting previously unselected package libwww-robotrules-perl.
Preparing to unpack .../335-libwww-robotrules-perl_6.02-1_all.deb ...
Unpacking libwww-robotrules-perl (6.02-1) ...
Selecting previously unselected package libwww-perl.
Preparing to unpack .../336-libwww-perl_6.43-1_all.deb ...
Unpacking libwww-perl (6.43-1) ...
Selecting previously unselected package liblist-someutils-perl.
Preparing to unpack .../337-liblist-someutils-perl_0.58-1_all.deb ...
Unpacking liblist-someutils-perl (0.58-1) ...
Selecting previously unselected package liblog-any-perl.
Preparing to unpack .../338-liblog-any-perl_1.708-1_all.deb ...
Unpacking liblog-any-perl (1.708-1) ...
Selecting previously unselected package liblog-any-adapter-screen-perl.
Preparing to unpack .../339-liblog-any-adapter-screen-perl_0.140-1_all.deb ...
Unpacking liblog-any-adapter-screen-perl (0.140-1) ...
Selecting previously unselected package libclass-method-modifiers-perl.
Preparing to unpack .../340-libclass-method-modifiers-perl_2.13-1_all.deb ...
Unpacking libclass-method-modifiers-perl (2.13-1) ...
Selecting previously unselected package libimport-into-perl.
Preparing to unpack .../341-libimport-into-perl_1.002005-1_all.deb ...
Unpacking libimport-into-perl (1.002005-1) ...
Selecting previously unselected package librole-tiny-perl.
Preparing to unpack .../342-librole-tiny-perl_2.001004-1_all.deb ...
Unpacking librole-tiny-perl (2.001004-1) ...
Selecting previously unselected package libstrictures-perl.
Preparing to unpack .../343-libstrictures-perl_2.000006-1_all.deb ...
Unpacking libstrictures-perl (2.000006-1) ...
Selecting previously unselected package libsub-quote-perl.
Preparing to unpack .../344-libsub-quote-perl_2.006006-1_all.deb ...
Unpacking libsub-quote-perl (2.006006-1) ...
Selecting previously unselected package libmoo-perl.
Preparing to unpack .../345-libmoo-perl_2.003006-1_all.deb ...
Unpacking libmoo-perl (2.003006-1) ...
Selecting previously unselected package libsub-exporter-progressive-perl.
Preparing to unpack .../346-libsub-exporter-progressive-perl_0.001013-1_all.deb ...
Unpacking libsub-exporter-progressive-perl (0.001013-1) ...
Selecting previously unselected package libvariable-magic-perl.
Preparing to unpack .../347-libvariable-magic-perl_0.62-1+b2_amd64.deb ...
Unpacking libvariable-magic-perl (0.62-1+b2) ...
Selecting previously unselected package libb-hooks-endofscope-perl.
Preparing to unpack .../348-libb-hooks-endofscope-perl_0.24-1_all.deb ...
Unpacking libb-hooks-endofscope-perl (0.24-1) ...
Selecting previously unselected package libsub-identify-perl.
Preparing to unpack .../349-libsub-identify-perl_0.14-1+b2_amd64.deb ...
Unpacking libsub-identify-perl (0.14-1+b2) ...
Selecting previously unselected package libsub-name-perl.
Preparing to unpack .../350-libsub-name-perl_0.26-1_amd64.deb ...
Unpacking libsub-name-perl (0.26-1) ...
Selecting previously unselected package libnamespace-clean-perl.
Preparing to unpack .../351-libnamespace-clean-perl_0.27-1_all.deb ...
Unpacking libnamespace-clean-perl (0.27-1) ...
Selecting previously unselected package libhash-fieldhash-perl.
Preparing to unpack .../352-libhash-fieldhash-perl_0.15-1+b2_amd64.deb ...
Unpacking libhash-fieldhash-perl (0.15-1+b2) ...
Selecting previously unselected package libobject-id-perl.
Preparing to unpack .../353-libobject-id-perl_0.1.2-2_all.deb ...
Unpacking libobject-id-perl (0.1.2-2) ...
Selecting previously unselected package libtype-tiny-perl.
Preparing to unpack .../354-libtype-tiny-perl_1.008001-2_all.deb ...
Unpacking libtype-tiny-perl (1.008001-2) ...
Selecting previously unselected package libmoox-struct-perl.
Preparing to unpack .../355-libmoox-struct-perl_0.017-1_all.deb ...
Unpacking libmoox-struct-perl (0.017-1) ...
Selecting previously unselected package libnumber-compare-perl.
Preparing to unpack .../356-libnumber-compare-perl_0.03-1_all.deb ...
Unpacking libnumber-compare-perl (0.03-1) ...
Selecting previously unselected package libtext-glob-perl.
Preparing to unpack .../357-libtext-glob-perl_0.10-1_all.deb ...
Unpacking libtext-glob-perl (0.10-1) ...
Selecting previously unselected package libpath-iterator-rule-perl.
Preparing to unpack .../358-libpath-iterator-rule-perl_1.014-1_all.deb ...
Unpacking libpath-iterator-rule-perl (1.014-1) ...
Selecting previously unselected package libpod-constants-perl.
Preparing to unpack .../359-libpod-constants-perl_0.19-1_all.deb ...
Unpacking libpod-constants-perl (0.19-1) ...
Selecting previously unselected package libre2-5:amd64.
Preparing to unpack .../360-libre2-5_20200101+dfsg-1_amd64.deb ...
Unpacking libre2-5:amd64 (20200101+dfsg-1) ...
Selecting previously unselected package libre-engine-re2-perl.
Preparing to unpack .../361-libre-engine-re2-perl_0.13-5_amd64.deb ...
Unpacking libre-engine-re2-perl (0.13-5) ...
Selecting previously unselected package libregexp-pattern-license-perl.
Preparing to unpack .../362-libregexp-pattern-license-perl_3.2.0-1_all.deb ...
Unpacking libregexp-pattern-license-perl (3.2.0-1) ...
Selecting previously unselected package libregexp-pattern-perl.
Preparing to unpack .../363-libregexp-pattern-perl_0.2.12-1_all.deb ...
Unpacking libregexp-pattern-perl (0.2.12-1) ...
Selecting previously unselected package libsort-key-perl.
Preparing to unpack .../364-libsort-key-perl_1.33-2+b2_amd64.deb ...
Unpacking libsort-key-perl (1.33-2+b2) ...
Selecting previously unselected package libnumber-range-perl.
Preparing to unpack .../365-libnumber-range-perl_0.12-1_all.deb ...
Unpacking libnumber-range-perl (0.12-1) ...
Selecting previously unselected package libstring-copyright-perl.
Preparing to unpack .../366-libstring-copyright-perl_0.003006-1_all.deb ...
Unpacking libstring-copyright-perl (0.003006-1) ...
Selecting previously unselected package libstring-escape-perl.
Preparing to unpack .../367-libstring-escape-perl_2010.002-2_all.deb ...
Unpacking libstring-escape-perl (2010.002-2) ...
Selecting previously unselected package licensecheck.
Preparing to unpack .../368-licensecheck_3.0.45-1_all.deb ...
Unpacking licensecheck (3.0.45-1) ...
Selecting previously unselected package diffstat.
Preparing to unpack .../369-diffstat_1.63-1_amd64.deb ...
Unpacking diffstat (1.63-1) ...
Selecting previously unselected package libassuan0:amd64.
Preparing to unpack .../370-libassuan0_2.5.3-7_amd64.deb ...
Unpacking libassuan0:amd64 (2.5.3-7) ...
Selecting previously unselected package gpgconf.
Preparing to unpack .../371-gpgconf_2.2.19-1_amd64.deb ...
Unpacking gpgconf (2.2.19-1) ...
Selecting previously unselected package libsqlite3-0:amd64.
Preparing to unpack .../372-libsqlite3-0_3.31.1-3_amd64.deb ...
Unpacking libsqlite3-0:amd64 (3.31.1-3) ...
Selecting previously unselected package gpg.
Preparing to unpack .../373-gpg_2.2.19-1_amd64.deb ...
Unpacking gpg (2.2.19-1) ...
Selecting previously unselected package libberkeleydb-perl:amd64.
Preparing to unpack .../374-libberkeleydb-perl_0.62-1+b1_amd64.deb ...
Unpacking libberkeleydb-perl:amd64 (0.62-1+b1) ...
Selecting previously unselected package libcgi-pm-perl.
Preparing to unpack .../375-libcgi-pm-perl_4.46-1_all.deb ...
Unpacking libcgi-pm-perl (4.46-1) ...
Selecting previously unselected package libclass-accessor-perl.
Preparing to unpack .../376-libclass-accessor-perl_0.51-1_all.deb ...
Unpacking libclass-accessor-perl (0.51-1) ...
Selecting previously unselected package libclass-xsaccessor-perl.
Preparing to unpack .../377-libclass-xsaccessor-perl_1.19-3+b3_amd64.deb ...
Unpacking libclass-xsaccessor-perl (1.19-3+b3) ...
Selecting previously unselected package libclone-perl.
Preparing to unpack .../378-libclone-perl_0.43-2_amd64.deb ...
Unpacking libclone-perl (0.43-2) ...
Selecting previously unselected package libdevel-size-perl.
Preparing to unpack .../379-libdevel-size-perl_0.83-1+b1_amd64.deb ...
Unpacking libdevel-size-perl (0.83-1+b1) ...
Selecting previously unselected package libnet-smtp-ssl-perl.
Preparing to unpack .../380-libnet-smtp-ssl-perl_1.04-1_all.deb ...
Unpacking libnet-smtp-ssl-perl (1.04-1) ...
Selecting previously unselected package libmailtools-perl.
Preparing to unpack .../381-libmailtools-perl_2.21-1_all.deb ...
Unpacking libmailtools-perl (2.21-1) ...
Selecting previously unselected package libdigest-hmac-perl.
Preparing to unpack .../382-libdigest-hmac-perl_1.03+dfsg-2_all.deb ...
Unpacking libdigest-hmac-perl (1.03+dfsg-2) ...
Selecting previously unselected package libnet-ip-perl.
Preparing to unpack .../383-libnet-ip-perl_1.26-2_all.deb ...
Unpacking libnet-ip-perl (1.26-2) ...
Selecting previously unselected package libnet-dns-perl.
Preparing to unpack .../384-libnet-dns-perl_1.22-1_all.deb ...
Unpacking libnet-dns-perl (1.22-1) ...
Selecting previously unselected package libnet-domain-tld-perl.
Preparing to unpack .../385-libnet-domain-tld-perl_1.75-1_all.deb ...
Unpacking libnet-domain-tld-perl (1.75-1) ...
Selecting previously unselected package libemail-valid-perl.
Preparing to unpack .../386-libemail-valid-perl_1.202-1_all.deb ...
Unpacking libemail-valid-perl (1.202-1) ...
Selecting previously unselected package libipc-system-simple-perl.
Preparing to unpack .../387-libipc-system-simple-perl_1.26-1_all.deb ...
Unpacking libipc-system-simple-perl (1.26-1) ...
Selecting previously unselected package libfile-basedir-perl.
Preparing to unpack .../388-libfile-basedir-perl_0.08-1_all.deb ...
Unpacking libfile-basedir-perl (0.08-1) ...
Selecting previously unselected package libfile-find-rule-perl.
Preparing to unpack .../389-libfile-find-rule-perl_0.34-1_all.deb ...
Unpacking libfile-find-rule-perl (0.34-1) ...
Selecting previously unselected package libio-string-perl.
Preparing to unpack .../390-libio-string-perl_1.08-3_all.deb ...
Unpacking libio-string-perl (1.08-3) ...
Selecting previously unselected package libfont-ttf-perl.
Preparing to unpack .../391-libfont-ttf-perl_1.06-1_all.deb ...
Unpacking libfont-ttf-perl (1.06-1) ...
Selecting previously unselected package libfuture-perl.
Preparing to unpack .../392-libfuture-perl_0.43-1_all.deb ...
Unpacking libfuture-perl (0.43-1) ...
Selecting previously unselected package libstruct-dumb-perl.
Preparing to unpack .../393-libstruct-dumb-perl_0.09-1_all.deb ...
Unpacking libstruct-dumb-perl (0.09-1) ...
Selecting previously unselected package libio-async-perl.
Preparing to unpack .../394-libio-async-perl_0.75-1_all.deb ...
Unpacking libio-async-perl (0.75-1) ...
Selecting previously unselected package liblinux-epoll-perl.
Preparing to unpack .../395-liblinux-epoll-perl_0.017-1_amd64.deb ...
Unpacking liblinux-epoll-perl (0.017-1) ...
Selecting previously unselected package libio-async-loop-epoll-perl.
Preparing to unpack .../396-libio-async-loop-epoll-perl_0.20-1_all.deb ...
Unpacking libio-async-loop-epoll-perl (0.20-1) ...
Selecting previously unselected package libio-pty-perl.
Preparing to unpack .../397-libio-pty-perl_1%3a1.12-1_amd64.deb ...
Unpacking libio-pty-perl (1:1.12-1) ...
Selecting previously unselected package libipc-run-perl.
Preparing to unpack .../398-libipc-run-perl_20180523.0-2_all.deb ...
Unpacking libipc-run-perl (20180523.0-2) ...
Selecting previously unselected package liblist-compare-perl.
Preparing to unpack .../399-liblist-compare-perl_0.53-1_all.deb ...
Unpacking liblist-compare-perl (0.53-1) ...
Selecting previously unselected package libmldbm-perl.
Preparing to unpack .../400-libmldbm-perl_2.05-2_all.deb ...
Unpacking libmldbm-perl (2.05-2) ...
Selecting previously unselected package libmoox-aliases-perl.
Preparing to unpack .../401-libmoox-aliases-perl_0.001006-1_all.deb ...
Unpacking libmoox-aliases-perl (0.001006-1) ...
Selecting previously unselected package libtext-levenshtein-perl.
Preparing to unpack .../402-libtext-levenshtein-perl_0.13-1_all.deb ...
Unpacking libtext-levenshtein-perl (0.13-1) ...
Selecting previously unselected package patchutils.
Preparing to unpack .../403-patchutils_0.3.4-2+b1_amd64.deb ...
Unpacking patchutils (0.3.4-2+b1) ...
Selecting previously unselected package t1utils.
Preparing to unpack .../404-t1utils_1.41-3_amd64.deb ...
Unpacking t1utils (1.41-3) ...
Selecting previously unselected package lintian.
Preparing to unpack .../405-lintian_2.55.0_all.deb ...
Unpacking lintian (2.55.0) ...
Selecting previously unselected package libconfig-model-dpkg-perl.
Preparing to unpack .../406-libconfig-model-dpkg-perl_2.129_all.deb ...
Unpacking libconfig-model-dpkg-perl (2.129) ...
Selecting previously unselected package liberror-perl.
Preparing to unpack .../407-liberror-perl_0.17029-1_all.deb ...
Unpacking liberror-perl (0.17029-1) ...
Selecting previously unselected package libparse-debcontrol-perl.
Preparing to unpack .../408-libparse-debcontrol-perl_2.005-4_all.deb ...
Unpacking libparse-debcontrol-perl (2.005-4) ...
Selecting previously unselected package libconvert-binhex-perl.
Preparing to unpack .../409-libconvert-binhex-perl_1.125-1_all.deb ...
Unpacking libconvert-binhex-perl (1.125-1) ...
Selecting previously unselected package libmime-tools-perl.
Preparing to unpack .../410-libmime-tools-perl_5.509-1_all.deb ...
Unpacking libmime-tools-perl (5.509-1) ...
Selecting previously unselected package gnuplot-data.
Preparing to unpack .../411-gnuplot-data_5.2.8+dfsg1-1_all.deb ...
Unpacking gnuplot-data (5.2.8+dfsg1-1) ...
Selecting previously unselected package libpixman-1-0:amd64.
Preparing to unpack .../412-libpixman-1-0_0.36.0-1_amd64.deb ...
Unpacking libpixman-1-0:amd64 (0.36.0-1) ...
Selecting previously unselected package libcairo2:amd64.
Preparing to unpack .../413-libcairo2_1.16.0-4_amd64.deb ...
Unpacking libcairo2:amd64 (1.16.0-4) ...
Selecting previously unselected package libxpm4:amd64.
Preparing to unpack .../414-libxpm4_1%3a3.5.12-1_amd64.deb ...
Unpacking libxpm4:amd64 (1:3.5.12-1) ...
Selecting previously unselected package libgd3:amd64.
Preparing to unpack .../415-libgd3_2.2.5-5.2_amd64.deb ...
Unpacking libgd3:amd64 (2.2.5-5.2) ...
Selecting previously unselected package liblua5.3-0:amd64.
Preparing to unpack .../416-liblua5.3-0_5.3.3-1.1+b1_amd64.deb ...
Unpacking liblua5.3-0:amd64 (5.3.3-1.1+b1) ...
Selecting previously unselected package libfribidi0:amd64.
Preparing to unpack .../417-libfribidi0_1.0.8-2_amd64.deb ...
Unpacking libfribidi0:amd64 (1.0.8-2) ...
Selecting previously unselected package libthai-data.
Preparing to unpack .../418-libthai-data_0.1.28-3_all.deb ...
Unpacking libthai-data (0.1.28-3) ...
Selecting previously unselected package libdatrie1:amd64.
Preparing to unpack .../419-libdatrie1_0.2.12-3_amd64.deb ...
Unpacking libdatrie1:amd64 (0.2.12-3) ...
Selecting previously unselected package libthai0:amd64.
Preparing to unpack .../420-libthai0_0.1.28-3_amd64.deb ...
Unpacking libthai0:amd64 (0.1.28-3) ...
Selecting previously unselected package libpango-1.0-0:amd64.
Preparing to unpack .../421-libpango-1.0-0_1.42.4-8_amd64.deb ...
Unpacking libpango-1.0-0:amd64 (1.42.4-8) ...
Selecting previously unselected package libpangoft2-1.0-0:amd64.
Preparing to unpack .../422-libpangoft2-1.0-0_1.42.4-8_amd64.deb ...
Unpacking libpangoft2-1.0-0:amd64 (1.42.4-8) ...
Selecting previously unselected package libpangocairo-1.0-0:amd64.
Preparing to unpack .../423-libpangocairo-1.0-0_1.42.4-8_amd64.deb ...
Unpacking libpangocairo-1.0-0:amd64 (1.42.4-8) ...
Selecting previously unselected package gnuplot-nox.
Preparing to unpack .../424-gnuplot-nox_5.2.8+dfsg1-1_amd64.deb ...
Unpacking gnuplot-nox (5.2.8+dfsg1-1) ...
Selecting previously unselected package fonts-freefont-otf.
Preparing to unpack .../425-fonts-freefont-otf_20120503-9_all.deb ...
Unpacking fonts-freefont-otf (20120503-9) ...
Selecting previously unselected package dh-octave-autopkgtest.
Preparing to unpack .../426-dh-octave-autopkgtest_0.7.3_all.deb ...
Unpacking dh-octave-autopkgtest (0.7.3) ...
Selecting previously unselected package dh-octave.
Preparing to unpack .../427-dh-octave_0.7.3_all.deb ...
Unpacking dh-octave (0.7.3) ...
Selecting previously unselected package fonts-urw-base35.
Preparing to unpack .../428-fonts-urw-base35_20170801.1-3_all.deb ...
Unpacking fonts-urw-base35 (20170801.1-3) ...
Selecting previously unselected package libgs9-common.
Preparing to unpack .../429-libgs9-common_9.50~dfsg-5_all.deb ...
Unpacking libgs9-common (9.50~dfsg-5) ...
Selecting previously unselected package libidn11:amd64.
Preparing to unpack .../430-libidn11_1.33-2.2_amd64.deb ...
Unpacking libidn11:amd64 (1.33-2.2) ...
Selecting previously unselected package libijs-0.35:amd64.
Preparing to unpack .../431-libijs-0.35_0.35-15_amd64.deb ...
Unpacking libijs-0.35:amd64 (0.35-15) ...
Selecting previously unselected package libjbig2dec0:amd64.
Preparing to unpack .../432-libjbig2dec0_0.17-1_amd64.deb ...
Unpacking libjbig2dec0:amd64 (0.17-1) ...
Selecting previously unselected package libpaper1:amd64.
Preparing to unpack .../433-libpaper1_1.1.28+b1_amd64.deb ...
Unpacking libpaper1:amd64 (1.1.28+b1) ...
Selecting previously unselected package libgs9:amd64.
Preparing to unpack .../434-libgs9_9.50~dfsg-5_amd64.deb ...
Unpacking libgs9:amd64 (9.50~dfsg-5) ...
Selecting previously unselected package ghostscript.
Preparing to unpack .../435-ghostscript_9.50~dfsg-5_amd64.deb ...
Unpacking ghostscript (9.50~dfsg-5) ...
Selecting previously unselected package hicolor-icon-theme.
Preparing to unpack .../436-hicolor-icon-theme_0.17-2_all.deb ...
Unpacking hicolor-icon-theme (0.17-2) ...
Selecting previously unselected package imagemagick-6.q16.
Preparing to unpack .../437-imagemagick-6.q16_8%3a6.9.10.23+dfsg-2.1+b2_amd64.deb ...
Unpacking imagemagick-6.q16 (8:6.9.10.23+dfsg-2.1+b2) ...
Selecting previously unselected package imagemagick.
Preparing to unpack .../438-imagemagick_8%3a6.9.10.23+dfsg-2.1+b2_amd64.deb ...
Unpacking imagemagick (8:6.9.10.23+dfsg-2.1+b2) ...
Selecting previously unselected package libgmpxx4ldbl:amd64.
Preparing to unpack .../439-libgmpxx4ldbl_2%3a6.2.0+dfsg-4_amd64.deb ...
Unpacking libgmpxx4ldbl:amd64 (2:6.2.0+dfsg-4) ...
Selecting previously unselected package libgmp-dev:amd64.
Preparing to unpack .../440-libgmp-dev_2%3a6.2.0+dfsg-4_amd64.deb ...
Unpacking libgmp-dev:amd64 (2:6.2.0+dfsg-4) ...
Selecting previously unselected package libmpfr-dev:amd64.
Preparing to unpack .../441-libmpfr-dev_4.0.2-1_amd64.deb ...
Unpacking libmpfr-dev:amd64 (4.0.2-1) ...
Selecting previously unselected package sbuild-build-depends-main-dummy.
Preparing to unpack .../442-sbuild-build-depends-main-dummy_0.invalid.0_amd64.deb ...
Unpacking sbuild-build-depends-main-dummy (0.invalid.0) ...
Setting up libapt-pkg-perl (0.1.36+b2) ...
Setting up libexpat1:amd64 (2.2.9-1) ...
Setting up libmodule-pluggable-perl (5.2-1) ...
Setting up libpipeline1:amd64 (1.5.2-2) ...
Setting up libgraphite2-3:amd64 (1.3.13-11) ...
Setting up libstring-escape-perl (2010.002-2) ...
Setting up liblcms2-2:amd64 (2.9-4) ...
Setting up libberkeleydb-perl:amd64 (0.62-1+b1) ...
Setting up libpixman-1-0:amd64 (0.36.0-1) ...
Setting up libwayland-server0:amd64 (1.18.0-1) ...
Setting up libx11-xcb1:amd64 (2:1.6.8-1) ...
Setting up libpciaccess0:amd64 (0.14-1) ...
Setting up libfile-which-perl (1.23-1) ...
Setting up libxau6:amd64 (1:1.0.8-1+b2) ...
Setting up imagemagick-6-common (8:6.9.10.23+dfsg-2.1) ...
Setting up libxdmcp6:amd64 (1:1.1.2-3) ...
Setting up libdouble-conversion3:amd64 (3.1.5-5) ...
Setting up libkeyutils1:amd64 (1.6.1-2) ...
Setting up libpsl5:amd64 (0.20.2-2) ...
Setting up libxcb1:amd64 (1.13.1-5) ...
Setting up libnumber-range-perl (0.12-1) ...
Setting up libfftw3-single3:amd64 (3.3.8-2) ...
Setting up libstruct-dumb-perl (0.09-1) ...
Setting up libxcb-xfixes0:amd64 (1.13.1-5) ...
Setting up libogg0:amd64 (1.3.2-1+b1) ...
Setting up libmouse-perl (2.5.9-1) ...
Setting up libpod-pom-perl (2.01-3) ...
Setting up hdf5-helpers (1.10.4+repack-11) ...
Setting up hicolor-icon-theme (0.17-2) ...
Setting up libregexp-pattern-perl (0.2.12-1) ...
Setting up libxcb-xinput0:amd64 (1.13.1-5) ...
Setting up libdynaloader-functions-perl (0.003-1) ...
Setting up libdatrie1:amd64 (0.2.12-3) ...
Setting up libtext-glob-perl (0.10-1) ...
Setting up libclass-method-modifiers-perl (2.13-1) ...
Setting up liblist-compare-perl (0.53-1) ...
Setting up libio-pty-perl (1:1.12-1) ...
Setting up libmagic-mgc (1:5.38-4) ...
Setting up libxcb-render0:amd64 (1.13.1-5) ...
Setting up libsort-key-perl (1.33-2+b2) ...
Setting up libclone-perl (0.43-2) ...
Setting up libarchive-zip-perl (1.67-1) ...
Setting up libyaml-0-2:amd64 (0.2.2-1) ...
Setting up libsub-identify-perl (0.14-1+b2) ...
Setting up libglib2.0-0:amd64 (2.62.4-2) ...
No schema files found: doing nothing.
Setting up libglvnd0:amd64 (1.3.1-1) ...
Setting up libio-stringy-perl (2.111-3) ...
Setting up libssl1.1:amd64 (1.1.1d-2) ...
Setting up libhtml-tagset-perl (3.20-4) ...
Setting up liblog-any-perl (1.708-1) ...
Setting up libqscintilla2-qt5-l10n (2.11.2+dfsg-5) ...
Setting up libijs-0.35:amd64 (0.35-15) ...
Setting up libxcb-glx0:amd64 (1.13.1-5) ...
Setting up libdevel-size-perl (0.83-1+b1) ...
Setting up libdebhelper-perl (12.9) ...
Setting up libbrotli1:amd64 (1.0.7-6) ...
Setting up libpod-constants-perl (0.19-1) ...
Setting up libsqlite3-0:amd64 (3.31.1-3) ...
Setting up libconvert-binhex-perl (1.125-1) ...
Setting up libfuture-perl (0.43-1) ...
Setting up liblwp-mediatypes-perl (6.04-1) ...
Setting up libyaml-libyaml-perl (0.81+repack-1) ...
Setting up fonts-freefont-otf (20120503-9) ...
Setting up libxcb-keysyms1:amd64 (0.4.0-1+b2) ...
Setting up libxcb-shape0:amd64 (1.13.1-5) ...
Setting up x11-common (1:7.7+20) ...
update-rc.d: warning: start and stop actions are no longer supported; falling back to defaults
invoke-rc.d: could not determine current runlevel
All runlevel operations denied by policy
invoke-rc.d: policy-rc.d denied execution of start.
Setting up libtry-tiny-perl (0.30-1) ...
Setting up libsensors-config (1:3.6.0-2) ...
Setting up libnghttp2-14:amd64 (1.40.0-1) ...
Setting up libmagic1:amd64 (1:5.38-4) ...
Setting up perl-openssl-defaults:amd64 (4) ...
Setting up libmldbm-perl (2.05-2) ...
Setting up libxml-namespacesupport-perl (1.12-1) ...
Setting up libfftw3-long3:amd64 (3.3.8-2) ...
Setting up gettext-base (0.19.8.1-10) ...
Setting up libclone-choose-perl (0.010-1) ...
Setting up libxcb-render-util0:amd64 (0.3.9-1+b1) ...
Setting up xkb-data (2.26-2) ...
Setting up libencode-locale-perl (1.05-1) ...
Setting up libqhull7:amd64 (2015.2-4) ...
Setting up libtext-levenshtein-perl (0.13-1) ...
Setting up libmetis5:amd64 (5.1.0.dfsg-5+b2) ...
Setting up libxcb-shm0:amd64 (1.13.1-5) ...
Setting up libxcb-icccm4:amd64 (0.4.1-1.1) ...
Setting up file (1:5.38-4) ...
Setting up fonts-urw-base35 (20170801.1-3) ...
Setting up libxcb-util0:amd64 (0.3.8-3+b2) ...
Setting up libassuan0:amd64 (2.5.3-7) ...
Setting up libldap-common (2.4.49+dfsg-1) ...
Setting up libyaml-perl (1.30-1) ...
Setting up libyaml-tiny-perl (1.73-1) ...
Setting up libpthread-stubs0-dev:amd64 (0.4-1) ...
Setting up libjbig0:amd64 (2.1-3.1+b2) ...
Setting up octave-common (5.2.0-1) ...
Setting up libregexp-common-perl (2017060201-1) ...
Setting up libpcre2-16-0:amd64 (10.34-7) ...
Setting up libaec0:amd64 (1.0.4-1) ...
Setting up libicu63:amd64 (63.2-2) ...
Setting up libopengl0:amd64 (1.3.1-1) ...
Setting up libsub-install-perl (0.928-1) ...
Setting up libflac8:amd64 (1.3.3-1) ...
Setting up poppler-data (0.4.9-2) ...
Setting up libxcb-xkb1:amd64 (1.13.1-5) ...
Setting up libxcb-image0:amd64 (0.4.0-1+b2) ...
Setting up libkrb5support0:amd64 (1.17-6) ...
Setting up libnumber-compare-perl (0.03-1) ...
Setting up libsasl2-modules-db:amd64 (2.1.27+dfsg-2) ...
Setting up libio-async-perl (0.75-1) ...
Setting up libxcb-present0:amd64 (1.13.1-5) ...
Setting up liberror-perl (0.17029-1) ...
Setting up libasound2-data (1.2.1.2-2) ...
Setting up patchutils (0.3.4-2+b1) ...
Setting up libxml-sax-base-perl (1.09-1) ...
Setting up libio-string-perl (1.08-3) ...
Setting up libboolean-perl (0.46-1) ...
Setting up xtrans-dev (1.3.5-1) ...
Setting up autotools-dev (20180224.1) ...
Setting up libblas3:amd64 (3.9.0-1) ...
update-alternatives: using /usr/lib/x86_64-linux-gnu/blas/libblas.so.3 to provide /usr/lib/x86_64-linux-gnu/libblas.so.3 (libblas.so.3-x86_64-linux-gnu) in auto mode
Setting up libxcb-xinerama0:amd64 (1.13.1-5) ...
Setting up libgmpxx4ldbl:amd64 (2:6.2.0+dfsg-4) ...
Setting up libalgorithm-c3-perl (0.10-1) ...
Setting up libgles2:amd64 (1.3.1-1) ...
Setting up liblog-log4perl-perl (1.49-1) ...
Setting up libtext-reform-perl (1.20-3) ...
Setting up libjpeg62-turbo:amd64 (1:1.5.2-2+b1) ...
Setting up libx11-data (2:1.6.8-1) ...
Setting up libjpeg62-turbo-dev:amd64 (1:1.5.2-2+b1) ...
Setting up libfile-find-rule-perl (0.34-1) ...
Setting up libdigest-hmac-perl (1.03+dfsg-2) ...
Setting up libxcb-sync1:amd64 (1.13.1-5) ...
Setting up libjbig2dec0:amd64 (0.17-1) ...
Setting up librtmp1:amd64 (2.4+20151223.gitfa8646d.1-2+b1) ...
Setting up libipc-system-simple-perl (1.26-1) ...
Setting up libidn11:amd64 (1.33-2.2) ...
Setting up libio-tiecombine-perl (1.005-1) ...
Setting up libnet-domain-tld-perl (1.75-1) ...
Setting up aglfn (1.7+git20191031.4036a9c-2) ...
Setting up libavahi-common-data:amd64 (0.7-5) ...
Setting up libncurses6:amd64 (6.1+20191019-1) ...
Setting up libgles1:amd64 (1.3.1-1) ...
Setting up libhash-fieldhash-perl (0.15-1+b2) ...
Setting up libdbus-1-3:amd64 (1.12.16-2) ...
Setting up libsigsegv2:amd64 (2.12-2) ...
Setting up libfftw3-quad3:amd64 (3.3.8-2) ...
Setting up libfribidi0:amd64 (1.0.8-2) ...
Setting up libopus0:amd64 (1.3-1+b1) ...
Setting up t1utils (1.41-3) ...
Setting up liblinux-epoll-perl (0.017-1) ...
Setting up diffstat (1.63-1) ...
Setting up bsdmainutils (11.1.2+b1) ...
update-alternatives: using /usr/bin/bsd-write to provide /usr/bin/write (write) in auto mode
update-alternatives: using /usr/bin/bsd-from to provide /usr/bin/from (from) in auto mode
Setting up libpng16-16:amd64 (1.6.37-2) ...
Setting up libvorbis0a:amd64 (1.3.6-2) ...
Setting up libvariable-magic-perl (0.62-1+b2) ...
Setting up libio-html-perl (1.001-1) ...
Setting up libtext-template-perl (1.58-1) ...
Setting up autopoint (0.19.8.1-10) ...
Setting up libwebp6:amd64 (0.6.1-2+b1) ...
Setting up libb-hooks-op-check-perl (0.22-1+b2) ...
Setting up fonts-dejavu-core (2.37-1) ...
Setting up libipc-run-perl (20180523.0-2) ...
Setting up libsensors5:amd64 (1:3.6.0-2) ...
Setting up libk5crypto3:amd64 (1.17-6) ...
Setting up libqt5core5a:amd64 (5.12.5+dfsg-8) ...
Setting up libltdl7:amd64 (2.4.6-13) ...
Setting up libfftw3-double3:amd64 (3.3.8-2) ...
Setting up libglapi-mesa:amd64 (19.3.3-1) ...
Setting up libparams-util-perl (1.07-3+b5) ...
Setting up libsasl2-2:amd64 (2.1.27+dfsg-2) ...
Setting up libgfortran5:amd64 (10-20200222-1) ...
Setting up libmtdev1:amd64 (1.1.5-1.1) ...
Setting up libvulkan1:amd64 (1.2.131.2-1) ...
Setting up libsub-exporter-progressive-perl (0.001013-1) ...
Setting up libarray-intspan-perl (2.003-1) ...
Setting up libcapture-tiny-perl (0.48-1) ...
Setting up libtimedate-perl (2.3100-1) ...
Setting up libexporter-lite-perl (0.08-1) ...
Setting up libxcb-dri2-0:amd64 (1.13.1-5) ...
Setting up libsub-name-perl (0.26-1) ...
Setting up zlib1g-dev:amd64 (1:1.2.11.dfsg-2) ...
Setting up libnuma1:amd64 (2.0.12-1+b1) ...
Setting up libparse-recdescent-perl (1.967015+dfsg-2) ...
Setting up liblqr-1-0:amd64 (0.4.2-2.1) ...
Setting up sensible-utils (0.0.12+nmu1) ...
Setting up libxshmfence1:amd64 (1.3-1) ...
Setting up libqt5dbus5:amd64 (5.12.5+dfsg-8) ...
Setting up libxcb-randr0:amd64 (1.13.1-5) ...
Setting up libpath-tiny-perl (0.108-1) ...
Setting up libuchardet0:amd64 (0.0.6-3) ...
Setting up liblua5.3-0:amd64 (5.3.3-1.1+b1) ...
Setting up libjson-perl (4.02000-2) ...
Setting up libasound2:amd64 (1.2.1.2-2) ...
Setting up liblog-any-adapter-screen-perl (0.140-1) ...
Setting up librole-tiny-perl (2.001004-1) ...
Setting up libmousex-strictconstructor-perl (0.02-2) ...
Setting up libre2-5:amd64 (20200101+dfsg-1) ...
Setting up libsub-uplevel-perl (0.2800-1) ...
Setting up libopenjp2-7:amd64 (2.3.1-1) ...
Setting up libsub-override-perl (0.09-2) ...
Setting up libx11-6:amd64 (2:1.6.8-1) ...
Setting up libthai-data (0.1.28-3) ...
Setting up libssh2-1:amd64 (1.8.0-2.1) ...
Setting up xorg-sgml-doctools (1:1.11-1) ...
Setting up netbase (6.1) ...
Setting up libstrictures-perl (2.000006-1) ...
Setting up libsub-quote-perl (2.006006-1) ...
Setting up libclass-xsaccessor-perl (1.19-3+b3) ...
Setting up libcxsparse3:amd64 (1:5.6.0+dfsg-2) ...
Setting up libtext-autoformat-perl (1.750000-1) ...
Setting up libkrb5-3:amd64 (1.17-6) ...
Setting up libtiff5:amd64 (4.1.0+git191117-2) ...
Setting up libsort-versions-perl (1.62-1) ...
Setting up libopengl-dev:amd64 (1.3.1-1) ...
Setting up libexporter-tiny-perl (1.002001-1) ...
Setting up libre-engine-re2-perl (0.13-5) ...
Setting up libclass-accessor-perl (0.51-1) ...
Setting up libtext-unidecode-perl (1.30-1) ...
Setting up libde265-0:amd64 (1.0.4-1) ...
Setting up libfont-ttf-perl (1.06-1) ...
Setting up libfile-homedir-perl (1.004-1) ...
Setting up libnet-ip-perl (1.26-2) ...
Setting up libsamplerate0:amd64 (0.1.9-2) ...
Setting up openssl (1.1.1d-2) ...
Setting up libwebpmux3:amd64 (0.6.1-2+b1) ...
Setting up libdrm-common (2.4.100-4) ...
Setting up libelf1:amd64 (0.176-1.1) ...
Setting up libevdev2:amd64 (1.8.901+dfsg-1) ...
Setting up readline-common (8.0-3) ...
Setting up libxml2:amd64 (2.9.10+dfsg-3) ...
Setting up libtext-levenshtein-damerau-perl (0.41-1) ...
Setting up libsuitesparseconfig5:amd64 (1:5.6.0+dfsg-2) ...
Setting up liburi-perl (1.76-2) ...
Setting up libcarp-assert-perl (0.21-1) ...
Setting up libgudev-1.0-0:amd64 (233-1) ...
Setting up libblas-dev:amd64 (3.9.0-1) ...
update-alternatives: using /usr/lib/x86_64-linux-gnu/blas/libblas.so to provide /usr/lib/x86_64-linux-gnu/libblas.so (libblas.so-x86_64-linux-gnu) in auto mode
Setting up libsz2:amd64 (1.0.4-1) ...
Setting up libvorbisenc2:amd64 (1.3.6-2) ...
Setting up libwacom-common (1.1-2) ...
Setting up libmousex-nativetraits-perl (1.09-2) ...
Setting up libxkbcommon0:amd64 (0.10.0-1) ...
Setting up libwayland-client0:amd64 (1.18.0-1) ...
Setting up libnet-ssleay-perl (1.88-2) ...
Setting up libgs9-common (9.50~dfsg-5) ...
Setting up x11proto-dev (2018.4-4) ...
Setting up libfile-stripnondeterminism-perl (1.6.3-2) ...
Setting up libxcb-dri3-0:amd64 (1.13.1-5) ...
Setting up gnuplot-data (5.2.8+dfsg1-1) ...
Setting up libamd2:amd64 (1:5.6.0+dfsg-2) ...
Setting up libice6:amd64 (2:1.0.9-2) ...
Setting up libhttp-date-perl (6.05-1) ...
Setting up liblapack3:amd64 (3.9.0-1) ...
update-alternatives: using /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3 to provide /usr/lib/x86_64-linux-gnu/liblapack.so.3 (liblapack.so.3-x86_64-linux-gnu) in auto mode
Setting up libncurses-dev:amd64 (6.1+20191019-1) ...
Setting up libfile-basedir-perl (0.08-1) ...
Setting up libgmp-dev:amd64 (2:6.2.0+dfsg-4) ...
Setting up libfile-listing-perl (6.04-1) ...
Setting up libxau-dev:amd64 (1:1.0.8-1+b2) ...
Setting up libcolamd2:amd64 (1:5.6.0+dfsg-2) ...
Setting up libxpm4:amd64 (1:3.5.12-1) ...
Setting up libxrender1:amd64 (1:0.9.10-1) ...
Setting up libtool (2.4.6-13) ...
Setting up libx265-179:amd64 (3.2.1-1) ...
Setting up libfftw3-bin (3.3.8-2) ...
Setting up libobject-id-perl (0.1.2-2) ...
Setting up liblist-moreutils-perl (0.416-1+b5) ...
Setting up libregexp-pattern-license-perl (3.2.0-1) ...
Setting up libreadline8:amd64 (8.0-3) ...
Setting up libheif1:amd64 (1.6.1-1) ...
Setting up libhash-merge-perl (0.300-1) ...
Setting up libaec-dev:amd64 (1.0.4-1) ...
Setting up libarpack2:amd64 (3.7.0-3) ...
Setting up libavahi-common3:amd64 (0.7-5) ...
Setting up libtype-tiny-perl (1.008001-2) ...
Setting up libjpeg-dev (1:1.5.2-2) ...
Setting up libxext6:amd64 (2:1.3.3-1+b2) ...
Setting up libgfortran-9-dev:amd64 (9.2.1-30) ...
Setting up libldap-2.4-2:amd64 (2.4.49+dfsg-1) ...
Setting up libnet-http-perl (6.19-1) ...
Setting up libpath-iterator-rule-perl (1.014-1) ...
Setting up m4 (1.4.18-4) ...
Setting up libnet-dns-perl (1.22-1) ...
Setting up libclass-c3-perl (0.34-1) ...
Setting up libreadline-dev:amd64 (8.0-3) ...
Setting up libqrupdate1:amd64 (1.1.2-3) ...
Setting up libdevel-callchecker-perl (0.008-1+b1) ...
Setting up libmpfr-dev:amd64 (4.0.2-1) ...
Setting up libqt5network5:amd64 (5.12.5+dfsg-8) ...
Setting up libio-async-loop-epoll-perl (0.20-1) ...
Setting up libxxf86vm1:amd64 (1:1.1.4-1+b2) ...
Setting up libqt5sql5:amd64 (5.12.5+dfsg-8) ...
Setting up libthai0:amd64 (0.1.28-3) ...
Setting up ca-certificates (20190110) ...
Updating certificates in /etc/ssl/certs...
128 added, 0 removed; done.
Setting up libcamd2:amd64 (1:5.6.0+dfsg-2) ...
Setting up libxdmcp-dev:amd64 (1:1.1.2-3) ...
Setting up libqt5xml5:amd64 (5.12.5+dfsg-8) ...
Setting up libtest-exception-perl (0.43-1) ...
Setting up libfreetype6:amd64 (2.10.1-2) ...
Setting up libglpk40:amd64 (4.65-2) ...
Setting up libxfixes3:amd64 (1:5.0.3-1) ...
Setting up libstring-copyright-perl (0.003006-1) ...
Setting up x11proto-core-dev (2018.4-4) ...
Setting up libhdf5-103:amd64 (1.10.4+repack-11) ...
Setting up libxinerama1:amd64 (2:1.1.4-2) ...
Setting up libxkbcommon-x11-0:amd64 (0.10.0-1) ...
Setting up liblapack-dev:amd64 (3.9.0-1) ...
update-alternatives: using /usr/lib/x86_64-linux-gnu/lapack/liblapack.so to provide /usr/lib/x86_64-linux-gnu/liblapack.so (liblapack.so-x86_64-linux-gnu) in auto mode
Setting up libgssapi-krb5-2:amd64 (1.17-6) ...
Setting up libdata-optlist-perl (0.110-1) ...
Setting up libcroco3:amd64 (0.6.13-1) ...
Setting up ucf (3.0038+nmu1) ...
Setting up autoconf (2.69-11.1) ...
Setting up dh-strip-nondeterminism (1.6.3-2) ...
Setting up libwww-robotrules-perl (6.02-1) ...
Setting up libjack-jackd2-0:amd64 (1.9.12~dfsg-2+b1) ...
Setting up libdrm2:amd64 (2.4.100-4) ...
Setting up dwz (0.13-5) ...
Setting up groff-base (1.22.4-4) ...
Setting up libccolamd2:amd64 (1:5.6.0+dfsg-2) ...
Setting up libhtml-parser-perl (3.72-5) ...
Setting up gpgconf (2.2.19-1) ...
Setting up libharfbuzz0b:amd64 (2.6.4-1) ...
Setting up libsndfile1:amd64 (1.0.28-7) ...
Setting up libmro-compat-perl (0.13-1) ...
Setting up libwacom2:amd64 (1.1-2) ...
Setting up libsm6:amd64 (2:1.2.3-1) ...
Setting up libfftw3-dev:amd64 (3.3.8-2) ...
Setting up libavahi-client3:amd64 (0.7-5) ...
Setting up libcholmod3:amd64 (1:5.6.0+dfsg-2) ...
Setting up libio-socket-ssl-perl (2.067-1) ...
Setting up gpg (2.2.19-1) ...
Setting up libsub-exporter-perl (0.987-1) ...
Setting up libhttp-message-perl (6.18-1) ...
Setting up libdrm-amdgpu1:amd64 (2.4.100-4) ...
Setting up automake (1:1.16.1-4) ...
update-alternatives: using /usr/bin/automake-1.16 to provide /usr/bin/automake (automake) in auto mode
Setting up libpaper1:amd64 (1.1.28+b1) ...

Creating config file /etc/papersize with new version
Setting up libportaudio2:amd64 (19.6.0-1) ...
Setting up libhttp-negotiate-perl (6.01-1) ...
Setting up libcarp-assert-more-perl (1.20-1) ...
Setting up libdrm-nouveau2:amd64 (2.4.100-4) ...
Setting up gettext (0.19.8.1-10) ...
Setting up libxdamage1:amd64 (1:1.1.5-1) ...
Setting up libxcb1-dev:amd64 (1.13.1-5) ...
Setting up gfortran-9 (9.2.1-30) ...
Setting up libgbm1:amd64 (19.3.3-1) ...
Setting up libhttp-cookies-perl (6.08-1) ...
Setting up libwmf0.2-7:amd64 (0.2.8.4-17) ...
Setting up libdrm-radeon1:amd64 (2.4.100-4) ...
Setting up fontconfig-config (2.13.1-2) ...
Setting up libhtml-tree-perl (5.07-2) ...
Setting up libxcursor1:amd64 (1:1.2.0-2) ...
Setting up libparams-classify-perl (0.015-1+b2) ...
Setting up libdrm-intel1:amd64 (2.4.100-4) ...
Setting up libcgi-pm-perl (4.46-1) ...
Setting up libgl1-mesa-dri:amd64 (19.3.3-1) ...
Setting up libhdf5-cpp-103:amd64 (1.10.4+repack-11) ...
Setting up libx11-dev:amd64 (2:1.6.8-1) ...
Setting up libcurl3-gnutls:amd64 (7.68.0-1) ...
Setting up man-db (2.9.0-2) ...
Not building database; man-db/auto-update is not 'true'.
Setting up libxml-sax-perl (1.02+dfsg-1) ...
update-perl-sax-parsers: Registering Perl SAX parser XML::SAX::PurePerl with priority 10...
update-perl-sax-parsers: Updating overall Perl SAX parser modules info file...

Creating config file /etc/perl/XML/SAX/ParserDetails.ini with new version
Setting up gfortran (4:9.2.1-3.1) ...
update-alternatives: using /usr/bin/gfortran to provide /usr/bin/f95 (f95) in auto mode
update-alternatives: using /usr/bin/gfortran to provide /usr/bin/f77 (f77) in auto mode
Setting up libinput-bin (1.15.2-1) ...
Setting up intltool-debian (0.35.0+20060710.5) ...
Setting up tex-common (6.13) ...
update-language: texlive-base not installed and configured, doing nothing!
Setting up libegl-mesa0:amd64 (19.3.3-1) ...
Setting up libumfpack5:amd64 (1:5.6.0+dfsg-2) ...
Setting up libnet-smtp-ssl-perl (1.04-1) ...
Setting up libmodule-runtime-perl (0.016-1) ...
Setting up libmailtools-perl (2.21-1) ...
Setting up libconfig-model-perl (2.138-2) ...
Setting up libhdf5-dev (1.10.4+repack-11) ...
update-alternatives: using /usr/lib/x86_64-linux-gnu/pkgconfig/hdf5-serial.pc to provide /usr/lib/x86_64-linux-gnu/pkgconfig/hdf5.pc (hdf5.pc) in auto mode
Setting up libgraphicsmagick-q16-3 (1.4+really1.3.35-1) ...
Setting up libxml-libxml-perl (2.0134+dfsg-1+b1) ...
update-perl-sax-parsers: Registering Perl SAX parser XML::LibXML::SAX::Parser with priority 50...
update-perl-sax-parsers: Registering Perl SAX parser XML::LibXML::SAX with priority 50...
update-perl-sax-parsers: Updating overall Perl SAX parser modules info file...
Replacing config file /etc/perl/XML/SAX/ParserDetails.ini with new version
Setting up libcups2:amd64 (2.3.1-11) ...
Setting up libdata-section-perl (0.200007-1) ...
Setting up libegl1:amd64 (1.3.1-1) ...
Setting up libgraphicsmagick++-q16-12 (1.4+really1.3.35-1) ...
Setting up libfontconfig1:amd64 (2.13.1-2+b1) ...
Setting up libstring-rewriteprefix-perl (0.008-1) ...
Setting up libconfig-model-backend-yaml-perl (2.133-2) ...
Setting up libinput10:amd64 (1.15.2-1) ...
Setting up fontconfig (2.13.1-2+b1) ...
Regenerating fonts cache... done.
Setting up libxft2:amd64 (2.3.2-2) ...
Setting up libglx-mesa0:amd64 (19.3.3-1) ...
Setting up libgs9:amd64 (9.50~dfsg-5) ...
Setting up libglx0:amd64 (1.3.1-1) ...
Setting up libmodule-implementation-perl (0.09-1) ...
Setting up libemail-valid-perl (1.202-1) ...
Setting up libpackage-stash-perl (0.38-1) ...
Setting up libimport-into-perl (1.002005-1) ...
Setting up libmoo-perl (2.003006-1) ...
Setting up po-debconf (1.0.21) ...
Setting up libfltk1.3:amd64 (1.3.4-10) ...
Setting up libpango-1.0-0:amd64 (1.42.4-8) ...
Setting up liblist-someutils-perl (0.58-1) ...
Setting up ghostscript (9.50~dfsg-5) ...
Setting up libmime-tools-perl (5.509-1) ...
Setting up libcairo2:amd64 (1.16.0-4) ...
Setting up libsoftware-license-perl (0.103014-2) ...
Setting up libclass-load-perl (0.25-1) ...
Setting up libmagickcore-6.q16-6:amd64 (8:6.9.10.23+dfsg-2.1+b2) ...
Setting up libgl1:amd64 (1.3.1-1) ...
Setting up libgd3:amd64 (2.2.5-5.2) ...
Setting up texinfo (6.7.0.dfsg.2-5) ...
Setting up libmagickwand-6.q16-6:amd64 (8:6.9.10.23+dfsg-2.1+b2) ...
Setting up libglx-dev:amd64 (1.3.1-1) ...
Setting up libglu1-mesa:amd64 (9.0.1-1) ...
Setting up libpangoft2-1.0-0:amd64 (1.42.4-8) ...
Setting up libmoox-aliases-perl (0.001006-1) ...
Setting up libparams-validate-perl (1.29-3) ...
Setting up libb-hooks-endofscope-perl (0.24-1) ...
Setting up libgl-dev:amd64 (1.3.1-1) ...
Setting up libpangocairo-1.0-0:amd64 (1.42.4-8) ...
Setting up libegl-dev:amd64 (1.3.1-1) ...
Setting up libsoftware-licensemoreutils-perl (1.004-1) ...
Setting up libfltk-gl1.3:amd64 (1.3.4-10) ...
Setting up libqt5gui5:amd64 (5.12.5+dfsg-8) ...
Setting up libqt5widgets5:amd64 (5.12.5+dfsg-8) ...
Setting up libqt5help5:amd64 (5.12.5-2+b2) ...
Setting up libgl2ps1.4 (1.4.0+dfsg1-2) ...
Setting up libqt5printsupport5:amd64 (5.12.5+dfsg-8) ...
Setting up liboctave7:amd64 (5.2.0-1) ...
Setting up libnamespace-clean-perl (0.27-1) ...
Setting up imagemagick-6.q16 (8:6.9.10.23+dfsg-2.1+b2) ...
update-alternatives: using /usr/bin/compare-im6.q16 to provide /usr/bin/compare (compare) in auto mode
update-alternatives: using /usr/bin/compare-im6.q16 to provide /usr/bin/compare-im6 (compare-im6) in auto mode
update-alternatives: using /usr/bin/animate-im6.q16 to provide /usr/bin/animate (animate) in auto mode
update-alternatives: using /usr/bin/animate-im6.q16 to provide /usr/bin/animate-im6 (animate-im6) in auto mode
update-alternatives: using /usr/bin/convert-im6.q16 to provide /usr/bin/convert (convert) in auto mode
update-alternatives: using /usr/bin/convert-im6.q16 to provide /usr/bin/convert-im6 (convert-im6) in auto mode
update-alternatives: using /usr/bin/composite-im6.q16 to provide /usr/bin/composite (composite) in auto mode
update-alternatives: using /usr/bin/composite-im6.q16 to provide /usr/bin/composite-im6 (composite-im6) in auto mode
update-alternatives: using /usr/bin/conjure-im6.q16 to provide /usr/bin/conjure (conjure) in auto mode
update-alternatives: using /usr/bin/conjure-im6.q16 to provide /usr/bin/conjure-im6 (conjure-im6) in auto mode
update-alternatives: using /usr/bin/import-im6.q16 to provide /usr/bin/import (import) in auto mode
update-alternatives: using /usr/bin/import-im6.q16 to provide /usr/bin/import-im6 (import-im6) in auto mode
update-alternatives: using /usr/bin/identify-im6.q16 to provide /usr/bin/identify (identify) in auto mode
update-alternatives: using /usr/bin/identify-im6.q16 to provide /usr/bin/identify-im6 (identify-im6) in auto mode
update-alternatives: using /usr/bin/stream-im6.q16 to provide /usr/bin/stream (stream) in auto mode
update-alternatives: using /usr/bin/stream-im6.q16 to provide /usr/bin/stream-im6 (stream-im6) in auto mode
update-alternatives: using /usr/bin/display-im6.q16 to provide /usr/bin/display (display) in auto mode
update-alternatives: using /usr/bin/display-im6.q16 to provide /usr/bin/display-im6 (display-im6) in auto mode
update-alternatives: using /usr/bin/montage-im6.q16 to provide /usr/bin/montage (montage) in auto mode
update-alternatives: using /usr/bin/montage-im6.q16 to provide /usr/bin/montage-im6 (montage-im6) in auto mode
update-alternatives: using /usr/bin/mogrify-im6.q16 to provide /usr/bin/mogrify (mogrify) in auto mode
update-alternatives: using /usr/bin/mogrify-im6.q16 to provide /usr/bin/mogrify-im6 (mogrify-im6) in auto mode
Setting up libgetopt-long-descriptive-perl (0.104-1) ...
Setting up gnuplot-nox (5.2.8+dfsg1-1) ...
update-alternatives: using /usr/bin/gnuplot-nox to provide /usr/bin/gnuplot (gnuplot) in auto mode
Setting up libgles-dev:amd64 (1.3.1-1) ...
Setting up libapp-cmd-perl (0.331-1) ...
Setting up libglvnd-dev:amd64 (1.3.1-1) ...
Setting up libmoox-struct-perl (0.017-1) ...
Setting up lintian (2.55.0) ...
Setting up libqscintilla2-qt5-15 (2.11.2+dfsg-5) ...
Setting up dh-octave-autopkgtest (0.7.3) ...
Setting up imagemagick (8:6.9.10.23+dfsg-2.1+b2) ...
Setting up octave (5.2.0-1) ...
Setting up cme (1.031-1) ...
Setting up libgl1-mesa-dev:amd64 (19.3.3-1) ...
Setting up licensecheck (3.0.45-1) ...
Setting up liboctave-dev (5.2.0-1) ...
Setting up dh-autoreconf (19) ...
Setting up liblwp-protocol-https-perl (6.07-2) ...
Setting up libwww-perl (6.43-1) ...
Setting up debhelper (12.9) ...
Setting up libparse-debcontrol-perl (2.005-4) ...
Setting up libconfig-model-dpkg-perl (2.129) ...
Setting up dh-octave (0.7.3) ...
Setting up sbuild-build-depends-main-dummy (0.invalid.0) ...
Processing triggers for libc-bin (2.29-10) ...
Processing triggers for ca-certificates (20190110) ...
Updating certificates in /etc/ssl/certs...
0 added, 0 removed; done.
Running hooks in /etc/ca-certificates/update.d...
done.

+------------------------------------------------------------------------------+
| Check architectures                                                          |
+------------------------------------------------------------------------------+

Arch check ok (amd64 included in any all)

+------------------------------------------------------------------------------+
| Build environment                                                            |
+------------------------------------------------------------------------------+

Kernel: Linux 4.19.0-6-cloud-amd64 #1 SMP Debian 4.19.67-2+deb10u2 (2019-11-11) amd64 (x86_64)
Toolchain package versions: binutils_2.34-3 dpkg-dev_1.19.7 g++-9_9.2.1-30 gcc-9_9.2.1-30 libc6-dev_2.29-10 libstdc++-8-dev_8.3.0-29 libstdc++-9-dev_9.2.1-30 libstdc++6_10-20200222-1 linux-libc-dev_5.4.19-1
Package versions: adduser_3.118 aglfn_1.7+git20191031.4036a9c-2 apt_1.8.4 autoconf_2.69-11.1 automake_1:1.16.1-4 autopoint_0.19.8.1-10 autotools-dev_20180224.1 base-files_11 base-passwd_3.5.47 bash_5.0-5 binutils_2.34-3 binutils-common_2.34-3 binutils-x86-64-linux-gnu_2.34-3 bsdmainutils_11.1.2+b1 bsdutils_1:2.34-0.1 build-essential_12.8 bzip2_1.0.8-2 ca-certificates_20190110 clang-9_1:9.0.1-8 cme_1.031-1 coreutils_8.30-3+b1 cpp_4:9.2.1-3.1 cpp-9_9.2.1-30 dash_0.5.10.2-6 debconf_1.5.73 debhelper_12.9 debian-archive-keyring_2019.1 debianutils_4.9.1 dh-autoreconf_19 dh-octave_0.7.3 dh-octave-autopkgtest_0.7.3 dh-strip-nondeterminism_1.6.3-2 diffstat_1.63-1 diffutils_1:3.7-3 dpkg_1.19.7 dpkg-dev_1.19.7 dwz_0.13-5 e2fsprogs_1.45.5-2 fakeroot_1.24-1 fdisk_2.34-0.1 file_1:5.38-4 findutils_4.7.0-1 fontconfig_2.13.1-2+b1 fontconfig-config_2.13.1-2 fonts-dejavu-core_2.37-1 fonts-freefont-otf_20120503-9 fonts-urw-base35_20170801.1-3 g++_4:9.2.1-3.1 g++-9_9.2.1-30 gcc_4:9.2.1-3.1 gcc-10-base_10-20200222-1 gcc-8-base_8.3.0-29 gcc-9_9.2.1-30 gcc-9-base_9.2.1-30 gettext_0.19.8.1-10 gettext-base_0.19.8.1-10 gfortran_4:9.2.1-3.1 gfortran-9_9.2.1-30 ghostscript_9.50~dfsg-5 gnuplot-data_5.2.8+dfsg1-1 gnuplot-nox_5.2.8+dfsg1-1 gpg_2.2.19-1 gpgconf_2.2.19-1 gpgv_2.2.19-1 grep_3.4-1 groff-base_1.22.4-4 gzip_1.9-3+b1 hdf5-helpers_1.10.4+repack-11 hicolor-icon-theme_0.17-2 hostname_3.23 imagemagick_8:6.9.10.23+dfsg-2.1+b2 imagemagick-6-common_8:6.9.10.23+dfsg-2.1 imagemagick-6.q16_8:6.9.10.23+dfsg-2.1+b2 init-system-helpers_1.57 intltool-debian_0.35.0+20060710.5 lib32gcc-s1_10-20200222-1 lib32gcc1_1:10-20200222-1 lib32stdc++6_10-20200222-1 libacl1_2.2.53-5 libaec-dev_1.0.4-1 libaec0_1.0.4-1 libalgorithm-c3-perl_0.10-1 libamd2_1:5.6.0+dfsg-2 libapp-cmd-perl_0.331-1 libapt-pkg-perl_0.1.36+b2 libapt-pkg5.0_1.8.4 libarchive-zip-perl_1.67-1 libarpack2_3.7.0-3 libarray-intspan-perl_2.003-1 libasan5_9.2.1-30 libasound2_1.2.1.2-2 libasound2-data_1.2.1.2-2 libassuan0_2.5.3-7 libatomic1_10-20200222-1 libattr1_1:2.4.48-5 libaudit-common_1:2.8.5-2 libaudit1_1:2.8.5-2+b1 libavahi-client3_0.7-5 libavahi-common-data_0.7-5 libavahi-common3_0.7-5 libb-hooks-endofscope-perl_0.24-1 libb-hooks-op-check-perl_0.22-1+b2 libberkeleydb-perl_0.62-1+b1 libbinutils_2.34-3 libblas-dev_3.9.0-1 libblas3_3.9.0-1 libblkid1_2.34-0.1 libboolean-perl_0.46-1 libbrotli1_1.0.7-6 libbsd0_0.10.0-1 libbz2-1.0_1.0.8-2 libc-bin_2.29-10 libc-dev-bin_2.29-10 libc6_2.29-10 libc6-dev_2.29-10 libc6-i386_2.29-10 libcairo2_1.16.0-4 libcamd2_1:5.6.0+dfsg-2 libcap-ng0_0.7.9-2.1+b1 libcapture-tiny-perl_0.48-1 libcarp-assert-more-perl_1.20-1 libcarp-assert-perl_0.21-1 libcc1-0_10-20200222-1 libccolamd2_1:5.6.0+dfsg-2 libcgi-pm-perl_4.46-1 libcholmod3_1:5.6.0+dfsg-2 libclang-common-9-dev_1:9.0.1-8 libclang-cpp9_1:9.0.1-8 libclass-accessor-perl_0.51-1 libclass-c3-perl_0.34-1 libclass-load-perl_0.25-1 libclass-method-modifiers-perl_2.13-1 libclass-xsaccessor-perl_1.19-3+b3 libclone-choose-perl_0.010-1 libclone-perl_0.43-2 libcolamd2_1:5.6.0+dfsg-2 libcom-err2_1.45.5-2 libconfig-model-backend-yaml-perl_2.133-2 libconfig-model-dpkg-perl_2.129 libconfig-model-perl_2.138-2 libconvert-binhex-perl_1.125-1 libcroco3_0.6.13-1 libcrypt-dev_1:4.4.10-10 libcrypt1_1:4.4.10-10 libctf-nobfd0_2.34-3 libctf0_2.34-3 libcups2_2.3.1-11 libcurl3-gnutls_7.68.0-1 libcxsparse3_1:5.6.0+dfsg-2 libdata-optlist-perl_0.110-1 libdata-section-perl_0.200007-1 libdatrie1_0.2.12-3 libdb5.3_5.3.28+dfsg1-0.6 libdbus-1-3_1.12.16-2 libde265-0_1.0.4-1 libdebconfclient0_0.251 libdebhelper-perl_12.9 libdevel-callchecker-perl_0.008-1+b1 libdevel-size-perl_0.83-1+b1 libdigest-hmac-perl_1.03+dfsg-2 libdouble-conversion3_3.1.5-5 libdpkg-perl_1.19.7 libdrm-amdgpu1_2.4.100-4 libdrm-common_2.4.100-4 libdrm-intel1_2.4.100-4 libdrm-nouveau2_2.4.100-4 libdrm-radeon1_2.4.100-4 libdrm2_2.4.100-4 libdynaloader-functions-perl_0.003-1 libedit2_3.1-20191231-1 libegl-dev_1.3.1-1 libegl-mesa0_19.3.3-1 libegl1_1.3.1-1 libelf1_0.176-1.1 libemail-valid-perl_1.202-1 libencode-locale-perl_1.05-1 liberror-perl_0.17029-1 libevdev2_1.8.901+dfsg-1 libexpat1_2.2.9-1 libexporter-lite-perl_0.08-1 libexporter-tiny-perl_1.002001-1 libext2fs2_1.45.5-2 libfakeroot_1.24-1 libfdisk1_2.34-0.1 libffi7_3.3-3 libfftw3-bin_3.3.8-2 libfftw3-dev_3.3.8-2 libfftw3-double3_3.3.8-2 libfftw3-long3_3.3.8-2 libfftw3-quad3_3.3.8-2 libfftw3-single3_3.3.8-2 libfile-basedir-perl_0.08-1 libfile-find-rule-perl_0.34-1 libfile-homedir-perl_1.004-1 libfile-listing-perl_6.04-1 libfile-stripnondeterminism-perl_1.6.3-2 libfile-which-perl_1.23-1 libflac8_1.3.3-1 libfltk-gl1.3_1.3.4-10 libfltk1.3_1.3.4-10 libfont-ttf-perl_1.06-1 libfontconfig1_2.13.1-2+b1 libfreetype6_2.10.1-2 libfribidi0_1.0.8-2 libfuture-perl_0.43-1 libgbm1_19.3.3-1 libgc1c2_1:7.6.4-0.4 libgcc-8-dev_8.3.0-29 libgcc-9-dev_9.2.1-30 libgcc-s1_10-20200222-1 libgcc1_1:10-20200222-1 libgcrypt20_1.8.5-5 libgd3_2.2.5-5.2 libgdbm-compat4_1.18.1-5 libgdbm6_1.18.1-5 libgetopt-long-descriptive-perl_0.104-1 libgfortran-9-dev_9.2.1-30 libgfortran5_10-20200222-1 libgl-dev_1.3.1-1 libgl1_1.3.1-1 libgl1-mesa-dev_19.3.3-1 libgl1-mesa-dri_19.3.3-1 libgl2ps1.4_1.4.0+dfsg1-2 libglapi-mesa_19.3.3-1 libgles-dev_1.3.1-1 libgles1_1.3.1-1 libgles2_1.3.1-1 libglib2.0-0_2.62.4-2 libglpk40_4.65-2 libglu1-mesa_9.0.1-1 libglvnd-dev_1.3.1-1 libglvnd0_1.3.1-1 libglx-dev_1.3.1-1 libglx-mesa0_19.3.3-1 libglx0_1.3.1-1 libgmp-dev_2:6.2.0+dfsg-4 libgmp10_2:6.2.0+dfsg-4 libgmpxx4ldbl_2:6.2.0+dfsg-4 libgnutls30_3.6.12-2 libgomp1_10-20200222-1 libgpg-error0_1.37-1 libgraphicsmagick++-q16-12_1.4+really1.3.35-1 libgraphicsmagick-q16-3_1.4+really1.3.35-1 libgraphite2-3_1.3.13-11 libgs9_9.50~dfsg-5 libgs9-common_9.50~dfsg-5 libgssapi-krb5-2_1.17-6 libgudev-1.0-0_233-1 libharfbuzz0b_2.6.4-1 libhash-fieldhash-perl_0.15-1+b2 libhash-merge-perl_0.300-1 libhdf5-103_1.10.4+repack-11 libhdf5-cpp-103_1.10.4+repack-11 libhdf5-dev_1.10.4+repack-11 libheif1_1.6.1-1 libhogweed5_3.5.1+really3.5.1-2 libhtml-parser-perl_3.72-5 libhtml-tagset-perl_3.20-4 libhtml-tree-perl_5.07-2 libhttp-cookies-perl_6.08-1 libhttp-date-perl_6.05-1 libhttp-message-perl_6.18-1 libhttp-negotiate-perl_6.01-1 libice6_2:1.0.9-2 libicu63_63.2-2 libidn11_1.33-2.2 libidn2-0_2.2.0-2 libijs-0.35_0.35-15 libimport-into-perl_1.002005-1 libinput-bin_1.15.2-1 libinput10_1.15.2-1 libio-async-loop-epoll-perl_0.20-1 libio-async-perl_0.75-1 libio-html-perl_1.001-1 libio-pty-perl_1:1.12-1 libio-socket-ssl-perl_2.067-1 libio-string-perl_1.08-3 libio-stringy-perl_2.111-3 libio-tiecombine-perl_1.005-1 libipc-run-perl_20180523.0-2 libipc-system-simple-perl_1.26-1 libisl22_0.22.1-1 libitm1_10-20200222-1 libjack-jackd2-0_1.9.12~dfsg-2+b1 libjbig0_2.1-3.1+b2 libjbig2dec0_0.17-1 libjpeg-dev_1:1.5.2-2 libjpeg62-turbo_1:1.5.2-2+b1 libjpeg62-turbo-dev_1:1.5.2-2+b1 libjson-perl_4.02000-2 libk5crypto3_1.17-6 libkeyutils1_1.6.1-2 libkrb5-3_1.17-6 libkrb5support0_1.17-6 liblapack-dev_3.9.0-1 liblapack3_3.9.0-1 liblcms2-2_2.9-4 libldap-2.4-2_2.4.49+dfsg-1 libldap-common_2.4.49+dfsg-1 liblinux-epoll-perl_0.017-1 liblist-compare-perl_0.53-1 liblist-moreutils-perl_0.416-1+b5 liblist-someutils-perl_0.58-1 libllvm9_1:9.0.1-8 liblog-any-adapter-screen-perl_0.140-1 liblog-any-perl_1.708-1 liblog-log4perl-perl_1.49-1 liblqr-1-0_0.4.2-2.1 liblsan0_10-20200222-1 libltdl7_2.4.6-13 liblua5.3-0_5.3.3-1.1+b1 liblwp-mediatypes-perl_6.04-1 liblwp-protocol-https-perl_6.07-2 liblz4-1_1.9.2-2 liblzma5_5.2.4-1+b1 libmagic-mgc_1:5.38-4 libmagic1_1:5.38-4 libmagickcore-6.q16-6_8:6.9.10.23+dfsg-2.1+b2 libmagickwand-6.q16-6_8:6.9.10.23+dfsg-2.1+b2 libmailtools-perl_2.21-1 libmetis5_5.1.0.dfsg-5+b2 libmime-tools-perl_5.509-1 libmldbm-perl_2.05-2 libmodule-implementation-perl_0.09-1 libmodule-pluggable-perl_5.2-1 libmodule-runtime-perl_0.016-1 libmoo-perl_2.003006-1 libmoox-aliases-perl_0.001006-1 libmoox-struct-perl_0.017-1 libmount1_2.34-0.1 libmouse-perl_2.5.9-1 libmousex-nativetraits-perl_1.09-2 libmousex-strictconstructor-perl_0.02-2 libmpc3_1.1.0-1 libmpfr-dev_4.0.2-1 libmpfr6_4.0.2-1 libmpx2_8.3.0-29 libmro-compat-perl_0.13-1 libmtdev1_1.1.5-1.1 libnamespace-clean-perl_0.27-1 libncurses-dev_6.1+20191019-1 libncurses6_6.1+20191019-1 libncursesw6_6.1+20191019-1 libnet-dns-perl_1.22-1 libnet-domain-tld-perl_1.75-1 libnet-http-perl_6.19-1 libnet-ip-perl_1.26-2 libnet-smtp-ssl-perl_1.04-1 libnet-ssleay-perl_1.88-2 libnettle7_3.5.1+really3.5.1-2 libnghttp2-14_1.40.0-1 libnuma1_2.0.12-1+b1 libnumber-compare-perl_0.03-1 libnumber-range-perl_0.12-1 libobjc-8-dev_8.3.0-29 libobjc-9-dev_9.2.1-30 libobjc4_10-20200222-1 libobject-id-perl_0.1.2-2 liboctave-dev_5.2.0-1 liboctave7_5.2.0-1 libogg0_1.3.2-1+b1 libomp-9-dev_1:9.0.1-8 libomp5-9_1:9.0.1-8 libopengl-dev_1.3.1-1 libopengl0_1.3.1-1 libopenjp2-7_2.3.1-1 libopus0_1.3-1+b1 libp11-kit0_0.23.20-1 libpackage-stash-perl_0.38-1 libpam-modules_1.3.1-5 libpam-modules-bin_1.3.1-5 libpam-runtime_1.3.1-5 libpam0g_1.3.1-5 libpango-1.0-0_1.42.4-8 libpangocairo-1.0-0_1.42.4-8 libpangoft2-1.0-0_1.42.4-8 libpaper1_1.1.28+b1 libparams-classify-perl_0.015-1+b2 libparams-util-perl_1.07-3+b5 libparams-validate-perl_1.29-3 libparse-debcontrol-perl_2.005-4 libparse-recdescent-perl_1.967015+dfsg-2 libpath-iterator-rule-perl_1.014-1 libpath-tiny-perl_0.108-1 libpciaccess0_0.14-1 libpcre2-16-0_10.34-7 libpcre2-8-0_10.34-7 libpcre3_2:8.39-12+b1 libperl5.30_5.30.0-9 libpipeline1_1.5.2-2 libpixman-1-0_0.36.0-1 libpng16-16_1.6.37-2 libpod-constants-perl_0.19-1 libpod-pom-perl_2.01-3 libportaudio2_19.6.0-1 libpsl5_0.20.2-2 libpthread-stubs0-dev_0.4-1 libqhull7_2015.2-4 libqrupdate1_1.1.2-3 libqscintilla2-qt5-15_2.11.2+dfsg-5 libqscintilla2-qt5-l10n_2.11.2+dfsg-5 libqt5core5a_5.12.5+dfsg-8 libqt5dbus5_5.12.5+dfsg-8 libqt5gui5_5.12.5+dfsg-8 libqt5help5_5.12.5-2+b2 libqt5network5_5.12.5+dfsg-8 libqt5printsupport5_5.12.5+dfsg-8 libqt5sql5_5.12.5+dfsg-8 libqt5widgets5_5.12.5+dfsg-8 libqt5xml5_5.12.5+dfsg-8 libquadmath0_10-20200222-1 libre-engine-re2-perl_0.13-5 libre2-5_20200101+dfsg-1 libreadline-dev_8.0-3 libreadline8_8.0-3 libregexp-common-perl_2017060201-1 libregexp-pattern-license-perl_3.2.0-1 libregexp-pattern-perl_0.2.12-1 librole-tiny-perl_2.001004-1 librtmp1_2.4+20151223.gitfa8646d.1-2+b1 libsamplerate0_0.1.9-2 libsasl2-2_2.1.27+dfsg-2 libsasl2-modules-db_2.1.27+dfsg-2 libseccomp2_2.4.2-2 libselinux1_3.0-1+b1 libsemanage-common_3.0-1 libsemanage1_3.0-1+b1 libsensors-config_1:3.6.0-2 libsensors5_1:3.6.0-2 libsepol1_3.0-1 libsigsegv2_2.12-2 libsm6_2:1.2.3-1 libsmartcols1_2.34-0.1 libsndfile1_1.0.28-7 libsoftware-license-perl_0.103014-2 libsoftware-licensemoreutils-perl_1.004-1 libsort-key-perl_1.33-2+b2 libsort-versions-perl_1.62-1 libsqlite3-0_3.31.1-3 libss2_1.45.5-2 libssh2-1_1.8.0-2.1 libssl1.1_1.1.1d-2 libstdc++-8-dev_8.3.0-29 libstdc++-9-dev_9.2.1-30 libstdc++6_10-20200222-1 libstrictures-perl_2.000006-1 libstring-copyright-perl_0.003006-1 libstring-escape-perl_2010.002-2 libstring-rewriteprefix-perl_0.008-1 libstruct-dumb-perl_0.09-1 libsub-exporter-perl_0.987-1 libsub-exporter-progressive-perl_0.001013-1 libsub-identify-perl_0.14-1+b2 libsub-install-perl_0.928-1 libsub-name-perl_0.26-1 libsub-override-perl_0.09-2 libsub-quote-perl_2.006006-1 libsub-uplevel-perl_0.2800-1 libsuitesparseconfig5_1:5.6.0+dfsg-2 libsystemd0_244.3-1 libsz2_1.0.4-1 libtasn1-6_4.16.0-2 libtest-exception-perl_0.43-1 libtext-autoformat-perl_1.750000-1 libtext-glob-perl_0.10-1 libtext-levenshtein-damerau-perl_0.41-1 libtext-levenshtein-perl_0.13-1 libtext-reform-perl_1.20-3 libtext-template-perl_1.58-1 libtext-unidecode-perl_1.30-1 libthai-data_0.1.28-3 libthai0_0.1.28-3 libtiff5_4.1.0+git191117-2 libtimedate-perl_2.3100-1 libtinfo6_6.1+20191019-1 libtool_2.4.6-13 libtry-tiny-perl_0.30-1 libtsan0_10-20200222-1 libtype-tiny-perl_1.008001-2 libubsan1_10-20200222-1 libuchardet0_0.0.6-3 libudev1_244.3-1 libumfpack5_1:5.6.0+dfsg-2 libunistring2_0.9.10-2 liburi-perl_1.76-2 libuuid1_2.34-0.1 libvariable-magic-perl_0.62-1+b2 libvorbis0a_1.3.6-2 libvorbisenc2_1.3.6-2 libvulkan1_1.2.131.2-1 libwacom-common_1.1-2 libwacom2_1.1-2 libwayland-client0_1.18.0-1 libwayland-server0_1.18.0-1 libwebp6_0.6.1-2+b1 libwebpmux3_0.6.1-2+b1 libwmf0.2-7_0.2.8.4-17 libwww-perl_6.43-1 libwww-robotrules-perl_6.02-1 libx11-6_2:1.6.8-1 libx11-data_2:1.6.8-1 libx11-dev_2:1.6.8-1 libx11-xcb1_2:1.6.8-1 libx265-179_3.2.1-1 libxau-dev_1:1.0.8-1+b2 libxau6_1:1.0.8-1+b2 libxcb-dri2-0_1.13.1-5 libxcb-dri3-0_1.13.1-5 libxcb-glx0_1.13.1-5 libxcb-icccm4_0.4.1-1.1 libxcb-image0_0.4.0-1+b2 libxcb-keysyms1_0.4.0-1+b2 libxcb-present0_1.13.1-5 libxcb-randr0_1.13.1-5 libxcb-render-util0_0.3.9-1+b1 libxcb-render0_1.13.1-5 libxcb-shape0_1.13.1-5 libxcb-shm0_1.13.1-5 libxcb-sync1_1.13.1-5 libxcb-util0_0.3.8-3+b2 libxcb-xfixes0_1.13.1-5 libxcb-xinerama0_1.13.1-5 libxcb-xinput0_1.13.1-5 libxcb-xkb1_1.13.1-5 libxcb1_1.13.1-5 libxcb1-dev_1.13.1-5 libxcursor1_1:1.2.0-2 libxdamage1_1:1.1.5-1 libxdmcp-dev_1:1.1.2-3 libxdmcp6_1:1.1.2-3 libxext6_2:1.3.3-1+b2 libxfixes3_1:5.0.3-1 libxft2_2.3.2-2 libxinerama1_2:1.1.4-2 libxkbcommon-x11-0_0.10.0-1 libxkbcommon0_0.10.0-1 libxml-libxml-perl_2.0134+dfsg-1+b1 libxml-namespacesupport-perl_1.12-1 libxml-sax-base-perl_1.09-1 libxml-sax-perl_1.02+dfsg-1 libxml2_2.9.10+dfsg-3 libxpm4_1:3.5.12-1 libxrender1_1:0.9.10-1 libxshmfence1_1.3-1 libxxf86vm1_1:1.1.4-1+b2 libyaml-0-2_0.2.2-1 libyaml-libyaml-perl_0.81+repack-1 libyaml-perl_1.30-1 libyaml-tiny-perl_1.73-1 libz3-4_4.8.7-4 libzstd1_1.4.4+dfsg-3 licensecheck_3.0.45-1 lintian_2.55.0 linux-libc-dev_5.4.19-1 login_1:4.8.1-1 logsave_1.45.5-2 lsb-base_11.1.0 m4_1.4.18-4 make_4.2.1-1.2 man-db_2.9.0-2 mawk_1.3.4.20200120-2 mount_2.34-0.1 ncurses-base_6.1+20191019-1 ncurses-bin_6.1+20191019-1 netbase_6.1 octave_5.2.0-1 octave-common_5.2.0-1 openssl_1.1.1d-2 passwd_1:4.8.1-1 patch_2.7.6-6 patchutils_0.3.4-2+b1 perl_5.30.0-9 perl-base_5.30.0-9 perl-modules-5.30_5.30.0-9 perl-openssl-defaults_4 po-debconf_1.0.21 poppler-data_0.4.9-2 readline-common_8.0-3 sbuild-build-depends-main-dummy_0.invalid.0 sed_4.7-1 sensible-utils_0.0.12+nmu1 sysvinit-utils_2.96-2.1 t1utils_1.41-3 tar_1.30+dfsg-6+b1 tex-common_6.13 texinfo_6.7.0.dfsg.2-5 tzdata_2019c-3 ucf_3.0038+nmu1 util-linux_2.34-0.1 x11-common_1:7.7+20 x11proto-core-dev_2018.4-4 x11proto-dev_2018.4-4 xkb-data_2.26-2 xorg-sgml-doctools_1:1.11-1 xtrans-dev_1.3.5-1 xz-utils_5.2.4-1+b1 zlib1g_1:1.2.11.dfsg-2 zlib1g-dev_1:1.2.11.dfsg-2

+------------------------------------------------------------------------------+
| Build                                                                        |
+------------------------------------------------------------------------------+


Unpack source
-------------

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA256

Format: 3.0 (quilt)
Source: octave-interval
Binary: octave-interval, octave-interval-doc
Architecture: any all
Version: 3.2.0-5
Maintainer: Debian Octave Group <team+pkg-octave-team@tracker.debian.org>
Uploaders: Oliver Heimlich <oheim@posteo.de>,
Homepage: https://octave.sourceforge.io/interval/
Standards-Version: 4.4.1
Vcs-Browser: https://salsa.debian.org/pkg-octave-team/octave-interval
Vcs-Git: https://salsa.debian.org/pkg-octave-team/octave-interval.git
Testsuite: autopkgtest-pkg-octave
Build-Depends: debhelper-compat (= 12), dh-octave (>= 0.7.1), ghostscript, libmpfr-dev (>= 3.1.0)
Build-Depends-Indep: texinfo, imagemagick, gnuplot-nox
Package-List:
 octave-interval deb math optional arch=any
 octave-interval-doc deb doc optional arch=all
Checksums-Sha1:
 9890115852745616ec5ca157aec518243d5b8030 2672463 octave-interval_3.2.0.orig.tar.gz
 2ebbc275eeb281d7abc31e1b48e17a8c33f613d3 7688 octave-interval_3.2.0-5.debian.tar.xz
Checksums-Sha256:
 40dca588e32167484a3e9d1c77858db11f4eacb5ea92dcc37c78144fd6f91a28 2672463 octave-interval_3.2.0.orig.tar.gz
 6d980b026ff22db457e871d8e2ca78ca80e9d2246b4f915a9b0c9bf54544e7b4 7688 octave-interval_3.2.0-5.debian.tar.xz
Files:
 be6ea4eef9e92f9198776c05c5b56f30 2672463 octave-interval_3.2.0.orig.tar.gz
 d5f34ecb4110a65b7b0b01ff25253cf7 7688 octave-interval_3.2.0-5.debian.tar.xz

-----BEGIN PGP SIGNATURE-----

iQIzBAEBCAAdFiEEP0ZDkUmP6HS9tdmPISSqGYN4XJAFAl3C58kACgkQISSqGYN4
XJDqtQ/+LvyocwRKrhX2qdC++9z/fWIYrSuBr+YB2tU5RxeKutLwwrsGEdghfOOD
rfG4LFGhsPS0MW/OC+8UumDKhOcg3nAxqUM9+SekbcJ9f7m/9qCbpuzwTmEJNSd9
85CPV8Iwao+t2JIVRVhRIaBjhZHsheVOKovHQmtG/7D8bKAL4rtOCLzDRhuQbNw7
1a02xpm/YGdybmoqb++c5yqqvHJ4g4M/iObOM6DA91MhiFaTxQ5sQlNBiBHmb/1/
/f9iI7CU5GgYzm5pxQvH4wOhxTNPqDVij1ETHd2f1ERp54F6DpkrXvPLiUN0SnQV
F3LCax1ik1QN1luCESH+M8A74hQGiAy818YkdBb3MgbZvJulI8R4ShuxPsyPUFkG
GO9cMNcJmZ5hvrLYi3vVLb5vaACHJxKQuxl5SXoy97/aNaBMCL+EPegHSadmWlSG
qgUia/3vgBaI6VKyGFghw19aAZ+O7/JnHGFWaZkrJ8wzUyA52FE1KJIuqSC4d6Hc
rWz4OLCrIXwfV6JhhkW6I2EPckx+eo1vLJT098eU05Ogm4j+09/Cw0Rvcy/BGHm3
Uy8RqcYXa8zOK0LwYvcOezorSCir7OV6Sl6V6EToaiUIWEmeCdtyG2gAXKCoOJot
zcDLI6evwM9oGzGttYIB9lQuqQZPRhjqnxzNmk6IiGa2BdVmPN4=
=3qY0
-----END PGP SIGNATURE-----

gpgv: unknown type of key resource 'trustedkeys.kbx'
gpgv: keyblock resource '/sbuild-nonexistent/.gnupg/trustedkeys.kbx': General error
gpgv: Signature made Wed Nov  6 15:33:29 2019 UTC
gpgv:                using RSA key 3F464391498FE874BDB5D98F2124AA1983785C90
gpgv: Can't check signature: No public key
dpkg-source: warning: failed to verify signature on ./octave-interval_3.2.0-5.dsc
dpkg-source: info: extracting octave-interval in /<<PKGBUILDDIR>>
dpkg-source: info: unpacking octave-interval_3.2.0.orig.tar.gz
dpkg-source: info: unpacking octave-interval_3.2.0-5.debian.tar.xz
dpkg-source: info: using patch list from debian/patches/series
dpkg-source: info: applying clean-src-compatibility-dir.patch
dpkg-source: info: applying no-pkg-load-at-docs-build.patch
dpkg-source: info: applying ignore-fesetround-tests.patch
dpkg-source: info: applying xtest-in-mpfr-matrix-mul-d.patch

Check disk space
----------------

Sufficient free space for build

User Environment
----------------

APT_CONFIG=/var/lib/sbuild/apt.conf
HOME=/sbuild-nonexistent
LANG=C.UTF-8
LC_ALL=C.UTF-8
LOGNAME=user42
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games
SCHROOT_ALIAS_NAME=unstable
SCHROOT_CHROOT_NAME=sid-amd64-sbuild
SCHROOT_COMMAND=env
SCHROOT_GID=1001
SCHROOT_GROUP=user42
SCHROOT_SESSION_ID=sid-amd64-sbuild-6493c03f-eb65-43df-b060-bda47e8bbf49
SCHROOT_UID=1001
SCHROOT_USER=user42
SHELL=/bin/sh
USER=user42

dpkg-buildpackage
-----------------

Command: dpkg-buildpackage -us -uc -b -rfakeroot
dpkg-buildpackage: info: source package octave-interval
dpkg-buildpackage: info: source version 3.2.0-5
dpkg-buildpackage: info: source distribution unstable
dpkg-buildpackage: info: source changed by Rafael Laboissiere <rafael@debian.org>
 dpkg-source --before-build .
dpkg-buildpackage: info: host architecture amd64
dpkg-source: info: using options from octave-interval-3.2.0/debian/source/options: --extend-diff-ignore=src/crlibm/Makefile\.in|src/crlibm/aclocal\.m4|src/crlibm/scs_lib/Makefile\.in|src/crlibm/configure|src/crlibm/depcomp
 debian/rules clean
dh clean --buildsystem=octave --with=octave
   debian/rules override_dh_auto_clean
make[1]: Entering directory '/<<PKGBUILDDIR>>'
dh_auto_clean
	dh_octave_clean
make[2]: Entering directory '/<<PKGBUILDDIR>>/src'
make[2]: -p: Command not found
make[2]: -p: Command not found
/bin/sh: 1: -dM: not found
test ! -e crlibm/Makefile || make -C crlibm clean
make -C compatibility clean
make[3]: Entering directory '/<<PKGBUILDDIR>>/src/compatibility'
make[3]: -p: Command not found
rm -f octave.cc
make[3]: Leaving directory '/<<PKGBUILDDIR>>/src/compatibility'
rm -f *.oct *.o
make[2]: Leaving directory '/<<PKGBUILDDIR>>/src'
[ ! -f Makefile ] || /usr/bin/make clean
[ ! -f doc/Makefile ] || /usr/bin/make -C doc clean
make[2]: Entering directory '/<<PKGBUILDDIR>>/doc'
rm -f manual.html manual.pdf image/interval-sombrero.m.png image/poly-example-surf.m.png image/contractor-rings-intersect.m.png image/interval-plot3.m.png image/poly-example-roots-simple.m.png image/contractor-rings-union.m.png image/interval-vs-normal-plot.m.png image/poly-example-roots-with-deriv.m.png image/cameleon.m.png
rm -f *.aux *.cp *.fn *.ky *.log *.pg *.toc *.tp *.vr
make[2]: Leaving directory '/<<PKGBUILDDIR>>/doc'
[ ! -f src/crlibm/Makefile ] || /usr/bin/make -C src/crlibm maintainer-clean
make[1]: Leaving directory '/<<PKGBUILDDIR>>'
   dh_autoreconf_clean -O--buildsystem=octave
   dh_clean -O--buildsystem=octave
 debian/rules binary
dh binary --buildsystem=octave --with=octave
   dh_update_autotools_config -O--buildsystem=octave
   dh_autoreconf -O--buildsystem=octave
   dh_octave_version -O--buildsystem=octave
Checking the Octave version... ok
   debian/rules override_dh_auto_configure
make[1]: Entering directory '/<<PKGBUILDDIR>>'
(cd src/crlibm ; autoreconf -i)
Makefile.am: installing './depcomp'
dh_auto_configure
make[1]: Leaving directory '/<<PKGBUILDDIR>>'
   dh_auto_build -O--buildsystem=octave
   dh_auto_test -O--buildsystem=octave
   create-stamp debian/debhelper-build-stamp
   dh_testroot -O--buildsystem=octave
   dh_prep -O--buildsystem=octave
   debian/rules override_dh_auto_install-indep
make[1]: Entering directory '/<<PKGBUILDDIR>>'
dh_auto_install
	octave --no-gui --no-history --silent --no-init-file --no-window-system /usr/share/dh-octave/install-pkg.m
warning: creating installation directory /<<PKGBUILDDIR>>/debian/octave-interval/usr/share/octave/packages
warning: called from
    install at line 30 column 5
    pkg at line 441 column 9
    /usr/share/dh-octave/install-pkg.m at line 43 column 1
checking whether the C++ compiler works... yes
checking for C++ compiler default output file name... a.out
checking for suffix of executables... 
checking whether we are cross compiling... no
checking for suffix of object files... o
checking whether we are using the GNU C++ compiler... yes
checking whether g++ accepts -g... yes
checking for mpfr_init2 in -lmpfr... yes
checking for floor in -lm... yes
checking how to run the C++ preprocessor... g++ -E
checking for grep that handles long lines and -e... /bin/grep
checking for egrep... /bin/grep -E
checking for ANSI C header files... yes
checking for sys/types.h... yes
checking for sys/stat.h... yes
checking for stdlib.h... yes
checking for string.h... yes
checking for memory.h... yes
checking for strings.h... yes
checking for inttypes.h... yes
checking for stdint.h... yes
checking for unistd.h... yes
checking sstream usability... yes
checking sstream presence... yes
checking for sstream... yes
checking fenv.h usability... yes
checking fenv.h presence... yes
checking for fenv.h... yes
checking mpfr.h usability... yes
checking mpfr.h presence... yes
checking for mpfr.h... yes
checking for int32_t... yes
checking for uint32_t... yes
checking for uint64_t... yes
checking for uint8_t... yes
checking for error_at_line... yes
checking for fesetround... yes
make[2]: Entering directory '/<<PKGBUILDDIR>>/src'
(cd crlibm && ./configure --disable-dependency-tracking --enable-sse2)
 [MKOCTFILE] crlibm_function.cc
 [MAKE] compatibility
 [MKOCTFILE] __setround__.cc
make[3]: Entering directory '/<<PKGBUILDDIR>>/src/compatibility'
g++ -c -Wdate-time -D_FORTIFY_SOURCE=2 -fPIC -I/usr/include/octave-5.2.0/octave/.. -I/usr/include/octave-5.2.0/octave  -pthread -fopenmp -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security    crlibm_function.cc -o crlibm_function.o
g++ -c -Wdate-time -D_FORTIFY_SOURCE=2 -fPIC -I/usr/include/octave-5.2.0/octave/.. -I/usr/include/octave-5.2.0/octave  -pthread -fopenmp -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security  -Wno-unknown-pragmas   __setround__.cc -o /tmp/oct-feYDiP.o
Detected Octave version: 5.2.0
cp "octave_current.cc" "octave.cc"
make[3]: Leaving directory '/<<PKGBUILDDIR>>/src/compatibility'
 [MKOCTFILE] intervaltotext.cc
g++ -c -Wdate-time -D_FORTIFY_SOURCE=2 -fPIC -I/usr/include/octave-5.2.0/octave/.. -I/usr/include/octave-5.2.0/octave  -pthread -fopenmp -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security    intervaltotext.cc -o /tmp/oct-ymQPjN.o
checking for a BSD-compatible install... /usr/bin/install -c
checking whether build environment is sane... yes
checking for a thread-safe mkdir -p... /bin/mkdir -p
checking for gawk... no
checking for mawk... mawk
checking whether make sets $(MAKE)... yes
checking whether make supports nested variables... yes
checking build system type... x86_64-pc-linux-gnu
checking host system type... x86_64-pc-linux-gnu
checking whether make sets $(MAKE)... (cached) yes
checking for gcc... gcc
checking whether the C compiler works... yes
checking for C compiler default output file name... a.out
checking for suffix of executables... 
checking whether we are cross compiling... no
checking for suffix of object files... o
checking whether we are using the GNU C compiler... yes
checking whether gcc accepts -g... yes
checking for gcc option to accept ISO C89... none needed
checking whether gcc understands -c and -o together... yes
checking whether make supports the include directive... yes (GNU style)
checking dependency style of gcc... none
checking for ranlib... ranlib
checking whether ln -s works... yes
checking how to run the C preprocessor... gcc -E
checking for grep that handles long lines and -e... /bin/grep
checking for egrep... /bin/grep -E
checking for ANSI C header files... yes
checking for an ANSI C-conforming const... yes
checking for inline... inline
checking for sqrt... no
checking for sys/types.h... yes
checking for sys/stat.h... yes
checking for stdlib.h... yes
checking for string.h... yes
checking for memory.h... yes
checking for strings.h... yes
checking for inttypes.h... yes
checking for stdint.h... yes
checking for unistd.h... yes
checking fenv.h usability... g++ -I/usr/include/octave-5.2.0/octave/.. -I/usr/include/octave-5.2.0/octave  -pthread -fopenmp -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security -shared -Wl,-Bsymbolic -Wl,-z,relro  -Wno-unknown-pragmas -o __setround__.oct  /tmp/oct-feYDiP.o    -L/usr/lib/x86_64-linux-gnu  -Wl,-z,relro 
yes
checking fenv.h presence... yes
checking for fenv.h... yes
checking float.h usability...  [MKOCTFILE] mpfr_function_d.cc
g++ -c -Wdate-time -D_FORTIFY_SOURCE=2 -fPIC -I/usr/include/octave-5.2.0/octave/.. -I/usr/include/octave-5.2.0/octave  -pthread -fopenmp -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security    mpfr_function_d.cc -o /tmp/oct-e0Mo5T.o
yes
checking float.h presence... yes
checking for float.h... yes
checking fpu_control.h usability... yes
checking fpu_control.h presence... yes
checking for fpu_control.h... yes
checking for log in -lm...  [MKOCTFILE] mpfr_linspace_d.cc
g++ -c -Wdate-time -D_FORTIFY_SOURCE=2 -fPIC -I/usr/include/octave-5.2.0/octave/.. -I/usr/include/octave-5.2.0/octave  -pthread -fopenmp -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security    mpfr_linspace_d.cc -o /tmp/oct-TeIt3f.o
yes
checking whether byte ordering is bigendian... no
checking for long double with more range or precision than double... yes
checking size of int... 4
checking that generated files are newer than configure... done
configure: creating ./config.status
config.status: creating Makefile
config.status: creating scs_lib/Makefile
config.status: creating crlibm_config.h
config.status: executing depfiles commands
 [MKOCTFILE] mpfr_matrix_mul_d.cc
g++ -c -Wdate-time -D_FORTIFY_SOURCE=2 -fPIC -I/usr/include/octave-5.2.0/octave/.. -I/usr/include/octave-5.2.0/octave  -pthread -fopenmp -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security  -fopenmp   mpfr_matrix_mul_d.cc -o /tmp/oct-YXNb7Y.o
g++ -I/usr/include/octave-5.2.0/octave/.. -I/usr/include/octave-5.2.0/octave  -pthread -fopenmp -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security -shared -Wl,-Bsymbolic -Wl,-z,relro  -o intervaltotext.oct  /tmp/oct-ymQPjN.o   -lmpfr  -L/usr/lib/x86_64-linux-gnu  -Wl,-z,relro 
 [MKOCTFILE] mpfr_matrix_sqr_d.cc
g++ -c -Wdate-time -D_FORTIFY_SOURCE=2 -fPIC -I/usr/include/octave-5.2.0/octave/.. -I/usr/include/octave-5.2.0/octave  -pthread -fopenmp -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security  -fopenmp   mpfr_matrix_sqr_d.cc -o /tmp/oct-g4xEra.o
mpfr_function_d.cc:220:7: warning: 'mpfr_root' is deprecated [-Wdeprecated-declarations]
      mpfr_root (mp, mp, static_cast <uint64_t> (arg2.elem(i)), rnd);
      ^
/usr/include/mpfr.h:691:1: note: 'mpfr_root' has been explicitly marked deprecated here
MPFR_DEPRECATED
^
/usr/include/mpfr.h:326:42: note: expanded from macro 'MPFR_DEPRECATED'
# define MPFR_DEPRECATED __attribute__ ((deprecated))
                                         ^
g++ -I/usr/include/octave-5.2.0/octave/.. -I/usr/include/octave-5.2.0/octave  -pthread -fopenmp -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security -shared -Wl,-Bsymbolic -Wl,-z,relro  -o mpfr_linspace_d.oct  /tmp/oct-TeIt3f.o   -lmpfr  -L/usr/lib/x86_64-linux-gnu  -Wl,-z,relro 
 [MKOCTFILE] mpfr_to_string_d.cc
g++ -c -Wdate-time -D_FORTIFY_SOURCE=2 -fPIC -I/usr/include/octave-5.2.0/octave/.. -I/usr/include/octave-5.2.0/octave  -pthread -fopenmp -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security    mpfr_to_string_d.cc -o /tmp/oct-zJP5qI.o
1 warning generated.
g++ -I/usr/include/octave-5.2.0/octave/.. -I/usr/include/octave-5.2.0/octave  -pthread -fopenmp -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security -shared -Wl,-Bsymbolic -Wl,-z,relro  -o mpfr_function_d.oct  /tmp/oct-e0Mo5T.o   -lmpfr  -L/usr/lib/x86_64-linux-gnu  -Wl,-z,relro 
 [MKOCTFILE] mpfr_vector_sum_d.cc
g++ -c -Wdate-time -D_FORTIFY_SOURCE=2 -fPIC -I/usr/include/octave-5.2.0/octave/.. -I/usr/include/octave-5.2.0/octave  -pthread -fopenmp -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security    mpfr_vector_sum_d.cc -o /tmp/oct-nuk4f5.o
g++ -I/usr/include/octave-5.2.0/octave/.. -I/usr/include/octave-5.2.0/octave  -pthread -fopenmp -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security -shared -Wl,-Bsymbolic -Wl,-z,relro  -fopenmp -o mpfr_matrix_mul_d.oct  /tmp/oct-YXNb7Y.o   -lmpfr  -L/usr/lib/x86_64-linux-gnu  -Wl,-z,relro 
 [MKOCTFILE] mpfr_vector_dot_d.cc
g++ -c -Wdate-time -D_FORTIFY_SOURCE=2 -fPIC -I/usr/include/octave-5.2.0/octave/.. -I/usr/include/octave-5.2.0/octave  -pthread -fopenmp -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security    mpfr_vector_dot_d.cc -o /tmp/oct-E4SzzI.o
g++ -I/usr/include/octave-5.2.0/octave/.. -I/usr/include/octave-5.2.0/octave  -pthread -fopenmp -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security -shared -Wl,-Bsymbolic -Wl,-z,relro  -fopenmp -o mpfr_matrix_sqr_d.oct  /tmp/oct-g4xEra.o   -lmpfr  -L/usr/lib/x86_64-linux-gnu  -Wl,-z,relro 
make -C crlibm CFLAGS+="-fPIC -Wno-div-by-zero -Wno-unused-variable -Wno-unused-but-set-variable"
make[3]: Entering directory '/<<PKGBUILDDIR>>/src/crlibm'
(CDPATH="${ZSH_VERSION+.}:" && cd . && /bin/bash /<<PKGBUILDDIR>>/src/crlibm/missing autoheader)
rm -f stamp-h1
touch crlibm_config.h.in
cd . && /bin/bash ./config.status crlibm_config.h
config.status: creating crlibm_config.h
config.status: crlibm_config.h is unchanged
make  all-recursive
make[4]: Entering directory '/<<PKGBUILDDIR>>/src/crlibm'
Making all in scs_lib
make[5]: Entering directory '/<<PKGBUILDDIR>>/src/crlibm/scs_lib'
gcc -DHAVE_CONFIG_H -I. -I..  -I.. -Wdate-time -D_FORTIFY_SOURCE=2  -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security -fPIC -Wno-div-by-zero -Wno-unused-variable -Wno-unused-but-set-variable -c -o scs_private.o scs_private.c
warning: unknown warning option '-Wno-unused-but-set-variable'; did you mean '-Wno-unused-const-variable'? [-Wunknown-warning-option]
1 warning generated.
gcc -DHAVE_CONFIG_H -I. -I..  -I.. -Wdate-time -D_FORTIFY_SOURCE=2  -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security -fPIC -Wno-div-by-zero -Wno-unused-variable -Wno-unused-but-set-variable -c -o double2scs.o double2scs.c
warning: unknown warning option '-Wno-unused-but-set-variable'; did you mean '-Wno-unused-const-variable'? [-Wunknown-warning-option]
1 warning generated.
gcc -DHAVE_CONFIG_H -I. -I..  -I.. -Wdate-time -D_FORTIFY_SOURCE=2  -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security -fPIC -Wno-div-by-zero -Wno-unused-variable -Wno-unused-but-set-variable -c -o print_scs.o print_scs.c
warning: unknown warning option '-Wno-unused-but-set-variable'; did you mean '-Wno-unused-const-variable'? [-Wunknown-warning-option]
1 warning generated.
gcc -DHAVE_CONFIG_H -I. -I..  -I.. -Wdate-time -D_FORTIFY_SOURCE=2  -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security -fPIC -Wno-div-by-zero -Wno-unused-variable -Wno-unused-but-set-variable -c -o division_scs.o division_scs.c
warning: unknown warning option '-Wno-unused-but-set-variable'; did you mean '-Wno-unused-const-variable'? [-Wunknown-warning-option]
1 warning generated.
gcc -DHAVE_CONFIG_H -I. -I..  -I.. -Wdate-time -D_FORTIFY_SOURCE=2  -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security -fPIC -Wno-div-by-zero -Wno-unused-variable -Wno-unused-but-set-variable -c -o addition_scs.o addition_scs.c
warning: unknown warning option '-Wno-unused-but-set-variable'; did you mean '-Wno-unused-const-variable'? [-Wunknown-warning-option]
1 warning generated.
gcc -DHAVE_CONFIG_H -I. -I..  -I.. -Wdate-time -D_FORTIFY_SOURCE=2  -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security -fPIC -Wno-div-by-zero -Wno-unused-variable -Wno-unused-but-set-variable -c -o multiplication_scs.o multiplication_scs.c
warning: unknown warning option '-Wno-unused-but-set-variable'; did you mean '-Wno-unused-const-variable'? [-Wunknown-warning-option]
1 warning generated.
gcc -DHAVE_CONFIG_H -I. -I..  -I.. -Wdate-time -D_FORTIFY_SOURCE=2  -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security -fPIC -Wno-div-by-zero -Wno-unused-variable -Wno-unused-but-set-variable -c -o scs2double.o scs2double.c
warning: unknown warning option '-Wno-unused-but-set-variable'; did you mean '-Wno-unused-const-variable'? [-Wunknown-warning-option]
1 warning generated.
gcc -DHAVE_CONFIG_H -I. -I..  -I.. -Wdate-time -D_FORTIFY_SOURCE=2  -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security -fPIC -Wno-div-by-zero -Wno-unused-variable -Wno-unused-but-set-variable -c -o zero_scs.o zero_scs.c
warning: unknown warning option '-Wno-unused-but-set-variable'; did you mean '-Wno-unused-const-variable'? [-Wunknown-warning-option]
1 warning generated.
gcc -DHAVE_CONFIG_H -I. -I..  -I.. -Wdate-time -D_FORTIFY_SOURCE=2  -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security -fPIC -Wno-div-by-zero -Wno-unused-variable -Wno-unused-but-set-variable -c -o scs2mpfr.o scs2mpfr.c
warning: unknown warning option '-Wno-unused-but-set-variable'; did you mean '-Wno-unused-const-variable'? [-Wunknown-warning-option]
1 warning generated.
rm -f libscs.a
ar cr libscs.a scs_private.o double2scs.o print_scs.o division_scs.o addition_scs.o multiplication_scs.o scs2double.o zero_scs.o scs2mpfr.o 
ranlib libscs.a
make[5]: Leaving directory '/<<PKGBUILDDIR>>/src/crlibm/scs_lib'
Making all in .
make[5]: Entering directory '/<<PKGBUILDDIR>>/src/crlibm'
gcc -DHAVE_CONFIG_H -I.   -Wdate-time -D_FORTIFY_SOURCE=2 -std=c99 -Wall -msse2 -mfpmath=sse  -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security -fPIC -Wno-div-by-zero -Wno-unused-variable -Wno-unused-but-set-variable -c -o crlibm_private.o crlibm_private.c
warning: unknown warning option '-Wno-unused-but-set-variable'; did you mean '-Wno-unused-const-variable'? [-Wunknown-warning-option]
1 warning generated.
gcc -DHAVE_CONFIG_H -I.   -Wdate-time -D_FORTIFY_SOURCE=2 -std=c99 -Wall -msse2 -mfpmath=sse  -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security -fPIC -Wno-div-by-zero -Wno-unused-variable -Wno-unused-but-set-variable -c -o triple-double.o triple-double.c
warning: unknown warning option '-Wno-unused-but-set-variable'; did you mean '-Wno-unused-const-variable'? [-Wunknown-warning-option]
1 warning generated.
gcc -DHAVE_CONFIG_H -I.   -Wdate-time -D_FORTIFY_SOURCE=2 -std=c99 -Wall -msse2 -mfpmath=sse  -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security -fPIC -Wno-div-by-zero -Wno-unused-variable -Wno-unused-but-set-variable -c -o exp-td.o exp-td.c
warning: unknown warning option '-Wno-unused-but-set-variable'; did you mean '-Wno-unused-const-variable'? [-Wunknown-warning-option]
1 warning generated.
gcc -DHAVE_CONFIG_H -I.   -Wdate-time -D_FORTIFY_SOURCE=2 -std=c99 -Wall -msse2 -mfpmath=sse  -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security -fPIC -Wno-div-by-zero -Wno-unused-variable -Wno-unused-but-set-variable -c -o exp-td-standalone.o exp-td-standalone.c
warning: unknown warning option '-Wno-unused-but-set-variable'; did you mean '-Wno-unused-const-variable'? [-Wunknown-warning-option]
1 warning generated.
gcc -DHAVE_CONFIG_H -I.   -Wdate-time -D_FORTIFY_SOURCE=2 -std=c99 -Wall -msse2 -mfpmath=sse  -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security -fPIC -Wno-div-by-zero -Wno-unused-variable -Wno-unused-but-set-variable -c -o expm1-standalone.o expm1-standalone.c
warning: unknown warning option '-Wno-unused-but-set-variable'; did you mean '-Wno-unused-const-variable'? [-Wunknown-warning-option]
1 warning generated.
gcc -DHAVE_CONFIG_H -I.   -Wdate-time -D_FORTIFY_SOURCE=2 -std=c99 -Wall -msse2 -mfpmath=sse  -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security -fPIC -Wno-div-by-zero -Wno-unused-variable -Wno-unused-but-set-variable -c -o expm1.o expm1.c
warning: unknown warning option '-Wno-unused-but-set-variable'; did you mean '-Wno-unused-const-variable'? [-Wunknown-warning-option]
g++ -I/usr/include/octave-5.2.0/octave/.. -I/usr/include/octave-5.2.0/octave  -pthread -fopenmp -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security -shared -Wl,-Bsymbolic -Wl,-z,relro  -o mpfr_vector_sum_d.oct  /tmp/oct-nuk4f5.o   -lmpfr  -L/usr/lib/x86_64-linux-gnu  -Wl,-z,relro 
gcc -DHAVE_CONFIG_H -I.   -Wdate-time -D_FORTIFY_SOURCE=2 -std=c99 -Wall -msse2 -mfpmath=sse  -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security -fPIC -Wno-div-by-zero -Wno-unused-variable -Wno-unused-but-set-variable -c -o log-de.o log-de.c
warning: unknown warning option '-Wno-unused-but-set-variable'; did you mean '-Wno-unused-const-variable'? [-Wunknown-warning-option]
1 warning generated.
1 warning generated.
gcc -DHAVE_CONFIG_H -I.   -Wdate-time -D_FORTIFY_SOURCE=2 -std=c99 -Wall -msse2 -mfpmath=sse  -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security -fPIC -Wno-div-by-zero -Wno-unused-variable -Wno-unused-but-set-variable -c -o log1p.o log1p.c
gcc -DHAVE_CONFIG_H -I.   -Wdate-time -D_FORTIFY_SOURCE=2 -std=c99 -Wall -msse2 -mfpmath=sse  -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security -fPIC -Wno-div-by-zero -Wno-unused-variable -Wno-unused-but-set-variable -c -o log10-td.o log10-td.c
warning: unknown warning option '-Wno-unused-but-set-variable'; did you mean '-Wno-unused-const-variable'? [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unused-but-set-variable'; did you mean '-Wno-unused-const-variable'? [-Wunknown-warning-option]
log1p.c:213:8: warning: variable 'E' is used uninitialized whenever 'if' condition is true [-Wsometimes-uninitialized]
   if ((xdb.i[HI] & 0x7fffffff) < 0x3f700000) {
       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
log1p.c:424:7: note: uninitialized use occurs here
   if(E==0)
      ^
log1p.c:213:4: note: remove the 'if' if its condition is always false
   if ((xdb.i[HI] & 0x7fffffff) < 0x3f700000) {
   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
log1p.c:176:9: note: initialize the variable 'E' to silence this warning
   int E, index;
        ^
         = 0
log1p.c:501:8: warning: variable 'E' is used uninitialized whenever 'if' condition is true [-Wsometimes-uninitialized]
   if ((xdb.i[HI] & 0x7fffffff) < 0x3f700000) {
       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
log1p.c:712:7: note: uninitialized use occurs here
   if(E==0)
      ^
log1p.c:501:4: note: remove the 'if' if its condition is always false
   if ((xdb.i[HI] & 0x7fffffff) < 0x3f700000) {
   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
log1p.c:455:9: note: initialize the variable 'E' to silence this warning
   int E, index;
        ^
         = 0
log1p.c:788:8: warning: variable 'E' is used uninitialized whenever 'if' condition is true [-Wsometimes-uninitialized]
   if ((xdb.i[HI] & 0x7fffffff) < 0x3f700000) {
       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
log1p.c:999:7: note: uninitialized use occurs here
   if(E==0)
      ^
log1p.c:788:4: note: remove the 'if' if its condition is always false
   if ((xdb.i[HI] & 0x7fffffff) < 0x3f700000) {
   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
log1p.c:734:9: note: initialize the variable 'E' to silence this warning
   int E, index;
        ^
         = 0
log1p.c:1075:8: warning: variable 'E' is used uninitialized whenever 'if' condition is true [-Wsometimes-uninitialized]
   if ((xdb.i[HI] & 0x7fffffff) < 0x3f700000) {
       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
log1p.c:1286:7: note: uninitialized use occurs here
   if(E==0)
      ^
log1p.c:1075:4: note: remove the 'if' if its condition is always false
   if ((xdb.i[HI] & 0x7fffffff) < 0x3f700000) {
   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
log1p.c:1021:9: note: initialize the variable 'E' to silence this warning
   int E, index;
        ^
         = 0
5 warnings generated.
gcc -DHAVE_CONFIG_H -I.   -Wdate-time -D_FORTIFY_SOURCE=2 -std=c99 -Wall -msse2 -mfpmath=sse  -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security -fPIC -Wno-div-by-zero -Wno-unused-variable -Wno-unused-but-set-variable -c -o log2-td.o log2-td.c
1 warning generated.
gcc -DHAVE_CONFIG_H -I.   -Wdate-time -D_FORTIFY_SOURCE=2 -std=c99 -Wall -msse2 -mfpmath=sse  -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security -fPIC -Wno-div-by-zero -Wno-unused-variable -Wno-unused-but-set-variable -c -o rem_pio2_accurate.o rem_pio2_accurate.c
warningwarning: unknown warning option '-Wno-unused-but-set-variable'; did you mean '-Wno-unused-const-variable'? [-Wunknown-warning-option]
: unknown warning option '-Wno-unused-but-set-variable'; did you mean '-Wno-unused-const-variable'? [-Wunknown-warning-option]
rem_pio2_accurate.c:98:14: warning: equality comparison with extraneous parentheses [-Wparentheses-equality]
  if ((X_IND == -1)){
       ~~~~~~^~~~~
rem_pio2_accurate.c:98:14: note: remove extraneous parentheses around the comparison to silence this warning
  if ((X_IND == -1)){
      ~      ^    ~
rem_pio2_accurate.c:98:14: note: use '=' to turn this equality comparison into an assignment
  if ((X_IND == -1)){
             ^~
             =
2 warnings generated.
gcc -DHAVE_CONFIG_H -I.   -Wdate-time -D_FORTIFY_SOURCE=2 -std=c99 -Wall -msse2 -mfpmath=sse  -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security -fPIC -Wno-div-by-zero -Wno-unused-variable -Wno-unused-but-set-variable -c -o trigo_fast.o trigo_fast.c
warning: unknown warning option '-Wno-unused-but-set-variable'; did you mean '-Wno-unused-const-variable'? [-Wunknown-warning-option]
trigo_fast.c:181:14: warning: equality comparison with extraneous parentheses [-Wparentheses-equality]
  if ((X_IND == -2)){
       ~~~~~~^~~~~
trigo_fast.c:181:14: note: remove extraneous parentheses around the comparison to silence this warning
  if ((X_IND == -2)){
      ~      ^    ~
trigo_fast.c:181:14: note: use '=' to turn this equality comparison into an assignment
  if ((X_IND == -2)){
             ^~
             =
trigo_fast.c:423:15: warning: equality comparison with extraneous parentheses [-Wparentheses-equality]
    if((index == 0)) { 
        ~~~~~~^~~~
trigo_fast.c:423:15: note: remove extraneous parentheses around the comparison to silence this warning
    if((index == 0)) { 
       ~      ^   ~
trigo_fast.c:423:15: note: use '=' to turn this equality comparison into an assignment
    if((index == 0)) { 
              ^~
              =
1 warning generated.
gcc -DHAVE_CONFIG_H -I.   -Wdate-time -D_FORTIFY_SOURCE=2 -std=c99 -Wall -msse2 -mfpmath=sse  -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security -fPIC -Wno-div-by-zero -Wno-unused-variable -Wno-unused-but-set-variable -c -o trigo_accurate.o trigo_accurate.c
warning: unknown warning option '-Wno-unused-but-set-variable'; did you mean '-Wno-unused-const-variable'? [-Wunknown-warning-option]
1 warning generated.
gcc -DHAVE_CONFIG_H -I.   -Wdate-time -D_FORTIFY_SOURCE=2 -std=c99 -Wall -msse2 -mfpmath=sse  -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security -fPIC -Wno-div-by-zero -Wno-unused-variable -Wno-unused-but-set-variable -c -o trigpi.o trigpi.c
warning: unknown warning option '-Wno-unused-but-set-variable'; did you mean '-Wno-unused-const-variable'? [-Wunknown-warning-option]
3 warnings generated.
gcc -DHAVE_CONFIG_H -I.   -Wdate-time -D_FORTIFY_SOURCE=2 -std=c99 -Wall -msse2 -mfpmath=sse  -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security -fPIC -Wno-div-by-zero -Wno-unused-variable -Wno-unused-but-set-variable -c -o asincos.o asincos.c
warning: unknown warning option '-Wno-unused-but-set-variable'; did you mean '-Wno-unused-const-variable'? [-Wunknown-warning-option]
g++ -I/usr/include/octave-5.2.0/octave/.. -I/usr/include/octave-5.2.0/octave  -pthread -fopenmp -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security -shared -Wl,-Bsymbolic -Wl,-z,relro  -o mpfr_to_string_d.oct  /tmp/oct-zJP5qI.o   -lmpfr  -L/usr/lib/x86_64-linux-gnu  -Wl,-z,relro 
gcc -DHAVE_CONFIG_H -I.   -Wdate-time -D_FORTIFY_SOURCE=2 -std=c99 -Wall -msse2 -mfpmath=sse  -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security -fPIC -Wno-div-by-zero -Wno-unused-variable -Wno-unused-but-set-variable -c -o pow.o pow.c
warning: unknown warning option '-Wno-unused-but-set-variable'; did you mean '-Wno-unused-const-variable'? [-Wunknown-warning-option]
g++ -I/usr/include/octave-5.2.0/octave/.. -I/usr/include/octave-5.2.0/octave  -pthread -fopenmp -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security -shared -Wl,-Bsymbolic -Wl,-z,relro  -o mpfr_vector_dot_d.oct  /tmp/oct-E4SzzI.o   -lmpfr  -L/usr/lib/x86_64-linux-gnu  -Wl,-z,relro 
gcc -DHAVE_CONFIG_H -I.   -Wdate-time -D_FORTIFY_SOURCE=2 -std=c99 -Wall -msse2 -mfpmath=sse  -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security -fPIC -Wno-div-by-zero -Wno-unused-variable -Wno-unused-but-set-variable -c -o atan_fast.o atan_fast.c
warning: unknown warning option '-Wno-unused-but-set-variable'; did you mean '-Wno-unused-const-variable'? [-Wunknown-warning-option]
1 warning generated.
1 warning generated.
gcc -DHAVE_CONFIG_H -I.   -Wdate-time -D_FORTIFY_SOURCE=2 -std=c99 -Wall -msse2 -mfpmath=sse  -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security -fPIC -Wno-div-by-zero -Wno-unused-variable -Wno-unused-but-set-variable -c -o atan_accurate.o atan_accurate.c
gcc -DHAVE_CONFIG_H -I.   -Wdate-time -D_FORTIFY_SOURCE=2 -std=c99 -Wall -msse2 -mfpmath=sse  -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security -fPIC -Wno-div-by-zero -Wno-unused-variable -Wno-unused-but-set-variable -c -o csh_fast.o csh_fast.c
warning: unknown warning option '-Wno-unused-but-set-variable'; did you mean '-Wno-unused-const-variable'? [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unused-but-set-variable'; did you mean '-Wno-unused-const-variable'? [-Wunknown-warning-option]
1 warning generated.
1 warning generated.
1 warning generated.
1 warning generated.
rm -f libcrlibm.a
ar cr libcrlibm.a crlibm_private.o triple-double.o exp-td.o exp-td-standalone.o expm1-standalone.o expm1.o log-de.o log1p.o log10-td.o log2-td.o rem_pio2_accurate.o trigo_fast.o trigo_accurate.o trigpi.o asincos.o pow.o atan_fast.o atan_accurate.o csh_fast.o scs_lib/scs_private.o scs_lib/addition_scs.o scs_lib/division_scs.o scs_lib/print_scs.o scs_lib/double2scs.o scs_lib/zero_scs.o scs_lib/multiplication_scs.o scs_lib/scs2double.o
ranlib libcrlibm.a
make[5]: Leaving directory '/<<PKGBUILDDIR>>/src/crlibm'
make[4]: Leaving directory '/<<PKGBUILDDIR>>/src/crlibm'
make[3]: Leaving directory '/<<PKGBUILDDIR>>/src/crlibm'
 [MKOCTFILE] crlibm_function.o
g++ -I/usr/include/octave-5.2.0/octave/.. -I/usr/include/octave-5.2.0/octave  -pthread -fopenmp -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security -shared -Wl,-Bsymbolic -Wl,-z,relro  -o crlibm_function.oct  crlibm_function.o crlibm/asincos.o crlibm/atan_accurate.o crlibm/atan_fast.o crlibm/crlibm_private.o crlibm/csh_fast.o crlibm/exp-td-standalone.o crlibm/exp-td.o crlibm/expm1-standalone.o crlibm/expm1.o crlibm/log-de.o crlibm/log10-td.o crlibm/log1p.o crlibm/log2-td.o crlibm/pow.o crlibm/rem_pio2_accurate.o crlibm/trigo_accurate.o crlibm/trigo_fast.o crlibm/trigpi.o crlibm/triple-double.o crlibm/scs_lib/addition_scs.o crlibm/scs_lib/division_scs.o crlibm/scs_lib/double2scs.o crlibm/scs_lib/multiplication_scs.o crlibm/scs_lib/print_scs.o crlibm/scs_lib/scs2double.o crlibm/scs_lib/scs2mpfr.o crlibm/scs_lib/scs_private.o crlibm/scs_lib/zero_scs.o    -L/usr/lib/x86_64-linux-gnu  -Wl,-z,relro 
make[2]: Leaving directory '/<<PKGBUILDDIR>>/src'
copyfile /<<PKGBUILDDIR>>/./src/__setround__.oct /<<PKGBUILDDIR>>/./src/crlibm_function.oct /<<PKGBUILDDIR>>/./src/intervaltotext.oct /<<PKGBUILDDIR>>/./src/mpfr_function_d.oct /<<PKGBUILDDIR>>/./src/mpfr_linspace_d.oct /<<PKGBUILDDIR>>/./src/mpfr_matrix_mul_d.oct /<<PKGBUILDDIR>>/./src/mpfr_matrix_sqr_d.oct /<<PKGBUILDDIR>>/./src/mpfr_to_string_d.oct /<<PKGBUILDDIR>>/./src/mpfr_vector_dot_d.oct /<<PKGBUILDDIR>>/./src/mpfr_vector_sum_d.oct /<<PKGBUILDDIR>>/./inst/x86_64-pc-linux-gnu-api-v53
For information about changes from previous versions of the interval package, run 'news interval'.
# The documentation build needs to load the package,
# so we have to set paths for the build process.
OCTAVE='octave --no-window-system --no-init-file'	\
	make -C doc manual.html
make[2]: Entering directory '/<<PKGBUILDDIR>>/doc'
 [OCTAVE] image/interval-sombrero.m
warning: crlibm is not working properly, using MPFR as a fallback
warning: called from
    __check_crlibm__>verify_crlibm at line 56 column 5
    __check_crlibm__ at line 33 column 3
    sin at line 57 column 3
    sin at line 45 column 10
    image/interval-sombrero.m at line 19 column 3
 [IMAGEMAGICK] image/interval-sombrero.m.png
 [OCTAVE] image/poly-example-surf.m
 [IMAGEMAGICK] image/poly-example-surf.m.png
 [MAKEINFO --plaintext] image/contractor-rings-intersect.m.texinfo
 [OCTAVE] image/contractor-rings-intersect.m
 [IMAGEMAGICK] image/contractor-rings-intersect.m.png
 [MAKEINFO --plaintext] image/interval-plot3.m.texinfo
 [OCTAVE] image/interval-plot3.m
 [IMAGEMAGICK] image/interval-plot3.m.png
 [MAKEINFO --plaintext] image/poly-example-roots-simple.m.texinfo
 [OCTAVE] image/poly-example-roots-simple.m
 [IMAGEMAGICK] image/poly-example-roots-simple.m.png
convert-im6.q16: profile 'icc': 'RGB ': RGB color space not permitted on grayscale PNG `image/poly-example-roots-simple.m.png' @ warning/png.c/MagickPNGWarningHandler/1667.
 [MAKEINFO --plaintext] image/contractor-rings-union.m.texinfo
 [OCTAVE] image/contractor-rings-union.m
 [IMAGEMAGICK] image/contractor-rings-union.m.png
 [MAKEINFO --plaintext] image/interval-vs-normal-plot.m.texinfo
 [OCTAVE] image/interval-vs-normal-plot.m
warning: crlibm is not working properly, using MPFR as a fallback
warning: called from
    __check_crlibm__>verify_crlibm at line 56 column 5
    __check_crlibm__ at line 33 column 3
    sin at line 57 column 3
    image/interval-vs-normal-plot.m at line 6 column 6
 [IMAGEMAGICK] image/interval-vs-normal-plot.m.png
 [MAKEINFO --plaintext] image/poly-example-roots-with-deriv.m.texinfo
 [OCTAVE] image/poly-example-roots-with-deriv.m
 [IMAGEMAGICK] image/poly-example-roots-with-deriv.m.png
convert-im6.q16: profile 'icc': 'RGB ': RGB color space not permitted on grayscale PNG `image/poly-example-roots-with-deriv.m.png' @ warning/png.c/MagickPNGWarningHandler/1667.
 [MAKEINFO --plaintext] image/cameleon.m.texinfo
 [OCTAVE] image/cameleon.m
warning: crlibm is not working properly, using MPFR as a fallback
warning: called from
    __check_crlibm__>verify_crlibm at line 56 column 5
    __check_crlibm__ at line 33 column 3
    sin at line 57 column 3
    check_parameters at line 34 column 10
    fsolve>vectorized at line 456 column 12
    fsolve at line 254 column 34
    image/cameleon.m at line 48 column 25
 [IMAGEMAGICK] image/cameleon.m.png
grep: ../packinfo/DESCRIPTION: No such file or directory
 [MAKEINFO --html] manual.texinfo
rm image/cameleon.m image/poly-example-roots-simple.m image/contractor-rings-union.m image/interval-vs-normal-plot.m image/poly-example-roots-with-deriv.m image/interval-plot3.m image/contractor-rings-intersect.m
make[2]: Leaving directory '/<<PKGBUILDDIR>>/doc'
# dh_installdocs does not support subdirectories,
# so we move everything in place
mkdir -p /<<PKGBUILDDIR>>/debian/octave-interval-doc/usr/share/doc/octave-interval/image
cp doc/manual.html /<<PKGBUILDDIR>>/debian/octave-interval-doc/usr/share/doc/octave-interval/
cp doc/image/*.png doc/image/*.svg /<<PKGBUILDDIR>>/debian/octave-interval-doc/usr/share/doc/octave-interval/image/
rm -rf \
	 /<<PKGBUILDDIR>>/debian/octave-interval//*/doc
make[1]: Leaving directory '/<<PKGBUILDDIR>>'
   dh_auto_install -O--buildsystem=octave -Noctave-interval-doc
	octave --no-gui --no-history --silent --no-init-file --no-window-system /usr/share/dh-octave/install-pkg.m
checking whether the C++ compiler works... yes
checking for C++ compiler default output file name... a.out
checking for suffix of executables... 
checking whether we are cross compiling... no
checking for suffix of object files... o
checking whether we are using the GNU C++ compiler... yes
checking whether g++ accepts -g... yes
checking for mpfr_init2 in -lmpfr... yes
checking for floor in -lm... yes
checking how to run the C++ preprocessor... g++ -E
checking for grep that handles long lines and -e... /bin/grep
checking for egrep... /bin/grep -E
checking for ANSI C header files... yes
checking for sys/types.h... yes
checking for sys/stat.h... yes
checking for stdlib.h... yes
checking for string.h... yes
checking for memory.h... yes
checking for strings.h... yes
checking for inttypes.h... yes
checking for stdint.h... yes
checking for unistd.h... yes
checking sstream usability... yes
checking sstream presence... yes
checking for sstream... yes
checking fenv.h usability... yes
checking fenv.h presence... yes
checking for fenv.h... yes
checking mpfr.h usability... yes
checking mpfr.h presence... yes
checking for mpfr.h... yes
checking for int32_t... yes
checking for uint32_t... yes
checking for uint64_t... yes
checking for uint8_t... yes
checking for error_at_line... yes
checking for fesetround... yes
make[1]: Entering directory '/<<PKGBUILDDIR>>/src'
make[1]: Nothing to be done for 'all'.
make[1]: Leaving directory '/<<PKGBUILDDIR>>/src'
copyfile /<<PKGBUILDDIR>>/./src/__setround__.oct /<<PKGBUILDDIR>>/./src/crlibm_function.oct /<<PKGBUILDDIR>>/./src/intervaltotext.oct /<<PKGBUILDDIR>>/./src/mpfr_function_d.oct /<<PKGBUILDDIR>>/./src/mpfr_linspace_d.oct /<<PKGBUILDDIR>>/./src/mpfr_matrix_mul_d.oct /<<PKGBUILDDIR>>/./src/mpfr_matrix_sqr_d.oct /<<PKGBUILDDIR>>/./src/mpfr_to_string_d.oct /<<PKGBUILDDIR>>/./src/mpfr_vector_dot_d.oct /<<PKGBUILDDIR>>/./src/mpfr_vector_sum_d.oct /<<PKGBUILDDIR>>/./inst/x86_64-pc-linux-gnu-api-v53
For information about changes from previous versions of the interval package, run 'news interval'.
   dh_octave_check -O--buildsystem=octave
Checking package...
Checking m files ...
[inst/@infsup/mulrev.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/mulrev.m
***** #IEEE Std 1788-2015 mulRevToPair examples
***** test
  [u, v] = mulrev (infsup (0), infsup (1, 2));
  assert (isempty (u) & isempty (v));
***** test
  [u, v] = mulrev (infsup (0), infsup (0, 1));
  assert (isentire (u) & isempty (v));
***** test
  [u, v] = mulrev (infsup (1), infsup (1, 2));
  assert (eq (u, infsup (1, 2)) & isempty (v));
***** test
  [u, v] = mulrev (infsup (1, inf), infsup (1));
  assert (eq (u, infsup (0, 1)) & isempty (v));
***** test
  [u, v] = mulrev (infsup (-1, 1), infsup (1, 2));
  assert (eq (u, infsup (-inf, -1)) & eq (v, infsup (1, inf)));
***** test
  [u, v] = mulrev (infsup (-inf, inf), infsup (1));
  assert (eq (u, infsup (-inf, 0)) & eq (v, infsup (0, inf)));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.mulRevToPair1;
 for testcase = [testcases]'
   assert (isequaln (...
     nthargout (1, 2, @mulrev, testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.mulRevToPair1;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (nthargout (1, 2, @mulrev, in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.mulRevToPair1;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (nthargout (1, 2, @mulrev, in1, in2), out));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.mulRevToPair2;
 for testcase = [testcases]'
   assert (isequaln (...
     nthargout (2, @mulrev, testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.mulRevToPair2;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (nthargout (2, @mulrev, in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.mulRevToPair2;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (nthargout (2, @mulrev, in1, in2), out));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.mulRev;
 for testcase = [testcases]'
   assert (isequaln (...
     mulrev (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.mulRev;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (mulrev (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.mulRev;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (mulrev (in1, in2), out));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.mulRevTen;
 for testcase = [testcases]'
   assert (isequaln (...
     mulrev (testcase.in{1}, testcase.in{2}, testcase.in{3}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.mulRevTen;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 in3 = vertcat (vertcat (testcases.in){:, 3});
 out = vertcat (testcases.out);
 assert (isequaln (mulrev (in1, in2, in3), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.mulRevTen;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 in3 = vertcat (vertcat (testcases.in){:, 3});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 in3 = reshape ([in3; in3(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (mulrev (in1, in2, in3), out));
18 tests, 18 passed, 0 known failure, 0 skipped
[inst/@infsup/prepad.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/prepad.m
***** assert (prepad (infsup (2:4), 4, 1) == infsup (1:4));
***** assert (prepad (infsup (0:2), 2, 1) == infsup (1:2));
***** test
 if (compare_versions (OCTAVE_VERSION (), "4.0.0", ">="))
   assert (prepad (infsup (0), 10, 0, 3) == infsup (zeros (1, 1, 10)))
 else
   # In Octave 3.8.x it is not possible to increase the number of dimensions.
 endif
***** assert (prepad (infsup (zeros (1, 2, 2)), 3) == infsup (zeros (1, 3, 2)));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsup/numel.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/numel.m
***** assert (numel (infsup ([])), 0);
***** assert (numel (infsup (0)), 1);
***** assert (numel (infsup (zeros (3, 1))), 3);
***** assert (numel (infsup (zeros (1, 4))), 4);
***** assert (numel (infsup (zeros (3, 4))), 12);
***** assert (numel (infsup (ones (2, 3)), 3:5), 3);
***** assert (numel (infsup (ones (2, 3)), ":", 2), 2);
***** assert (numel (infsup (ones (2, 3)), 2, ":"), 3);
***** # numel is called implicitly during this subsref expression (see bug #53375)
***** assert (infsup ()(:).inf, inf);
***** error <invalid use> numel (1, infsup(1));
10 tests, 10 passed, 0 known failure, 0 skipped
[inst/@infsup/factorial.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/factorial.m
***** # from the documentation string
***** assert (factorial (infsup (6)) == 720);
***** assert (factorial (infsup (0)) == 1);
***** assert (factorial (infsup ("[0, 1.99]")) == 1);
***** assert (factorial (infsup ("[0, 2]")) == "[1, 2]");
***** assert (factorial (infsup ("[1.4, 1.6]")) == "[Empty]");
5 tests, 5 passed, 0 known failure, 0 skipped
[inst/@infsup/hdist.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/hdist.m
***** # from the documentation string
***** assert (hdist (infsup (1, 6), infsup (2, 8)), 2);
1 test, 1 passed, 0 known failure, 0 skipped
[inst/@infsup/pow2.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/pow2.m
***** # from the documentation string
 assert (pow2 (infsup (5)) == infsup (32));
***** # correct use of signed zeros
***** test
 x = pow2 (infsup (-inf, -realmax));
 assert (signbit (inf (x)));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.exp2;
 for testcase = [testcases]'
   assert (isequaln (...
     pow2 (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.exp2;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (pow2 (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.exp2;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (pow2 (in1), out));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsup/plot.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/plot.m
***** # this test is rather pointless
***** test
  clf
  plot (empty ());
  close
***** demo
  clf
  hold on
  plot (infsup (0), infsup (0));
  plot (infsup (1, 2), infsup (0));
  plot (infsup (0), infsup (1, 2));
  plot (infsup (1, 2), infsup (1, 2));
  axis ([-.5, 2.5, -.5, 2.5]);
  hold off
***** demo
  clf
  plot (infsup (-rand (50, 1), +rand (50, 1)));
***** demo
  clf
  hold on
  axis off
  range = infsup (0, 9);
  x = linspace (inf (range), sup (range), 250);
  X = mince (range, 9);
  f = @ (x) 0.5 * sin (x) .* x .^ 2;
  y = f (x);
  Y = f (X);
  plot (range, f (range), [42 161 152]/255);
  plot (X, Y, [238 232 213]/255, [88 110 117]/255);
  plot (x, y, '-', 'color', [220 50 47]/255, 'linewidth', 2);
  hold off
1 test, 1 passed, 0 known failure, 0 skipped
[inst/@infsup/ceil.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/ceil.m
***** # Empty interval
***** assert (ceil (infsup ()) == infsup ());
***** # Singleton intervals
***** assert (ceil (infsup (0)) == infsup (0));
***** assert (ceil (infsup (0.5)) == infsup (1));
***** assert (ceil (infsup (-0.5)) == infsup (0));
***** # Bounded intervals
***** assert (ceil (infsup (-0.5, 0)) == infsup (0));
***** assert (ceil (infsup (0, 0.5)) == infsup (0, 1));
***** assert (ceil (infsup (0.25, 0.5)) == infsup (1));
***** assert (ceil (infsup (-1, 0)) == infsup (-1, 0));
***** assert (ceil (infsup (-1, 1)) == infsup (-1, 1));
***** assert (ceil (infsup (-realmin, realmin)) == infsup (0, 1));
***** assert (ceil (infsup (-realmax, realmax)) == infsup (-realmax, realmax));
***** # Unbounded intervals
***** assert (ceil (infsup (-realmin, inf)) == infsup (0, inf));
***** assert (ceil (infsup (-realmax, inf)) == infsup (-realmax, inf));
***** assert (ceil (infsup (-inf, realmin)) == infsup (-inf, 1));
***** assert (ceil (infsup (-inf, realmax)) == infsup (-inf, realmax));
***** assert (ceil (infsup (-inf, inf)) == infsup (-inf, inf));
***** # from the documentation string
***** assert (ceil (infsup (2.5, 3.5)) == infsup (3, 4));
***** assert (ceil (infsup (-.5, 5)) == infsup (0, 5));
***** # correct use of signed zeros
***** test
 x = ceil (infsup (-0.5));
 assert (signbit (inf (x)));
 assert (not (signbit (sup (x))));
***** test
 x = ceil (infsup (0));
 assert (signbit (inf (x)));
 assert (not (signbit (sup (x))));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.ceil;
 for testcase = [testcases]'
   assert (isequaln (...
     ceil (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.ceil;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (ceil (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.ceil;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (ceil (in1), out));
23 tests, 23 passed, 0 known failure, 0 skipped
[inst/@infsup/mtimes.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/mtimes.m
***** # from the documentation string
***** assert (infsup ([1, 2; 7, 15], [2, 2; 7.5, 15]) * infsup ([3, 3; 0, 1], [3, 3.25; 0, 2]) == infsup ([3, 5; 21, 36], [6, 10.5; 22.5, 54.375]));
***** # matrix multiplication using BLAS routines
***** assert (mtimes (infsup ([1, 2; 7, 15], [2, 2; 7.5, 15]), infsup ([3, 3; 0, 1], [3, 3.25; 0, 2]), 'valid') == infsup ([3, 5; 21, 36], [6, 10.5; 22.5, 54.375]));
2 tests, 2 passed, 0 known failure, 0 skipped
[inst/@infsup/sprintf.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/sprintf.m
***** assert (sprintf ("%g", infsup ("pi")), "3.14159 3.1416");
1 test, 1 passed, 0 known failure, 0 skipped
[inst/@infsup/cosrev.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/cosrev.m
***** # from the documentation string
***** assert (cosrev (0, infsup (6, 9)) == "[0x1.F6A7A2955385Ep2, 0x1.F6A7A2955386p2]");
warning: crlibm is not working properly, using MPFR as a fallback
***** # correct use of signed zeros
***** test
 x = cosrev (infsup (1), infsup (0));
 assert (signbit (inf (x)));
 assert (not (signbit (sup (x))));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.cosRev;
 for testcase = [testcases]'
   assert (isequaln (...
     cosrev (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.cosRev;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (cosrev (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.cosRev;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (cosrev (in1), out));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.cosRevBin;
 for testcase = [testcases]'
   assert (isequaln (...
     cosrev (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.cosRevBin;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (cosrev (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.cosRevBin;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (cosrev (in1, in2), out));
8 tests, 8 passed, 0 known failure, 0 skipped
[inst/@infsup/tanrev.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/tanrev.m
***** # from the documentation string
***** assert (tanrev (infsup (0), infsup (2, 4)) == infsup ("pi"));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.tanRev;
 for testcase = [testcases]'
   assert (isequaln (...
     tanrev (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.tanRev;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (tanrev (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.tanRev;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (tanrev (in1), out));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.tanRevBin;
 for testcase = [testcases]'
   assert (isequaln (...
     tanrev (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.tanRevBin;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (tanrev (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.tanRevBin;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (tanrev (in1, in2), out));
7 tests, 7 passed, 0 known failure, 0 skipped
[inst/@infsup/dilog.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/dilog.m
***** assert (dilog (infsup (-inf, inf)) == "[-Inf, +0x1.3BD3CC9BE45DFp1]");
***** # from the documentation string
***** assert (dilog (infsup (1)) == "[0x1.A51A6625307D3, 0x1.A51A6625307D4]");
2 tests, 2 passed, 0 known failure, 0 skipped
[inst/@infsup/newdec.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/newdec.m
***** # from the documentation string
***** assert (isequal (newdec (infsup (2, 3)), infsupdec (2, 3)));
***** assert (isequal (newdec (infsupdec (2, 3)), infsupdec (2, 3)));
***** assert (isequal (newdec (infsupdec (1, "trv")), infsupdec (1, "trv")));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.newDec;
 for testcase = [testcases]'
   assert (isequaln (...
     newdec (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.newDec;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (newdec (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.newDec;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (newdec (in1), out));
6 tests, 6 passed, 0 known failure, 0 skipped
[inst/@infsup/gauss.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/gauss.m
***** # from the documentation string
***** assert (gauss (infsup ([1, 0; 0, 2]), [2, 0; 0, 4]) == [2, 0; 0, 2]);
1 test, 1 passed, 0 known failure, 0 skipped
[inst/@infsup/horzcat.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/horzcat.m
***** assert (horzcat (infsup (1), infsup (2)) == infsup (horzcat (1, 2)));
***** test
 # from the documentation string
 a = infsup (2, 5);
 assert (horzcat (a, a, a) == infsup ([2, 2, 2], [5, 5, 5]));
2 tests, 2 passed, 0 known failure, 0 skipped
[inst/@infsup/polyval.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/polyval.m
***** assert (polyval (infsup (42), 0) == 42);
***** assert (polyval (infsup ([42 42]), 0) == 42);
***** assert (polyval (infsup ([42 42]), 1) == 84);
***** assert (polyval (infsup ([42 42]), -1) == 0);
***** assert (polyval (infsup ([-42 42 42]), .5) == -42*0.5^2 + 42*0.5 + 42);
***** assert (polyval (infsup (vec (pascal (3))), 0.1) == "[0X6.502E9A7231A08P+0, 0X6.502E9A7231A0CP+0]");
6 tests, 6 passed, 0 known failure, 0 skipped
[inst/@infsup/iscolumn.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/iscolumn.m
***** assert (not (iscolumn (infsup ([]))));
***** assert (iscolumn (infsup (0)));
***** assert (not (iscolumn (infsup (zeros (1, 2)))));
***** assert (iscolumn (infsup (zeros (2, 1))));
***** assert (not (iscolumn (infsup (zeros (5)))));
5 tests, 5 passed, 0 known failure, 0 skipped
[inst/@infsup/fprintf.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/fprintf.m
***** test
 if (compare_versions (OCTAVE_VERSION, "4.2", ">="))
   assert (evalc ("n = fprintf ('%g', infsup ('pi'));"), "3.14159 3.1416");
   assert (n, 14);
 endif
1 test, 1 passed, 0 known failure, 0 skipped
[inst/@infsup/rdivide.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/rdivide.m
***** # from the documentation string
***** assert (infsup (2, 3) ./ infsup (1, 2) == infsup (1, 3));
***** assert (1 ./ infsup (1, 4) == infsup (0.25, 1));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.div;
 for testcase = [testcases]'
   assert (isequaln (...
     rdivide (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.div;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (rdivide (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.div;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (rdivide (in1, in2), out));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.recip;
 for testcase = [testcases]'
   assert (isequaln (...
     rdivide (1, testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.recip;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (rdivide (1, in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsupdec.recip;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (rdivide (1, in1), out));
8 tests, 8 passed, 0 known failure, 0 skipped
[inst/@infsup/display.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/display.m
***** # Test for the display function are also largely done with the help of the
***** # doctest package.
***** # evalc has been introduced in Octave 4.2
***** test
 if (compare_versions (OCTAVE_VERSION, "4.2", ">="))
   assert (evalc ("display (infsup ())"), "[Empty]\n\n");
   assert (evalc ("display (infsupdec ())"), "[Empty]_trv\n\n");
 endif
***** test
 if (compare_versions (OCTAVE_VERSION, "4.2", ">="))
   assert (evalc ("a = infsup ()"), "a = [Empty]\n");
   assert (evalc ("b = infsupdec ()"), "b = [Empty]_trv\n");
 endif
***** test
 if (compare_versions (OCTAVE_VERSION, "4.2", ">="))
   assert (evalc ("a = infsup (); display (a)"), "a = [Empty]\n");
   assert (evalc ("b = infsupdec (); display (b)"), "b = [Empty]_trv\n");
 endif
***** test
 if (compare_versions (OCTAVE_VERSION, "4.2", ">=") && !ispc ())
   assert (evalc ("display (infsup (magic (3)))"), ...
    ["33 interval matrix\n", ...
     "\n", ...
     "   [8]   [1]   [6]\n", ...
     "   [3]   [5]   [7]\n", ...
     "   [4]   [9]   [2]\n", ...
     "\n"]);
 endif
***** test
 if (compare_versions (OCTAVE_VERSION, "4.2", ">=") && !ispc ())
   assert (evalc ("infsup (magic (3))"), ...
    ["ans = 33 interval matrix\n", ...
     "\n", ...
     "   [8]   [1]   [6]\n", ...
     "   [3]   [5]   [7]\n", ...
     "   [4]   [9]   [2]\n", ...
     "\n"]);
 endif
***** test
 if (compare_versions (OCTAVE_VERSION, "4.2", ">=") && !ispc ())
   assert (evalc ("infsup ('pi')"), "ans  [3.1415, 3.1416]\n");
 endif
***** test
 if (compare_versions (OCTAVE_VERSION, "4.2", ">=") && !ispc ())
   assert (evalc ("infsup (1:3)"), ...
    ["ans = 13 interval vector\n", ...
     "\n", ...
     "   [1]   [2]   [3]\n", ...
     "\n"]);
 endif
***** test
 if (compare_versions (OCTAVE_VERSION, "4.2", ">=") && !ispc ())
   assert (evalc ("infsup (ones(2, 2, 2))"), ...
    ["ans = 222 interval array\n", ...
     "\n", ...
     "ans(:,:,1) =\n", ...
     "\n", ...
     "   [1]   [1]\n", ...
     "   [1]   [1]\n", ...
     "\n", ...
     "ans(:,:,2) =\n", ...
     "\n", ...
     "   [1]   [1]\n", ...
     "   [1]   [1]\n", ...
     "\n"]);
 endif
warning: test: file /<<PKGBUILDDIR>>/inst/@infsup/display.m leaked global variables: current_print_indent_level
8 tests, 8 passed, 0 known failure, 0 skipped
[inst/@infsup/cancelplus.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/cancelplus.m
***** # from the documentation string
***** assert (cancelplus (infsup (2, 3), infsup (1, 1.5)) == infsup (3.5, 4));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.cancelPlus;
 for testcase = [testcases]'
   assert (isequaln (...
     cancelplus (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.cancelPlus;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (cancelplus (in1, in2), out));
***** test
 # Decorated scalar evaluation
 testcases = testdata.NoSignal.infsupdec.cancelPlus;
 for testcase = [testcases]'
   assert (isequaln (...
     cancelplus (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Decorated vector evaluation
 testcases = testdata.NoSignal.infsupdec.cancelPlus;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (cancelplus (in1, in2), out));
***** test
 # N-dimensional array vector evaluation
 testcases = testdata.NoSignal.infsupdec.cancelPlus;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (cancelplus (in1, in2), out));
6 tests, 6 passed, 0 known failure, 0 skipped
[inst/@infsup/smig.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/smig.m
***** assert (smig (infsup (-1, 2)), 0);
***** assert (smig (infsup (-42, -23)), -23);
***** assert (smig (infsup (23, 42)), 23);
3 tests, 3 passed, 0 known failure, 0 skipped
[inst/@infsup/realsqrt.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/realsqrt.m
***** # from the documentation string
***** assert (realsqrt (infsup (-6, 4)) == infsup (0, 2));
***** # correct use of signed zeros
***** test
 x = realsqrt (infsup (0));
 assert (signbit (inf (x)));
 assert (not (signbit (sup (x))));
***** test
 x = realsqrt (infsup (0, 2));
 assert (signbit (inf (x)));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.sqrt;
 for testcase = [testcases]'
   assert (isequaln (...
     realsqrt (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.sqrt;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (realsqrt (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.sqrt;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (realsqrt (in1), out));
6 tests, 6 passed, 0 known failure, 0 skipped
[inst/@infsup/gammaln.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/gammaln.m
***** assert (gammaln (infsup (-inf, inf)) == "[-0x1.F19B9BCC38A42p-4, +Inf]");
***** # from the documentation string
***** assert (gammaln (infsup (1.5)) == "[-0x1.EEB95B094C192p-4, -0x1.EEB95B094C191p-4]");
***** # correct use of signed zeros
***** test
 x = gammaln (infsup (1));
 assert (signbit (inf (x)));
 assert (not (signbit (sup (x))));
***** test
 x = gammaln (infsup (2));
 assert (signbit (inf (x)));
 assert (not (signbit (sup (x))));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsup/floor.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/floor.m
***** # Empty interval
***** assert (floor (infsup ()) == infsup ());
***** # Singleton intervals
***** assert (floor (infsup (0)) == infsup (0));
***** assert (floor (infsup (0.5)) == infsup (0));
***** assert (floor (infsup (-0.5)) == infsup (-1));
***** # Bounded intervals
***** assert (floor (infsup (-0.5, 0)) == infsup (-1, 0));
***** assert (floor (infsup (0, 0.5)) == infsup (0));
***** assert (floor (infsup (0.25, 0.5)) == infsup (0));
***** assert (floor (infsup (-1, 0)) == infsup (-1, 0));
***** assert (floor (infsup (-1, 1)) == infsup (-1, 1));
***** assert (floor (infsup (-realmin, realmin)) == infsup (-1, 0));
***** assert (floor (infsup (-realmax, realmax)) == infsup (-realmax, realmax));
***** # Unbounded intervals
***** assert (floor (infsup (-realmin, inf)) == infsup (-1, inf));
***** assert (floor (infsup (-realmax, inf)) == infsup (-realmax, inf));
***** assert (floor (infsup (-inf, realmin)) == infsup (-inf, 0));
***** assert (floor (infsup (-inf, realmax)) == infsup (-inf, realmax));
***** assert (floor (infsup (-inf, inf)) == infsup (-inf, inf));
***** # from the documentation string
***** assert (floor (infsup (2.5, 3.5)) == infsup (2, 3));
***** assert (floor (infsup (-0.5, 5)) == infsup (-1, 5));
***** # correct use of signed zeros
***** test
 x = floor (infsup (0.5));
 assert (signbit (inf (x)));
 assert (not (signbit (sup (x))));
***** test
 x = floor (infsup (0));
 assert (signbit (inf (x)));
 assert (not (signbit (sup (x))));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.floor;
 for testcase = [testcases]'
   assert (isequaln (...
     floor (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.floor;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (floor (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.floor;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (floor (in1), out));
23 tests, 23 passed, 0 known failure, 0 skipped
[inst/@infsup/expm.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/expm.m
***** # from the paper
***** test
 A = infsup ([0 1; 0 -3], [0 1; 0 -2]);
 assert (all (all (subset (infsup ([1, 0.316738; 0, 0.0497871], [1, 0.432332; 0, 0.135335]), expm (A)))));
1 test, 1 passed, 0 known failure, 0 skipped
[inst/@infsup/sinh.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/sinh.m
***** # from the documentation string
***** assert (sinh (infsup (1)) == "[0x1.2CD9FC44EB982, 0x1.2CD9FC44EB983]");
***** # correct use of signed zeros
***** test
 x = sinh (infsup (0));
 assert (signbit (inf (x)));
 assert (not (signbit (sup (x))));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.sinh;
 for testcase = [testcases]'
   assert (isequaln (...
     sinh (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.sinh;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (sinh (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.sinh;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (sinh (in1), out));
5 tests, 5 passed, 0 known failure, 0 skipped
[inst/@infsup/ge.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/ge.m
***** assert (ge (infsup (2, 3), infsup (1, 3)));
1 test, 1 passed, 0 known failure, 0 skipped
[inst/@infsup/rows.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/rows.m
***** assert (rows (infsup (zeros (3, 4))), 3);
1 test, 1 passed, 0 known failure, 0 skipped
[inst/@infsup/fsolve.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/fsolve.m
***** test
  sqr = @(x) x .^ 2;
  assert (subset (sqrt (infsup (2)), fsolve (sqr, infsup (0, 3), 2)));
***** test
  sqr = @(x) x .^ 2;
  assert (subset (sqrt (infsup (2)), fsolve (sqr, infsup (0, 3), 2, struct ("Vectorize", false))));
***** function [fval, x] = contractor (y, x)
  fval = x .^ 2;
  y = intersect (y, fval);
  x = sqrrev (y, x);
***** endfunction
***** assert (subset (sqrt (infsup (2)), fsolve (@contractor, infsup (0, 3), 2, struct ("Contract", true))));
***** assert (subset (sqrt (infsup (2)), fsolve (@contractor, infsup (0, 3), 2, struct ("Contract", true, "Vectorize", false))));
***** demo
 clf
 hold on
 grid on
 axis equal
 shade = [238 232 213] / 255;
 blue = [38 139 210] / 255;
 cyan = [42 161 152] / 255;
 red = [220 50 47] / 255;
 # 2D ring
 f = @(x, y) hypot (x, y);
 [outer, paving, inner] = fsolve (f, infsup ([-3; -3], [3; 3]), ...
                                  infsup (0.5, 2), ...
                                  optimset ('TolX', 0.1));
 # Plot the outer interval enclosure
 plot (outer(1), outer(2), shade)
 # Plot the guaranteed inner interval enclosures of the preimage
 plot (paving(1, inner), paving(2, inner), blue, cyan);
 # Plot the boundary of the preimage
 plot (paving(1, not (inner)), paving(2, not (inner)), red);
***** demo
 clf
 hold on
 grid on
 shade = [238 232 213] / 255;
 blue = [38 139 210] / 255;
 # This 3D ring is difficult to approximate with interval boxes
 f = @(x, y, z) hypot (hypot (x, y) - 2, z);
 [~, paving, inner] = fsolve (f, infsup ([-4; -4; -2], [4; 4; 2]), ...
                                 infsup (0, 0.5), ...
                                 optimset ('TolX', 0.2));
 plot3 (paving(1, not (inner)), ...
        paving(2, not (inner)), ...
        paving(3, not (inner)), shade, blue);
 view (50, 60)
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsup/idist.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/idist.m
***** # from the documentation string
***** assert (idist (infsup (0, 6), infsup (7, 20)), 1);
1 test, 1 passed, 0 known failure, 0 skipped
[inst/@infsup/reshape.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/reshape.m
***** assert (reshape (infsup (1 : 6), 2, 3) == infsup (reshape (1 : 6, 2, 3)));
***** assert (reshape (infsup (1 : 24), 2, [], 4) == infsup (reshape (1 : 24, 2, 3, 4)));
2 tests, 2 passed, 0 known failure, 0 skipped
[inst/@infsup/powrev1.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/powrev1.m
***** # from the documentation string
***** assert (powrev1 (infsup (2, 5), infsup (3, 6)) == "[0x1.3EE8390D43955, 0x1.3988E1409212Fp1]");
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.powRev1;
 for testcase = [testcases]'
   assert (isequaln (...
     powrev1 (testcase.in{1}, testcase.in{2}, testcase.in{3}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.powRev1;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 in3 = vertcat (vertcat (testcases.in){:, 3});
 out = vertcat (testcases.out);
 assert (isequaln (powrev1 (in1, in2, in3), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.powRev1;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 in3 = vertcat (vertcat (testcases.in){:, 3});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 in3 = reshape ([in3; in3(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (powrev1 (in1, in2, in3), out));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsup/log10.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/log10.m
***** # from the documentation string
***** assert (log10 (infsup (2)) == "[0x1.34413509F79FEp-2, 0x1.34413509F79FFp-2]");
***** # correct use of signed zeros
***** test
 x = log10 (infsup (1));
 assert (signbit (inf (x)));
 assert (not (signbit (sup (x))));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.log10;
 for testcase = [testcases]'
   assert (isequaln (...
     log10 (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.log10;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (log10 (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.log10;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (log10 (in1), out));
5 tests, 5 passed, 0 known failure, 0 skipped
[inst/@infsup/pown.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/pown.m
***** # from the documentation string
***** assert (pown (infsup (5, 6), 2) == infsup (25, 36));
***** assert (pown (infsup (-2, 1), 2) == infsup (0, 4));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.sqr;
 for testcase = [testcases]'
   assert (isequaln (...
     pown (testcase.in{1}, 2), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.sqr;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (pown (in1, 2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.sqr;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (pown (in1, 2), out));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.pown;
 for testcase = [testcases]'
   assert (isequaln (...
     pown (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.pown;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (pown (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.pown;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (pown (in1, in2), out));
8 tests, 8 passed, 0 known failure, 0 skipped
[inst/@infsup/le.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/le.m
***** assert (le (infsup (1, 3), infsup (3)));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.less;
 for testcase = [testcases]'
   assert (isequaln (...
     le (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.less;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (le (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.less;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (le (in1, in2), out));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsup/mag.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/mag.m
***** assert (mag (infsup (-3, 4)), 4);
***** assert (mag (infsup (-4, 3)), 4);
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.mag;
 for testcase = [testcases]'
   assert (isequaln (...
     mag (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.mag;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (mag (in1), out));
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.mag;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (mag (in1), out));
***** test
 # Decorated scalar evaluation
 testcases = testdata.NoSignal.infsupdec.mag;
 for testcase = [testcases]'
   assert (isequaln (...
     mag (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Decorated vector evaluation
 testcases = testdata.NoSignal.infsupdec.mag;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (mag (in1), out));
***** test
 # Decorated N-dimensional array evaluation
 testcases = testdata.NoSignal.infsupdec.mag;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (mag (in1), out));
7 tests, 7 passed, 0 known failure, 0 skipped
[inst/@infsup/isvector.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/isvector.m
***** assert (not (isvector (infsup ([]))));
***** assert (isvector (infsup (0)));
***** assert (isvector (infsup (zeros (1, 2))));
***** assert (isvector (infsup (zeros (2, 1))));
***** assert (not (isvector (infsup (zeros (5)))));
5 tests, 5 passed, 0 known failure, 0 skipped
[inst/@infsup/ei.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/ei.m
***** assert (isempty (ei (infsup (0))));
***** assert (isempty (ei (infsup (-inf, -2))));
***** assert (isentire (ei (infsup (0, inf))));
***** # from the documentation string
***** assert (ei (infsup (1)) == "[0x1.E52670F350D08, 0x1.E52670F350D09]");
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsup/uminus.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/uminus.m
***** # from the documentation string
***** assert (-infsup (2, 3) == infsup (-3, -2));
***** # correct use of signed zeros
***** test
 x = uminus (infsup (0));
 assert (signbit (inf (x)));
 assert (not (signbit (sup (x))));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.neg;
 for testcase = [testcases]'
   assert (isequaln (...
     uminus (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.neg;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (uminus (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.neg;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (uminus (in1), out));
5 tests, 5 passed, 0 known failure, 0 skipped
[inst/@infsup/cancelminus.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/cancelminus.m
***** # from the documentation string
***** assert (cancelminus (infsup (2, 3), infsup (1, 1.5)) == infsup (1, 1.5));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.cancelMinus;
 for testcase = [testcases]'
   assert (isequaln (...
     cancelminus (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.cancelMinus;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (cancelminus (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.cancelMinus;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (cancelminus (in1, in2), out));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsup/columns.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/columns.m
***** assert (columns (infsup (zeros (3, 4))), 4);
***** assert (columns (infsup (zeros (0, 4))), 4);
***** assert (columns (infsup (zeros (3, 0))), 0);
***** assert (columns (infsup (zeros (3, 1))), 1);
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsup/vertcat.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/vertcat.m
***** assert (vertcat (infsup (1), infsup (2)) == infsup (vertcat (1, 2)));
***** test
 # from the documentation string
 a = infsup (2, 5);
 assert (vertcat (a, a, a) == infsup ([2; 2; 2], [5; 5; 5]));
2 tests, 2 passed, 0 known failure, 0 skipped
[inst/@infsup/fma.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/fma.m
***** # from the documentation string
***** assert (fma (infsup (1+eps), infsup (7), infsup ("0.1")) == "[0x1.C666666666668p2, 0x1.C666666666669p2]");
***** # correct use of signed zeros
***** test
 x = fma (infsup (0), 0, 0);
 assert (signbit (inf (x)));
 assert (not (signbit (sup (x))));
***** test
 x = fma (infsup (1), 0, 0);
 assert (signbit (inf (x)));
 assert (not (signbit (sup (x))));
***** test
 x = fma (infsup (1), 1, -1);
 assert (signbit (inf (x)));
 assert (not (signbit (sup (x))));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.fma;
 for testcase = [testcases]'
   assert (isequaln (...
     fma (testcase.in{1}, testcase.in{2}, testcase.in{3}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.fma;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 in3 = vertcat (vertcat (testcases.in){:, 3});
 out = vertcat (testcases.out);
 assert (isequaln (fma (in1, in2, in3), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.fma;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 in3 = vertcat (vertcat (testcases.in){:, 3});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 in3 = reshape ([in3; in3(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (fma (in1, in2, in3), out));
7 tests, 7 passed, 0 known failure, 0 skipped
[inst/@infsup/atan2rev2.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/atan2rev2.m
***** # from the documentation string
***** assert (atan2rev2 (infsup (1, 2), infsup ("pi") / 4) == "[0x1.FFFFFFFFFFFFEp-1, 0x1.0000000000001p1]");
1 test, 1 passed, 0 known failure, 0 skipped
[inst/@infsup/det.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/det.m
***** # from the documentation string
***** assert (det (infsup (magic (3))) == -360);
1 test, 1 passed, 0 known failure, 0 skipped
[inst/@infsup/max.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/max.m
***** # from the documentation string
***** assert (max (infsup (2, 3), infsup (1, 2)) == infsup (2, 3));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.max;
 for testcase = [testcases]'
   assert (isequaln (...
     max (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.max;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (max (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.max;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (max (in1, in2), out));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsup/sumsq.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/sumsq.m
***** # from the documentation string
***** assert (sumsq ([infsup(1), pow2(-1074), -1]) == infsup (2, 2+eps*2));
***** assert (sumsq (infsup ([])) == 0);
***** # correct use of signed zeros
***** test
 x = sumsq (infsup (0));
 assert (signbit (inf (x)));
 assert (not (signbit (sup (x))));
3 tests, 3 passed, 0 known failure, 0 skipped
[inst/@infsup/abs.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/abs.m
***** # Empty interval
***** assert (abs (infsup ()) == infsup ());
***** # Singleton intervals
***** assert (abs (infsup (1)) == infsup (1));
***** assert (abs (infsup (0)) == infsup (0));
***** assert (abs (infsup (-1)) == infsup (1));
***** assert (abs (infsup (realmax)) == infsup (realmax));
***** assert (abs (infsup (realmin)) == infsup (realmin));
***** assert (abs (infsup (-realmin)) == infsup (realmin));
***** assert (abs (infsup (-realmax)) == infsup (realmax));
***** # Bounded intervals
***** assert (abs (infsup (1, 2)) == infsup (1, 2));
***** assert (abs (infsup (0, 1)) == infsup (0, 1));
***** assert (abs (infsup (-1, 1)) == infsup (0, 1));
***** assert (abs (infsup (-1, 0)) == infsup (0, 1));
***** assert (abs (infsup (-2, -1)) == infsup (1, 2));
***** # Unbounded intervals
***** assert (abs (infsup (0, inf)) == infsup (0, inf));
***** assert (abs (infsup (-inf, inf)) == infsup (0, inf));
***** assert (abs (infsup (-inf, 0)) == infsup (0, inf));
***** assert (abs (infsup (1, inf)) == infsup (1, inf));
***** assert (abs (infsup (-1, inf)) == infsup (0, inf));
***** assert (abs (infsup (-inf, -1)) == infsup (1, inf));
***** assert (abs (infsup (-inf, 1)) == infsup (0, inf));
***** # from the documentation string
***** assert (abs (infsup (2.5, 3.5)) == infsup (2.5, 3.5));
***** assert (abs (infsup (-0.5, 5.5)) == infsup (0, 5.5));
***** # correct use of signed zeros
***** assert (signbit (inf (abs (infsup (-1, 0)))));
***** test
 x = abs (infsup (0));
 assert (signbit (inf (x)));
 assert (not (signbit (sup (x))));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.abs;
 for testcase = [testcases]'
   assert (isequaln (...
     abs (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.abs;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (abs (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.abs;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (abs (in1), out));
27 tests, 27 passed, 0 known failure, 0 skipped
[inst/@infsup/csch.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/csch.m
***** # from the documentation string
***** assert (csch (infsup (1)) == "[0x1.B3AB8A78B90Cp-1, 0x1.B3AB8A78B90C1p-1]");
***** # correct use of signed zeros
***** test
 x = csch (infsup (0, inf));
 assert (signbit (inf (x)));
 assert (not (signbit (sup (x))));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.csch;
 for testcase = [testcases]'
   assert (isequaln (...
     csch (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.csch;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (csch (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.csch;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (csch (in1), out));
5 tests, 5 passed, 0 known failure, 0 skipped
[inst/@infsup/hypot.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/hypot.m
***** # from the documentation string
***** assert (hypot (infsup (2, 3), infsup (1, 2)) == "[0x1.1E3779B97F4A7p1, 0x1.CD82B446159F4p1]");
***** # correct use of signed zeros
***** test
 x = hypot (infsup (0), infsup (0));
 assert (signbit (inf (x)));
 assert (not (signbit (sup (x))));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.hypot;
 for testcase = [testcases]'
   assert (isequaln (...
     hypot (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.hypot;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (hypot (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.hypot;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (hypot (in1, in2), out));
5 tests, 5 passed, 0 known failure, 0 skipped
[inst/@infsup/mod.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/mod.m
***** assert (mod (infsup (), infsup ()) == infsup ());
***** assert (mod (infsup (0), infsup ()) == infsup ());
***** assert (mod (infsup (), infsup (0)) == infsup ());
***** assert (mod (infsup (0), infsup (0)) == infsup ());
***** assert (mod (infsup (1), infsup (0)) == infsup ());
***** assert (mod (infsup (0, 1), infsup (0)) == infsup ());
***** assert (mod (infsup (1, 2), infsup (0)) == infsup ());
***** assert (mod (infsup (0, inf), infsup (0)) == infsup ());
***** assert (mod (infsup (1, inf), infsup (0)) == infsup ());
***** assert (mod (infsup (realmax, inf), infsup (0)) == infsup ());
***** assert (mod (infsup (0), infsup (1)) == infsup (0));
***** assert (mod (infsup (0), infsup (0, 1)) == infsup (0));
***** assert (mod (infsup (0), infsup (1, 2)) == infsup (0));
***** assert (mod (infsup (0), infsup (0, inf)) == infsup (0));
***** assert (mod (infsup (0), infsup (1, inf)) == infsup (0));
***** assert (mod (infsup (0), infsup (realmax, inf)) == infsup (0));
***** assert (mod (infsup (1), infsup (1)) == infsup (0));
***** assert (mod (infsup (2), infsup (1)) == infsup (0));
***** assert (mod (infsup (4), infsup (2)) == infsup (0));
***** assert (mod (infsup (6), infsup (3)) == infsup (0));
***** assert (mod (infsup (8), infsup (2)) == infsup (0));
***** assert (mod (infsup (9), infsup (3)) == infsup (0));
***** assert (mod (infsup (realmax), infsup (realmax)) == infsup (0));
***** assert (mod (infsup (realmax), infsup (realmax / 2)) == infsup (0));
***** assert (mod (infsup (realmax), infsup (realmax / 4)) == infsup (0));
***** assert (mod (infsup (realmax), infsup (realmax / 8)) == infsup (0));
***** assert (mod (infsup (realmax), infsup (realmax / 16)) == infsup (0));
***** assert (mod (infsup (realmax), infsup (realmax / 32)) == infsup (0));
***** assert (mod (infsup (0.1), infsup (0.1)) == infsup (0));
***** assert (mod (infsup (0.1 * 2), infsup (0.1)) == infsup (0));
***** assert (mod (infsup (0.1 * 4), infsup (0.1)) == infsup (0));
***** assert (mod (infsup (pi), infsup (pi)) == infsup (0));
***** assert (mod (infsup (pi), infsup (pi / 2)) == infsup (0));
***** assert (mod (infsup (pi), infsup (pi / 4)) == infsup (0));
***** assert (mod (infsup (pow2 (-1074)), infsup (pow2 (-1074))) == infsup (0));
***** assert (mod (infsup (pow2 (-1073)), infsup (pow2 (-1074))) == infsup (0));
***** assert (mod (infsup (pow2 (-1072)), infsup (pow2 (-1074))) == infsup (0));
***** assert (mod (infsup (1), infsup (2)) == infsup (1));
***** assert (mod (infsup (0.5), infsup (1)) == infsup (0.5));
***** assert (mod (infsup (pi), infsup (3.15)) == infsup (pi));
***** assert (mod (infsup (1), infsup (2, 3)) == infsup (1));
***** assert (mod (infsup (1), infsup (2, inf)) == infsup (1));
***** assert (mod (infsup (0.5), infsup (1, 2)) == infsup (0.5));
***** assert (mod (infsup (0.5), infsup (1, inf)) == infsup (0.5));
***** assert (mod (infsup (pi), infsup (3.15)) == infsup (pi));
***** assert (mod (infsup (pi), infsup (3.15, inf)) == infsup (pi));
***** assert (mod (infsup (0, 1), infsup (0, 1)) == infsup (0, 1));
***** assert (mod (infsup (0, 2), infsup (0, 1)) == infsup (0, 1));
***** assert (mod (infsup (0, 1), infsup (0, 2)) == infsup (0, 1));
***** assert (mod (infsup (0, realmax), infsup (0, realmax)) == infsup (0, realmax));
***** assert (mod (infsup (realmax, inf), infsup (realmax, inf)) == infsup (0, inf));
***** assert (mod (infsup (0, inf), infsup (0, inf)) == infsup (0, inf));
***** assert (mod (infsup (0), infsup (1)) == infsup (0));
***** assert (mod (infsup (1), infsup (1)) == infsup (0));
***** assert (mod (infsup (0, 1), infsup (1)) == infsup (0, 1));
***** assert (mod (infsup (1, 2), infsup (1)) == infsup (0, 1));
***** assert (mod (infsup (0, inf), infsup (1)) == infsup (0, 1));
***** assert (mod (infsup (1, inf), infsup (1)) == infsup (0, 1));
***** assert (mod (infsup (realmax, inf), infsup (1)) == infsup (0, 1));
***** assert (mod (infsup (1), infsup (1)) == infsup (0));
***** assert (mod (infsup (1), infsup (0, 1)) == infsup (0, 0.5));
***** assert (mod (infsup (1), infsup (1, 2)) == infsup (0, 1));
***** assert (mod (infsup (1), infsup (0, inf)) == infsup (0, 1));
***** assert (mod (infsup (1), infsup (1, inf)) == infsup (0, 1));
***** assert (mod (infsup (1), infsup (2, inf)) == infsup (1));
***** assert (mod (infsup (1), infsup (realmax, inf)) == infsup (1));
66 tests, 66 passed, 0 known failure, 0 skipped
[inst/@infsup/inv.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/inv.m
***** # from the wiki
***** test
  A = infsup ([1, 2, 3; 4, 0, 0; 0, 0, 1]);
  A (2, 3) = "[0, 6]";
  B = inv (A);
  assert (inf (B) == [0, .25, -1.5; .5, -.125, -1.5; 0, 0, 1]);
  assert (sup (B) == [0, .25,    0; .5, -.125, -.75; 0, 0, 1]);
***** # from the documentation string
***** assert (inv (infsup ([2, 1, 1; 0, 1, 0; 1, 0, 0])) == [0, 0, 1; 0, 1, 0; 1, -1, -2]);
***** assert (inv (infsup ([1, 2, 3; 4, 0, 6; 0, 0, 1])) == [0, .25, -1.5; .5, -.125, -.75; 0, 0, 1]);
3 tests, 3 passed, 0 known failure, 0 skipped
[inst/@infsup/atan2.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/atan2.m
***** test "from the documentation string";
***** assert (atan2 (infsup (1), infsup (-1)) == "[0x1.2D97C7F3321D2p1, 0x1.2D97C7F3321D3p1]");
***** # correct use of signed zeros
***** test
 x = atan2 (0, infsup (1));
 assert (signbit (inf (x)));
 assert (not (signbit (sup (x))));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.atan2;
 for testcase = [testcases]'
   assert (isequaln (...
     atan2 (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.atan2;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (atan2 (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.atan2;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (atan2 (in1, in2), out));
6 tests, 6 passed, 0 known failure, 0 skipped
[inst/@infsup/fminsearch.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/fminsearch.m
***** test
  sqr = @(x) x .^ 2;
  [x, y] = fminsearch (sqr, infsup (-inf, inf));
  assert (y == 0);
***** demo
  clf
  hold on
  draw = @(x) plot (x(1), x(2), [238 232 213]/255, [88 110 117]/255);
  f = @(x) (x(1) - 2) .^ 2 - x(2) .^ 2;
  fminsearch (f, infsup ("[1, 3] [0, 1]"), ...
              optimset ('OutputFcn', draw));
  hold off
1 test, 1 passed, 0 known failure, 0 skipped
[inst/@infsup/plot3.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/plot3.m
***** # this test is rather pointless
***** test
  clf
  plot3 (empty (), empty (), empty ());
  close
***** demo
  clf
  colormap hot
  x = y = z = (1 : 3) + infsup ("[0, 1]");
  plot3 (x, y, z);
  grid on
***** demo
  clf
  colormap jet
  z = 1 : 8;
  x = y = infsup ("[-1, 1]") ./ z;
  plot3 (x, y, z);
  grid on
***** demo
  clf
  [x, y] = meshgrid (mince (infsup ("[-5, 5]"), 20), ...
                     mince (infsup ("[0.1, 5]"), 10));
  z = log (hypot (x, y));
  blue = [38 139 210]/255; base2 = [238 232 213]/255;
  plot3 (x, y, z, base2, blue);
  view (330, 12)
***** demo
  clf
  [x, y] = meshgrid (midrad (-10 : 0.5 : 10, .25));
  z = sin (hypot (x, y)) .* hypot (x, y);
  plot3 (mid (x), mid (y), z);
  grid on
1 test, 1 passed, 0 known failure, 0 skipped
[inst/@infsup/inf.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/inf.m
***** # from the documentation string
***** assert (inf (infsup (2.5, 3.5)), 2.5);
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.inf;
 for testcase = [testcases]'
   assert (isequaln (...
     inf (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.inf;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (inf (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.inf;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (inf (in1), out));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsup/acosh.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/acosh.m
***** # Empty interval
***** assert (acosh (infsup ()) == infsup ());
***** # Singleton intervals
***** assert (acosh (infsup (0)) == infsup ());
***** assert (acosh (infsup (1)) == infsup (0));
***** test
 x = infsup (1 : 3 : 100);
 assert (min (subset (acosh (x), log (x + sqrt (x + 1) .* sqrt (x - 1)))));
***** # Bounded intervals
***** assert (acosh (infsup (0, 1)) == infsup (0));
***** # Unbounded intervals
***** assert (acosh (infsup (-inf, 0)) == infsup ());
***** assert (acosh (infsup (-inf, 1)) == infsup (0));
***** assert (acosh (infsup (0, inf)) == infsup (0, inf));
***** assert (acosh (infsup (1, inf)) == infsup (0, inf));
***** assert (subset (acosh (infsup (2, inf)), infsup (1, inf)));
***** # from the documentation string
***** assert (acosh (infsup (2)) == "[0x1.5124271980434, 0x1.5124271980435]");
***** # correct use of signed zeros
***** test
 x = acosh (infsup (1));
 assert (signbit (inf (x)));
 assert (not (signbit (sup (x))));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.acosh;
 for testcase = [testcases]'
   assert (isequaln (...
     acosh (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.acosh;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (acosh (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.acosh;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (acosh (in1), out));
15 tests, 15 passed, 0 known failure, 0 skipped
[inst/@infsup/size.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/size.m
***** assert (size (infsup (zeros (3, 4))), [3 4]);
***** assert (size (infsup (zeros (2, 3, 4))), [2, 3, 4]);
***** test
 [x y z] = size (infsup (magic (3)));
 assert (x, 3);
 assert (y, 3);
 assert (z, 1);
3 tests, 3 passed, 0 known failure, 0 skipped
[inst/@infsup/erf.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/erf.m
***** # from the documentation string
***** assert (erf (infsup (1)) == "[0x1.AF767A741088Ap-1, 0x1.AF767A741088Bp-1]");
***** # correct use of signed zeros
***** test
 x = erf (infsup (0));
 assert (signbit (inf (x)));
 assert (not (signbit (sup (x))));
2 tests, 2 passed, 0 known failure, 0 skipped
[inst/@infsup/isempty.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/isempty.m
***** assert (isempty (infsup ()));
***** assert (not (isempty (infsup (1, 2))));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.isEmpty;
 for testcase = [testcases]'
   assert (isequaln (...
     isempty (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.isEmpty;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (isempty (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.isEmpty;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (isempty (in1), out));
5 tests, 5 passed, 0 known failure, 0 skipped
[inst/@infsup/printf.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/printf.m
***** test
 if (compare_versions (OCTAVE_VERSION, "4.2", ">="))
   assert (evalc ("n = printf ('%g', infsup ('pi'));"), "3.14159 3.1416");
   assert (n, 14);
 endif
1 test, 1 passed, 0 known failure, 0 skipped
[inst/@infsup/bisect.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/bisect.m
***** test
 # from the documentation string
 [a, b] = bisect (infsup (2, 32));
 assert (a == infsup (2, 8));
 assert (b == infsup (8, 32));
***** test
 [a, b] = bisect (infsup (-inf, inf));
 assert (a == infsup (-inf, 0));
 assert (b == infsup (0, inf));
***** test
 [a, b] = bisect (infsup (0));
 assert (a == 0);
 assert (b == 0);
***** test
 [a, b] = bisect (infsup ());
 assert (isempty (a));
 assert (isempty (b));
***** test
 [a, b] = bisect (infsup (0, inf));
 assert (a == infsup (0, pow2 (-25)));
 assert (b == infsup (pow2 (-25), inf));
***** test
 [a, b] = bisect (infsup (-inf, 0));
 assert (a == infsup (-inf, -pow2 (-25)));
 assert (b == infsup (-pow2 (-25), 0));
***** # correct use of signed zeros
***** test
 [a, b] = bisect (infsup (0));
 assert (signbit (inf (a)));
 assert (signbit (inf (b)));
 assert (not (signbit (sup (a))));
 assert (not (signbit (sup (b))));
7 tests, 7 passed, 0 known failure, 0 skipped
[inst/@infsup/lt.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/lt.m
***** assert (not (lt (infsup (1, 3), infsup (3))));
***** assert (lt (infsup (1, 3), infsup (3.1)));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.strictLess;
 for testcase = [testcases]'
   assert (isequaln (...
     lt (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.strictLess;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (lt (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.strictLess;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (lt (in1, in2), out));
5 tests, 5 passed, 0 known failure, 0 skipped
[inst/@infsup/cat.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/cat.m
***** assert (size (cat (1, infsup ([]), infsup ([]))), [0 0]);
***** assert (cat (1, infsup (1), infsup (2)) == infsup (cat (1, 1, 2)));
***** assert (cat (2, infsup (1), infsup (2)) == infsup (cat (2, 1, 2)));
***** assert (cat (5, infsup (1), infsup (2)) == infsup (cat (5, 1, 2)));
***** assert (cat (1, infsup (zeros (2, 2, 2)), infsup (ones (2, 2, 2))) == infsup (cat (1, zeros (2, 2, 2), ones (2, 2, 2))));
5 tests, 5 passed, 0 known failure, 0 skipped
[inst/@infsup/disp.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/disp.m
***** assert (disp (infsup([])), "");
***** assert (disp (infsup(zeros (0, 1))), "");
***** assert (disp (infsup(zeros (1, 0))), "");
***** assert (disp (infsup(0)), "[0]\n");
***** assert (disp (infsup(0, 1)), "[0, 1]\n");
***** assert (disp (infsup([0 0])), "   [0]   [0]\n");
***** assert (disp (infsup([0 0; 0 0])), "   [0]   [0]\n   [0]   [0]\n");
***** assert (disp (infsup([0; 0])), "   [0]\n   [0]\n");
***** assert (disp (infsup (zeros (1, 1, 1, 0))), "");
***** assert (disp (infsup(zeros(2, 2, 2))), "ans(:,:,1) =\n\n   [0]   [0]\n   [0]   [0]\n\nans(:,:,2) =\n\n   [0]   [0]\n   [0]   [0]\n")
***** test
 i = infsupdec (reshape (1:24, 2, 3, 4));
 i(1, 1, 2) = entire ();
 i(1, 1, 3) = empty ();
 i(1, 1, 4) = nai ();
 assert (disp (i(1,1,:)), "ans(:,:,1) =   [1]_com\nans(:,:,2) =   [Entire]_dac\nans(:,:,3) =   [Empty]_trv\nans(:,:,4) =   [NaI]\n")
***** test
 x = infsup (zeros ([1 2 2]));
 unwind_protect
   format compact
   compact = disp (x);
   format loose
   loose = disp (x);
 unwind_protect_cleanup
   format
 end_unwind_protect
 assert (compact, "ans(:,:,1) =\n   [0]   [0]\nans(:,:,2) =\n   [0]   [0]\n");
 assert (loose, "ans(:,:,1) =\n\n   [0]   [0]\n\nans(:,:,2) =\n\n   [0]   [0]\n");
***** test
 x = infsup (zeros ([1 1 2]));
 unwind_protect
   format compact
   compact = disp (x);
   format loose
   loose = disp (x);
 unwind_protect_cleanup
   format
 end_unwind_protect
 assert (compact, "ans(:,:,1) =   [0]\nans(:,:,2) =   [0]\n");
 assert (loose,   "ans(:,:,1) =   [0]\nans(:,:,2) =   [0]\n");
13 tests, 13 passed, 0 known failure, 0 skipped
[inst/@infsup/ctranspose.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/ctranspose.m
***** assert (ctranspose (infsup (magic (3))) == infsup (magic (3)'));
1 test, 1 passed, 0 known failure, 0 skipped
[inst/@infsup/fix.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/fix.m
***** # Empty interval
***** assert (fix (infsup ()) == infsup ());
***** # Singleton intervals
***** assert (fix (infsup (0)) == infsup (0));
***** assert (fix (infsup (1)) == infsup (1));
***** assert (fix (infsup (1+eps)) == infsup (1));
***** assert (fix (infsup (-1)) == infsup (-1));
***** assert (fix (infsup (0.5)) == infsup (0));
***** assert (fix (infsup (-0.5)) == infsup (0));
***** # Bounded intervals
***** assert (fix (infsup (-0.5, 0)) == infsup (0));
***** assert (fix (infsup (0, 0.5)) == infsup (0));
***** assert (fix (infsup (0.25, 0.5)) == infsup (0));
***** assert (fix (infsup (-1, 0)) == infsup (-1, 0));
***** assert (fix (infsup (-1, 1)) == infsup (-1, 1));
***** assert (fix (infsup (-realmin, realmin)) == infsup (0));
***** assert (fix (infsup (-realmax, realmax)) == infsup (-realmax, realmax));
***** # Unbounded intervals
***** assert (fix (infsup (-realmin, inf)) == infsup (0, inf));
***** assert (fix (infsup (-realmax, inf)) == infsup (-realmax, inf));
***** assert (fix (infsup (-inf, realmin)) == infsup (-inf, 0));
***** assert (fix (infsup (-inf, realmax)) == infsup (-inf, realmax));
***** assert (fix (infsup (-inf, inf)) == infsup (-inf, inf));
***** # from the documentation string
***** assert (fix (infsup (2.5, 3.5)) == infsup (2, 3));
***** assert (fix (infsup (-0.5, 5)) == infsup (0, 5));
***** # correct use of signed zeros
***** test
 x = fix (infsup (0.5));
 assert (signbit (inf (x)));
 assert (not (signbit (sup (x))));
***** test
 x = fix (infsup (-0.5));
 assert (signbit (inf (x)));
 assert (not (signbit (sup (x))));
***** test
 x = fix (infsup (0));
 assert (signbit (inf (x)));
 assert (not (signbit (sup (x))));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.trunc;
 for testcase = [testcases]'
   assert (isequaln (...
     fix (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.trunc;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (fix (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.trunc;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (fix (in1), out));
27 tests, 27 passed, 0 known failure, 0 skipped
[inst/@infsup/transpose.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/transpose.m
***** assert (transpose (infsup (magic (3))) == infsup (magic (3).'));
***** # from the documentation string
***** assert (transpose (infsup (zeros (1, 3), ones (1, 3))) == infsup (zeros (3, 1), ones (3, 1)));
2 tests, 2 passed, 0 known failure, 0 skipped
[inst/@infsup/triu.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/triu.m
***** assert (triu (infsup (magic (10))) == triu (magic (10)));
***** assert (triu (infsup (magic (10)), 1) == triu (magic (10), 1));
***** assert (triu (infsup (magic (10)), -1) == triu (magic (10), -1));
***** assert (triu (infsup (magic (10)), 0, "pack") == triu (magic (10), 0, "pack"));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsup/sum.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/sum.m
***** # from the documentation string
***** assert (sum ([infsup(1), pow2(-1074), -1]) == infsup (pow2 (-1074)));
***** assert (sum (infsup ([])) == 0);
***** # correct use of signed zeros
***** test
 x = sum (infsup (0));
 assert (signbit (inf (x)));
 assert (not (signbit (sup (x))));
***** # N-dimensional arrays
***** assert (sum (infsup (ones (1, 1, 10))) == infsup (10));
***** assert (sum (infsup (ones (1, 1, 10))) == infsup (10));
5 tests, 5 passed, 0 known failure, 0 skipped
[inst/@infsup/postpad.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/postpad.m
***** assert (postpad (infsup (1:3), 4, 4) == infsup (1:4));
***** assert (postpad (infsup (1:3), 2, 4) == infsup (1:2));
***** test
 if (compare_versions (OCTAVE_VERSION (), "4.0.0", ">="))
   assert (postpad (infsup (0), 10, 0, 3) == infsup (zeros (1, 1, 10)))
 else
   # In Octave 3.8.x it is not possible to increase the number of dimensions.
 endif
***** assert (postpad (infsup (zeros (1, 2, 2)), 3) == infsup (zeros (1, 3, 2)));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsup/overlap.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/overlap.m
***** test
 [s, n] = overlap (infsup (), infsup ());
 assert (s, "bothEmpty");
 assert (n, uint16 (32768));
***** test
 [s, n] = overlap (infsup (), infsup (0));
 assert (s, "firstEmpty");
 assert (n, uint16 (16384));
***** test
 [s, n] = overlap (infsup (0), infsup ());
 assert (s, "secondEmpty");
 assert (n, uint16 (8192));
***** test
 [s, n] = overlap (infsup (1, 2), infsup (3, 4));
 assert (s, "before");
 assert (n, uint16 (4096));
***** test
 [s, n] = overlap (infsup (1, 2), infsup (2, 3));
 assert (s, "meets");
 assert (n, uint16 (2048));
***** test
 [s, n] = overlap (infsup (1, 3), infsup (2, 4));
 assert (s, "overlaps");
 assert (n, uint16 (1024));
***** test
 [s, n] = overlap (infsup (1, 2), infsup (1, 3));
 assert (s, "starts");
 assert (n, uint16 (512));
***** test
 [s, n] = overlap (infsup (2, 3), infsup (1, 4));
 assert (s, "containedBy");
 assert (n, uint16 (256));
***** test
 [s, n] = overlap (infsup (2, 3), infsup (1, 3));
 assert (s, "finishes");
 assert (n, uint16 (128));
***** test
 [s, n] = overlap (infsup (1, 2), infsup (1, 2));
 assert (s, "equals");
 assert (n, uint16 (64));
***** test
 [s, n] = overlap (infsup (1, 3), infsup (2, 3));
 assert (s, "finishedBy");
 assert (n, uint16 (32));
***** test
 [s, n] = overlap (infsup (1, 4), infsup (2, 3));
 assert (s, "contains");
 assert (n, uint16 (16));
***** test
 [s, n] = overlap (infsup (1, 3), infsup (1, 2));
 assert (s, "startedBy");
 assert (n, uint16 (8));
***** test
 [s, n] = overlap (infsup (2, 4), infsup (1, 3));
 assert (s, "overlappedBy");
 assert (n, uint16 (4));
***** test
 [s, n] = overlap (infsup (2, 3), infsup (1, 2));
 assert (s, "metBy");
 assert (n, uint16 (2));
***** test
 [s, n] = overlap (infsup (3, 4), infsup (1, 2));
 assert (s, "after");
 assert (n, uint16 (1));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.overlap;
 for testcase = [testcases]'
   assert (isequaln (...
     overlap (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.overlap;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = {testcases.out}';
 assert (isequaln (overlap (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.overlap;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = {testcases.out}';
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (overlap (in1, in2), out));
19 tests, 19 passed, 0 known failure, 0 skipped
[inst/@infsup/sin.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/sin.m
***** # from the documentation string
***** assert (sin (infsup (1)) == "[0x1.AED548F090CEEp-1, 0x1.AED548F090CEFp-1]");
***** # correct use of signed zeros
***** test
 x = sin (infsup (0));
 assert (signbit (inf (x)));
 assert (not (signbit (sup (x))));
***** # test fix for bug #51283
***** test
 x = sin (infsup ([0, 0]));
 assert (signbit (inf (x)));
 assert (not (signbit (sup (x))));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.sin;
 for testcase = [testcases]'
   assert (isequaln (...
     sin (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.sin;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (sin (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.sin;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (sin (in1), out));
6 tests, 6 passed, 0 known failure, 0 skipped
[inst/@infsup/mldivide.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/mldivide.m
***** # unique solution
***** assert (infsup ([1, 0; 0, 2]) \ [2, 0; 0, 4] == [2, 0; 0 2]);
***** # no solution
***** assert (all (isempty (infsup ([1, 0; 2, 0]) \ [3; 0])));
***** # many solutions
***** assert (infsup ([1, 0; 2, 0]) \ [4; 8] == infsup ([4; -inf], [4; inf]));
***** assert (all (subset (infsup ([2, -1; -1, 2], [4, 1; 1, 4]) \ infsup ([-3; .8], [3; .8]), infsup ([-2.3; -1.1], [2.3; 1.6]))));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsup/mrdivide.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/mrdivide.m
***** # from the documentation string
***** assert (infsup ([1, 2; 3, 4]) / [3, 4; 1, 2] == infsup ([0, 1; 1, 0]));
1 test, 1 passed, 0 known failure, 0 skipped
[inst/@infsup/infsup.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/infsup.m
***** # Empty intervals
***** test
 x = infsup ();
 assert (inf (x), +inf);
 assert (sup (x), -inf);
***** test
 x = infsup ("[]");
 assert (inf (x), +inf);
 assert (sup (x), -inf);
***** test
 x = infsup ("[ ]");
 assert (inf (x), +inf);
 assert (sup (x), -inf);
***** test
 x = infsup ("[\t]");
 assert (inf (x), +inf);
 assert (sup (x), -inf);
***** test
 x = infsup ("[empty]");
 assert (inf (x), +inf);
 assert (sup (x), -inf);
***** test
 x = infsup ("[EMPTY]");
 assert (inf (x), +inf);
 assert (sup (x), -inf);
***** test
 x = infsup ("[ empty ]");
 assert (inf (x), +inf);
 assert (sup (x), -inf);
***** test
 x = infsup ("\t[\t Empty\t]\t");
 assert (inf (x), +inf);
 assert (sup (x), -inf);
***** # Entire interval
***** test
 x = infsup ("[,]");
 assert (inf (x), -inf);
 assert (sup (x), +inf);
***** test
 x = infsup ("[entire]");
 assert (inf (x), -inf);
 assert (sup (x), +inf);
***** test
 x = infsup ("[ENTIRE]");
 assert (inf (x), -inf);
 assert (sup (x), +inf);
***** test
 x = infsup ("[ entire ]");
 assert (inf (x), -inf);
 assert (sup (x), +inf);
***** test
 x = infsup (" [Entire \t] ");
 assert (inf (x), -inf);
 assert (sup (x), +inf);
***** test
 x = infsup ("[-inf,+inf]");
 assert (inf (x), -inf);
 assert (sup (x), +inf);
***** test
 x = infsup ("[-infinity, +infinity]");
 assert (inf (x), -inf);
 assert (sup (x), +inf);
***** test
 x = infsup ("[-INF, +INFinitY]");
 assert (inf (x), -inf);
 assert (sup (x), +inf);
***** # double boundaries
***** test
 x = infsup (0);
 assert (inf (x), 0);
 assert (sup (x), 0);
 assert (signbit (inf (x)));
 assert (not (signbit (sup (x))));
***** test
 x = infsup (2, 3);
 assert (inf (x), 2);
 assert (sup (x), 3);
***** test
 x = infsup (-inf, 0.1);
 assert (inf (x), -inf);
 assert (sup (x), 0.1);
***** test
 x = infsup (-inf, +inf);
 assert (inf (x), -inf);
 assert (sup (x), +inf);
***** # NaN values
***** warning id=interval:UndefinedOperation
 x = infsup (nan);
 assert (inf (x), +inf);
 assert (sup (x), -inf);
***** warning id=interval:UndefinedOperation
 x = infsup (nan, 2);
 assert (inf (x), +inf);
 assert (sup (x), -inf);
***** warning id=interval:UndefinedOperation
 x = infsup (3, nan);
 assert (inf (x), +inf);
 assert (sup (x), -inf);
***** # illegal numeric boundaries
***** warning id=interval:UndefinedOperation
 x = infsup (+inf, -inf);
 assert (inf (x), +inf);
 assert (sup (x), -inf);
***** warning id=interval:UndefinedOperation
 x = infsup (+inf, +inf);
 assert (inf (x), +inf);
 assert (sup (x), -inf);
***** warning id=interval:UndefinedOperation
 x = infsup (-inf, -inf);
 assert (inf (x), +inf);
 assert (sup (x), -inf);
***** warning id=interval:UndefinedOperation
 x = infsup (3, 2);
 assert (inf (x), +inf);
 assert (sup (x), -inf);
***** warning id=interval:UndefinedOperation
 x = infsup (3, -inf);
 assert (inf (x), +inf);
 assert (sup (x), -inf);
***** # double matrix
***** test
 x = infsup (magic (4));
 assert (inf (x), magic (4));
 assert (sup (x), magic (4));
***** test
 x = infsup (magic (3), magic (3) + 1);
 assert (inf (x), magic (3));
 assert (sup (x), magic (3) + 1);
***** warning id=interval:UndefinedOperation
 x = infsup (nan (3));
 assert (inf (x), +inf (3));
 assert (sup (x), -inf (3));
***** test
 x = infsup (-inf (3), +inf (3));
 assert (inf (x), -inf (3));
 assert (sup (x), +inf (3));
***** # decimal boundaries
***** test
 x = infsup ("0.1");
 assert (inf (x), 0.1 - eps / 16);
 assert (sup (x), 0.1);
***** test
 x = infsup ("0.1e1");
 assert (inf (x), 1);
 assert (sup (x), 1);
***** # hexadecimal boundaries
***** test
 x = infsup ("0xff");
 assert (inf (x), 255);
 assert (sup (x), 255);
***** test
 x = infsup ("0xff.1");
 assert (inf (x), 255.0625);
 assert (sup (x), 255.0625);
***** test
 x = infsup ("0xff.1p-1");
 assert (inf (x), 127.53125);
 assert (sup (x), 127.53125);
***** # named constants
***** test
 x = infsup ("pi");
 assert (inf (x), pi);
 assert (sup (x), pi + 2 * eps);
***** test
 x = infsup ("e");
 assert (inf (x), e);
 assert (sup (x), e + eps);
***** # uncertain form
***** test
 x = infsup ("32?");
 assert (inf (x), 31.5);
 assert (sup (x), 32.5);
***** test
 x = infsup ("32?8");
 assert (inf (x), 24);
 assert (sup (x), 40);
***** test
 x = infsup ("32?u");
 assert (inf (x), 32);
 assert (sup (x), 32.5);
***** test
 x = infsup ("32?d");
 assert (inf (x), 31.5);
 assert (sup (x), 32);
***** test
 x = infsup ("32??");
 assert (inf (x), -inf);
 assert (sup (x), +inf);
***** test
 x = infsup ("32??d");
 assert (inf (x), -inf);
 assert (sup (x), 32);
***** test
 x = infsup ("32??u");
 assert (inf (x), 32);
 assert (sup (x), +inf);
***** test
 x = infsup ("32?e5");
 assert (inf (x), 3150000);
 assert (sup (x), 3250000);
***** # rational form
***** test
 x = infsup ("6/9");
 assert (inf (x), 2 / 3);
 assert (sup (x), 2 / 3 + eps / 2);
***** test
 x = infsup ("6e1/9");
 assert (inf (x), 20 / 3 - eps * 2);
 assert (sup (x), 20 / 3);
***** test
 x = infsup ("6/9e1");
 assert (inf (x), 2 / 30);
 assert (sup (x), 2 / 30 + eps / 16);
***** test
 x = infsup ("-6/9");
 assert (inf (x), -(2 / 3 + eps / 2));
 assert (sup (x), -2 / 3);
***** test
 x = infsup ("6/-9");
 assert (inf (x), -(2 / 3 + eps / 2));
 assert (sup (x), -2 / 3);
***** test
 x = infsup ("-6/-9");
 assert (inf (x), 2 / 3);
 assert (sup (x), 2 / 3 + eps / 2);
***** test
 x = infsup ("6.6/9.9");
 assert (inf (x), 2 / 3);
 assert (sup (x), 2 / 3 + eps / 2);
***** # inf-sup interval literal
***** test
 x = infsup ("[2, 3]");
 assert (inf (x), 2);
 assert (sup (x), 3);
***** test
 x = infsup ("[0.1]");
 assert (inf (x), 0.1 - eps / 16);
 assert (sup (x), 0.1);
***** test
 x = infsup ("[0xff, 0xff.1]");
 assert (inf (x), 255);
 assert (sup (x), 255.0625);
***** test
 x = infsup ("[e, pi]");
 assert (inf (x), e);
 assert (sup (x), pi + 2 * eps);
***** test
 x = infsup ("[6/9, 6e1/9]");
 assert (inf (x), 2 / 3);
 assert (sup (x), 20 / 3);
***** # corner cases
***** test
 x = infsup (",");
 assert (inf (x), -inf);
 assert (sup (x), +inf);
***** test
 x = infsup ("[, 3]");
 assert (inf (x), -inf);
 assert (sup (x), 3);
***** test
 x = infsup ("", "3");
 assert (inf (x), -inf);
 assert (sup (x), 3);
***** test
 x = infsup ("[2, ]");
 assert (inf (x), 2);
 assert (sup (x), inf);
***** test
 x = infsup ("2", "");
 assert (inf (x), 2);
 assert (sup (x), inf);
***** # decimal vector
***** test
 x = infsup (["0.1"; "0.2"; "0.3"]);
 assert (inf (x), [0.1 - eps / 16; 0.2 - eps / 8; 0.3]);
 assert (sup (x), [0.1; 0.2; 0.3 + eps / 8]);
***** test
 x = infsup ("0.1; 0.2; 0.3");
 assert (inf (x), [0.1 - eps / 16; 0.2 - eps / 8; 0.3]);
 assert (sup (x), [0.1; 0.2; 0.3 + eps / 8]);
***** test
 x = infsup ("0.1\n0.2\n0.3");
 assert (inf (x), [0.1 - eps / 16; 0.2 - eps / 8; 0.3]);
 assert (sup (x), [0.1; 0.2; 0.3 + eps / 8]);
***** # cell array with mixed boundaries
***** test
 x = infsup ({"0.1", 42; "e", "3.2/8"}, {"0xffp2", "42e1"; "pi", 2});
 assert (inf (x), [0.1 - eps / 16, 42; e, 0.4 - eps / 4]);
 assert (sup (x), [1020, 420; pi + 2 * eps, 2]);
***** test
 x = infsup ({"[2, 3]", "3/4", "[Entire]", "42?3", 1, "0xf"});
 assert (inf (x), [2, 0.75, -inf, 39, 1, 15]);
 assert (sup (x), [3, 0.75, +inf, 45, 1, 15]);
***** # broadcasting
***** test
 x = infsup (magic (3), 10);
 assert (inf (x), magic (3));
 assert (sup (x), 10 .* ones (3));
***** test
 x = infsup (zeros (1, 20), ones (20, 1));
 assert (inf (x), zeros (20, 20));
 assert (sup (x), ones (20, 20));
***** # nai
***** warning id=interval:UndefinedOperation
 x = infsup ("[nai]");
 assert (inf (x), +inf);
 assert (sup (x), -inf);
***** warning id=interval:UndefinedOperation
 x = infsup ("Ausgeschnitzel");
 assert (inf (x), +inf);
 assert (sup (x), -inf);
***** # interval literals vs. two arguments
***** warning id=interval:UndefinedOperation
 x = infsup ("[empty]", 42);
 assert (inf (x), +inf);
 assert (sup (x), -inf);
***** warning id=interval:UndefinedOperation
 x = infsup ("0?", 42);
 assert (inf (x), +inf);
 assert (sup (x), -inf);
***** # extraction of single errors
***** warning id=interval:UndefinedOperation
 x = infsup ("0 1 2 [xxx] 3 4");
 assert (inf (x), [0 1 2 +inf 3 4]);
 assert (sup (x), [0 1 2 -inf 3 4]);
***** warning id=interval:UndefinedOperation
 x = infsup ({1 2; 3 "[xxx]"});
 assert (inf (x), [1 2; 3 +inf]);
 assert (sup (x), [1 2; 3 -inf]);
***** # complex values
***** warning id=interval:InvalidOperand
 x = infsup ([1 2 3+i 4+0i]);
 assert (inf (x), [1 2 +inf 4]);
 assert (sup (x), [1 2 -inf 4]);
***** # inaccurate conversion
***** warning id=interval:PossiblyUndefinedOperation
 x = infsup ("1.000000000000000000002", "1.000000000000000000001");
 assert (inf (x), 1);
 assert (sup (x), 1 + eps);
***** test
 n = uint64(2 ^ 53);
 x = infsup (n, n + 1);
 assert (inf (x), double (n));
 assert (sup (x), double (n + 2));
***** test
 n = uint64(2 ^ 53);
 x = infsup ({n}, n + 1);
 assert (inf (x), double (n));
 assert (sup (x), double (n + 2));
***** test
 n = uint64(2 ^ 53);
 x = infsup (n + 1, n + 1);
 assert (inf (x), double (n));
 assert (sup (x), double (n + 2));
***** test
 n = uint64(2 ^ 54);
 x = infsup (n, n + 1);
 assert (inf (x), double (n));
 assert (sup (x), double (n + 4));
***** warning id=interval:PossiblyUndefinedOperation
 n = uint64(2 ^ 54);
 x = infsup (n + 1, n + 2);
 assert (inf (x), double (n));
 assert (sup (x), double (n + 4));
***** warning id=interval:PossiblyUndefinedOperation
 x = infsup ("pi", "3.141592653589793");
 assert (inf (x), pi);
 assert (sup (x), pi);
***** warning id=interval:PossiblyUndefinedOperation
 x = infsup ("pi", "3.1415926535897932");
 assert (inf (x), pi);
 assert (sup (x), pi + 2 * eps);
***** # isexact flag
***** test
 [~, isexact] = infsup ();
 assert (isexact);
***** test
 [~, isexact] = infsup (0);
 assert (isexact);
***** test
 [~, isexact] = infsup ("1 2 3");
 assert (isexact, true);
***** test
 [~, isexact] = infsup ("1 2 3.1");
 assert (isexact, false);
***** warning
 [~, isexact] = infsup ("[nai]");
 assert (not (isexact));
***** # overflow flag
***** test
 [~, ~, overflow] = infsup ();
 assert (not (overflow));
***** test
 [~, ~, overflow] = infsup (0);
 assert (not (overflow));
***** test
 [~, ~, overflow] = infsup ([1 2 3]);
 assert (overflow, false (1, 3));
***** warning
 [~, ~, overflow] = infsup ("[nai]");
 assert (not (overflow));
***** test
 [~, ~, overflow] = infsup ("1e3000");
 assert (overflow);
***** test
 [~, ~, overflow] = infsup ("[1, inf]");
 assert (not (overflow));
***** # isnai flag
***** test
 [~, ~, ~, isnai] = infsup ();
 assert (not (isnai));
***** test
 [~, ~, ~, isnai] = infsup (0);
 assert (not (isnai));
***** test
 [~, ~, ~, isnai] = infsup ([1 2 3]);
 assert (isnai, false (1, 3));
***** warning
 [~, ~, ~, isnai] = infsup ("[nai]");
 assert (isnai);
***** warning
 [~, ~, ~, isnai] = infsup ("xxx");
 assert (isnai);
***** warning
 [~, ~, ~, isnai] = infsup ("1 2 xxx 4");
 assert (isnai, [false, false, true, false]);
***** warning
 [~, ~, ~, isnai] = infsup ("[-inf, inf] [inf, inf]");
 assert (isnai, [false, true]);
***** # N-dimensional arrays
***** test
 x = infsup (zeros (2, 2, 2));
 assert (x.inf, zeros (2, 2, 2));
 assert (x.sup, zeros (2, 2, 2));
***** test
 x = infsup (zeros (2, 2, 2), ones (2, 2, 2));
 assert (x.inf, zeros (2, 2, 2));
 assert (x.sup, ones (2, 2, 2));
***** test
 x = infsup (zeros (2, 1, 2, 1, 2, 1), ones (1, 3, 1, 3, 1, 3));
 assert (x.inf, zeros (2, 3, 2, 3, 2, 3));
 assert (x.sup, ones (2, 3, 2, 3, 2, 3));
***** test
 c1 = reshape ({1, 2, 3, 4, 5, 6, 7, 8}, 2, 2, 2);
 c2 = reshape ({2, 3, 4, 5, 6, 7, 8, 9}, 2, 2, 2);
 x = infsup (c1, c2);
 assert (x.inf, reshape (1:8, 2, 2, 2));
 assert (x.sup, reshape (2:9, 2, 2, 2));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.("b-numsToInterval");
 for testcase = [testcases]'
   assert (isequaln (...
     infsup (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.("b-numsToInterval");
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (infsup (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.("b-numsToInterval");
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (infsup (in1, in2), out));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.("b-textToInterval");
 for testcase = [testcases]'
   assert (isequaln (...
     infsup (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.("b-textToInterval");
 in1 = vertcat (testcases.in);
 out = vertcat (testcases.out);
 assert (isequaln (infsup (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.("b-numsToInterval");
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (infsup (in1, in2), out));
***** warning
 testcases = testdata.PossiblyUndefinedOperation.infsup.("b-textToInterval");
 for testcase = [testcases]'
   lastwarn ("", "");
   assert (isequaln (...
     infsup (testcase.in{1}), ...
     testcase.out));
   assert (nthargout (2, @lastwarn), "interval:PossiblyUndefinedOperation");
 endfor
***** warning
 testcases = testdata.UndefinedOperation.infsup.("b-textToInterval");
 for testcase = [testcases]'
   lastwarn ("", "");
   assert (isequaln (...
     infsup (testcase.in{1}), ...
     testcase.out));
   assert (nthargout (2, @lastwarn), "interval:UndefinedOperation");
 endfor
***** warning
 testcases = testdata.UndefinedOperation.infsup.("b-numsToInterval");
 for testcase = [testcases]'
   lastwarn ("", "");
   assert (isequaln (...
     infsup (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
   assert (nthargout (2, @lastwarn), "interval:UndefinedOperation");
 endfor
117 tests, 117 passed, 0 known failure, 0 skipped
[inst/@infsup/sumabs.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/sumabs.m
***** # from the documentation string
***** assert (sumabs ([infsup(1), pow2(-1074), -1]) == infsup (2, 2+eps*2));
***** assert (sumabs (infsup ([])) == 0);
***** # correct use of signed zeros
***** test
 x = sumabs (infsup (0));
 assert (signbit (inf (x)));
 assert (not (signbit (sup (x))));
3 tests, 3 passed, 0 known failure, 0 skipped
[inst/@infsup/ismember.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/ismember.m
***** assert (ismember (0, entire ()));
***** assert (ismember (0, intervalpart (entire ())));
***** assert (not (ismember (0, empty ())));
***** assert (not (ismember (0, intervalpart (empty ()))));
***** warning assert (not (ismember (0, infsupdec (2, 1))));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.isMember;
 for testcase = [testcases]'
   assert (isequaln (...
     ismember (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.isMember;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (ismember (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.isMember;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (ismember (in1, in2), out));
***** test
 # Decorated scalar evaluation
 testcases = testdata.NoSignal.infsupdec.isMember;
 for testcase = [testcases]'
   assert (isequaln (...
     ismember (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Decorated vector evaluation
 testcases = testdata.NoSignal.infsupdec.isMember;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (ismember (in1, in2), out));
***** test
 # Decorated N-dimensional array evaluation
 testcases = testdata.NoSignal.infsupdec.isMember;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (ismember (in1, in2), out));
11 tests, 11 passed, 0 known failure, 0 skipped
[inst/@infsup/intervaltoexact.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/intervaltoexact.m
***** assert (intervaltoexact (infsup (1 + eps)), "[0x1.0000000000001p+0]");
1 test, 1 passed, 0 known failure, 0 skipped
[inst/@infsup/nthroot.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/nthroot.m
***** assert (nthroot (infsup (25, 36), 2) == infsup (5, 6));
***** # correct use of signed zeros
***** test
 x = nthroot (infsup (0), 2);
 assert (signbit (inf (x)));
 assert (not (signbit (sup (x))));
***** test
 x = nthroot (infsup (0, inf), -2);
 assert (signbit (inf (x)));
***** test
 x = nthroot (infsup (0, inf), -3);
 assert (signbit (inf (x)));
***** assert (nthroot (infsup (-1, 1), 2) == infsup (0, 1));
***** assert (nthroot (infsup (-1, 1), 3) == infsup (-1, 1));
***** assert (nthroot (infsup (-1, 1), -2) == infsup (1, inf));
***** assert (nthroot (infsup (-1, 1), -3) == infsup (-inf, inf));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.rootn;
 for testcase = [testcases]'
   assert (isequaln (...
     nthroot (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.rootn;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (nthroot (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.rootn;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 if (i > numel (in1))
   i = i - numel (in1);
   in1 = [in1; in1];
   in2 = [in2; in2];
   out = [out; out];
 endif
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (nthroot (in1, in2), out));
11 tests, 11 passed, 0 known failure, 0 skipped
[inst/@infsup/absrev.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/absrev.m
***** # Empty interval
***** assert (absrev (infsup ()) == infsup ());
***** assert (absrev (infsup (0, 1), infsup ()) == infsup ());
***** assert (absrev (infsup (0, 1), infsup (7, 9)) == infsup ());
***** assert (absrev (infsup (), infsup (0, 1)) == infsup ());
***** assert (absrev (infsup (-2, -1)) == infsup ());
***** # Singleton intervals
***** assert (absrev (infsup (1)) == infsup (-1, 1));
***** assert (absrev (infsup (0)) == infsup (0));
***** assert (absrev (infsup (-1)) == infsup ());
***** assert (absrev (infsup (realmax)) == infsup (-realmax, realmax));
***** assert (absrev (infsup (realmin)) == infsup (-realmin, realmin));
***** assert (absrev (infsup (-realmin)) == infsup ());
***** assert (absrev (infsup (-realmax)) == infsup ());
***** # Bound intervals
***** assert (absrev (infsup (1, 2)) == infsup (-2, 2));
***** assert (absrev (infsup (1, 2), infsup (0, 2)) == infsup (1, 2));
***** assert (absrev (infsup (0, 1), infsup (-0.5, 2)) == infsup (-0.5, 1));
***** assert (absrev (infsup (-1, 1)) == infsup (-1, 1));
***** assert (absrev (infsup (-1, 0)) == infsup (0));
***** # Unbound intervals
***** assert (absrev (infsup (0, inf)) == infsup (-inf, inf));
***** assert (absrev (infsup (-inf, inf)) == infsup (-inf, inf));
***** assert (absrev (infsup (-inf, 0)) == infsup (0));
***** assert (absrev (infsup (1, inf), infsup (-inf, 0)) == infsup (-inf, -1));
***** assert (absrev (infsup (-1, inf)) == infsup (-inf, inf));
***** assert (absrev (infsup (-inf, -1)) == infsup ());
***** assert (absrev (infsup (-inf, 1)) == infsup (-1, 1));
***** # from the documentation string
***** assert (absrev (infsup (-2, 1)) == infsup (-1, 1));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation with one argument
 testcases = testdata.NoSignal.infsup.absRev;
 for testcase = [testcases]'
   assert (isequaln (...
     absrev (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation with one argument
 testcases = testdata.NoSignal.infsup.absRev;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (absrev (in1), out));
***** test
 # N-dimensional array evaluation with one argument
 testcases = testdata.NoSignal.infsup.absRev;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (absrev (in1), out));
***** test
 # Scalar evaluation with two arguments
 testcases = testdata.NoSignal.infsup.absRevBin;
 for testcase = [testcases]'
   assert (isequaln (...
     absrev (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation with two arguments
 testcases = testdata.NoSignal.infsup.absRevBin;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (absrev (in1, in2), out));
***** test
 # N-dimensional array evaluation with two arguments
 testcases = testdata.NoSignal.infsup.absRevBin;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (absrev (in1, in2), out));
31 tests, 31 passed, 0 known failure, 0 skipped
[inst/@infsup/plus.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/plus.m
***** # from the documentation string
***** assert (infsup (2, 3) + infsup (1, 2) == infsup (3, 5));
***** # correct use of signed zeros
***** test
 x = plus (infsup (0), infsup (0));
 assert (signbit (inf (x)));
 assert (not (signbit (sup (x))));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.add;
 for testcase = [testcases]'
   assert (isequaln (...
     plus (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.add;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (plus (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.add;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (plus (in1, in2), out));
5 tests, 5 passed, 0 known failure, 0 skipped
[inst/@infsup/norm.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/norm.m
***** test
 A = infsup ("0 [Empty] [0, 1] 1");
 assert (isequal (norm (A, 0, "cols"), infsup ("0 [Empty] [0, 1] 1")));
***** assert (norm (infsup (magic (3)), inf, 1) == 45);
***** assert (norm (infsup (-magic (3), magic (3)), inf, 1) == "[0, 45]");
3 tests, 3 passed, 0 known failure, 0 skipped
[inst/@infsup/atan.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/atan.m
***** # from the documentation string
***** assert (atan (infsup (1)) == "[0x1.921FB54442D18p-1, 0x1.921FB54442D19p-1]");
***** # correct use of signed zeros
***** test
 x = atan (infsup (0));
 assert (signbit (inf (x)));
 assert (not (signbit (sup (x))));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.atan;
 for testcase = [testcases]'
   assert (isequaln (...
     atan (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.atan;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (atan (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.atan;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (atan (in1), out));
5 tests, 5 passed, 0 known failure, 0 skipped
[inst/@infsup/mince.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/mince.m
***** assert (isequal (mince (infsup (0, 10), 10), infsup (0 : 9, 1 : 10)));
1 test, 1 passed, 0 known failure, 0 skipped
[inst/@infsup/sec.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/sec.m
***** # from the documentation string
***** assert (sec (infsup (1)) == "[0x1.D9CF0F125CC29, 0x1.D9CF0F125CC2A]");
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.sec;
 for testcase = [testcases]'
   assert (isequaln (...
     sec (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.sec;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (sec (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.sec;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (sec (in1), out));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsup/pownrev.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/pownrev.m
***** assert (pownrev (infsup (25, 36), infsup (0, inf), 2) == infsup (5, 6));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.pownRev;
 for testcase = [testcases]'
   assert (isequaln (...
     pownrev (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.pownRev;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (pownrev (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.pownRev;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (pownrev (in1, in2), out));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.pownRevBin;
 for testcase = [testcases]'
   assert (isequaln (...
     pownrev (testcase.in{1}, testcase.in{2}, testcase.in{3}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.pownRevBin;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 in3 = vertcat (vertcat (testcases.in){:, 3});
 out = vertcat (testcases.out);
 assert (isequaln (pownrev (in1, in2, in3), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.pownRevBin;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 in3 = vertcat (vertcat (testcases.in){:, 3});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 in3 = reshape ([in3; in3(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (pownrev (in1, in2, in3), out));
7 tests, 7 passed, 0 known failure, 0 skipped
[inst/@infsup/diag.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/diag.m
***** assert (diag (infsup (-inf, inf)) == "[Entire]");
***** assert (diag (infsup ()) == "[Empty]");
***** assert (numel (diag (infsup ([]))), 0);
***** assert (isequal (diag (infsup (magic (3))), infsup ([8; 5; 2])));
***** assert (isequal (diag (infsup ([8 5 3])), infsup ([8 0 0; 0 5 0; 0 0 3])));
***** assert (isequal (diag (infsup (1:2), 2, 3), infsup ([1 0 0; 0 2 0])));
6 tests, 6 passed, 0 known failure, 0 skipped
[inst/@infsup/cbrt.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/cbrt.m
***** # from the documentation string
***** assert (cbrt (infsup (-27, 27)) == infsup (-3, 3));
***** # correct use of signed zeros
***** test
 x = cbrt (infsup (0));
 assert (signbit (inf (x)));
 assert (not (signbit (sup (x))));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.cbrt;
 for testcase = [testcases]'
   assert (isequaln (...
     cbrt (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.cbrt;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (cbrt (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.cbrt;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (cbrt (in1), out));
5 tests, 5 passed, 0 known failure, 0 skipped
[inst/@infsup/sinrev.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/sinrev.m
***** # from the documentation string
***** assert (sinrev (infsup (-1), infsup (0, 6)) == "[0x1.2D97C7F3321D2p2, 0x1.2D97C7F3321D3p2]");
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.sinRev;
 for testcase = [testcases]'
   assert (isequaln (...
     sinrev (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.sinRev;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (sinrev (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.sinRev;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (sinrev (in1), out));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.sinRevBin;
 for testcase = [testcases]'
   assert (isequaln (...
     sinrev (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.sinRevBin;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (sinrev (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.sinRevBin;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (sinrev (in1, in2), out));
7 tests, 7 passed, 0 known failure, 0 skipped
[inst/@infsup/ne.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/ne.m
***** assert (ne (infsup (1, 2), infsup (1, 3)));
1 test, 1 passed, 0 known failure, 0 skipped
[inst/@infsup/csc.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/csc.m
***** # from the documentation string
***** assert (csc (infsup (1)) == "[0x1.303AA9620B223, 0x1.303AA9620B224]");
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.csc;
 for testcase = [testcases]'
   assert (isequaln (...
     csc (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.csc;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (csc (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.csc;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (csc (in1), out));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsup/dot.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/dot.m
***** # matrix  matrix
***** assert (dot (infsup (magic (3)), magic (3)) == [89, 107, 89]);
***** assert (dot (infsup (magic (3)), magic (3), 1) == [89, 107, 89]);
***** assert (dot (infsup (magic (3)), magic (3), 2) == [101; 83; 101]);
***** # matrix  vector
***** assert (dot (infsup (magic (3)), [1, 2, 3]) == [28; 34; 28]);
***** assert (dot (infsup (magic (3)), [1, 2, 3], 1) == [15, 30, 45]);
***** assert (dot (infsup (magic (3)), [1, 2, 3], 2) == [28; 34; 28]);
***** assert (dot (infsup (magic (3)), [1; 2; 3]) == [26, 38, 26]);
***** assert (dot (infsup (magic (3)), [1; 2; 3], 1) == [26, 38, 26]);
***** assert (dot (infsup (magic (3)), [1; 2; 3], 2) == [15; 30; 45]);
***** # matrix  scalar
***** assert (dot (infsup (magic (3)), 42) == [630, 630, 630]);
***** assert (dot (infsup (magic (3)), 42, 1) == [630, 630, 630]);
***** assert (dot (infsup (magic (3)), 42, 2) == [630; 630; 630]);
***** # vector x vector
***** assert (dot (infsup([1, 2, 3]), [4, 5, 6]) == 32);
***** assert (dot (infsup([1, 2, 3]), [4, 5, 6], 1) == [4, 10, 18]);
***** assert (dot (infsup([1, 2, 3]), [4, 5, 6], 2) == 32);
***** assert (dot (infsup([1; 2; 3]), [4; 5; 6]) == 32);
***** assert (dot (infsup([1; 2; 3]), [4; 5; 6], 1) == 32);
***** assert (dot (infsup([1; 2; 3]), [4; 5; 6], 2) == [4; 10; 18]);
***** # vector  scalar
***** assert (dot (infsup ([1, 2, 3]), 42) == 252);
***** assert (dot (infsup ([1, 2, 3]), 42, 1) == [42, 84, 126]);
***** assert (dot (infsup ([1, 2, 3]), 42, 2) == 252);
***** assert (dot (infsup ([1; 2; 3]), 42) == 252);
***** assert (dot (infsup ([1; 2; 3]), 42, 1) == 252);
***** assert (dot (infsup ([1; 2; 3]), 42, 2) == [42; 84; 126]);
***** # N-dimensional arrays
***** test
  x = infsup (reshape (1:24, 2, 3, 4));
  y = infsup (2.*ones (2, 3, 4));
  assert (dot (x, y, 3) == infsup ([80, 96, 112; 88, 104, 120]))
***** test
  x = infsup (ones (2, 2, 2, 2));
  y = infsup (1);
  assert (size (dot (x, y)), [1, 2, 2, 2]);
  assert (size (dot (x, y, 1)), [1, 2, 2, 2]);
  assert (size (dot (x, y, 2)), [2, 1, 2, 2]);
  assert (size (dot (x, y, 3)), [2, 2, 1, 2]);
  assert (size (dot (x, y, 4)), [2, 2, 2]);
  assert (size (dot (x, y, 5)), [2, 2, 2, 2]);
***** # from the documentation string
***** assert (dot ([infsup(1), 2, 3], [infsup(2), 3, 4]) == 20);
***** assert (dot (infsup ([realmax; realmin; realmax]), [1; -1; -1], 1) == -realmin);
28 tests, 28 passed, 0 known failure, 0 skipped
[inst/@infsup/atan2rev1.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/atan2rev1.m
***** # from the documentation string
***** assert (atan2rev1 (infsup (1, 2), infsup ("pi") / 4) == "[0x1.FFFFFFFFFFFFFp-1, 0x1.0000000000001p1]");
1 test, 1 passed, 0 known failure, 0 skipped
[inst/@infsup/pow.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/pow.m
***** # from the documentation string
***** assert (pow (infsup (5, 6), infsup (2, 3)) == infsup (25, 216));
***** # correct use of signed zeros
***** test
 x = pow (infsup (0), infsup (1));
 assert (signbit (inf (x)));
 assert (not (signbit (sup (x))));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.pow;
 for testcase = [testcases]'
   assert (isequaln (...
     pow (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.pow;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (pow (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.pow;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (pow (in1, in2), out));
5 tests, 5 passed, 0 known failure, 0 skipped
[inst/@infsup/ldivide.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/ldivide.m
***** # from the documentation string
***** assert (ldivide (infsup (2, 3), infsup (1, 2)) == "[1/3, 1]");
1 test, 1 passed, 0 known failure, 0 skipped
[inst/@infsup/strictprecedes.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/strictprecedes.m
***** assert (strictprecedes (infsup (1, 1.9), infsup (2.1, 3)));
***** assert (not (strictprecedes (infsup (1, 2), infsup (2, 3))));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.strictPrecedes;
 for testcase = [testcases]'
   assert (isequaln (...
     strictprecedes (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.strictPrecedes;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (strictprecedes (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.strictPrecedes;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (strictprecedes (in1, in2), out));
5 tests, 5 passed, 0 known failure, 0 skipped
[inst/@infsup/gamma.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/gamma.m
***** # from the documentation string
***** assert (gamma (infsup (1.5)) == "[0x1.C5BF891B4EF6Ap-1, 0x1.C5BF891B4EF6Bp-1]");
1 test, 1 passed, 0 known failure, 0 skipped
[inst/@infsup/gt.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/gt.m
***** assert (not (gt (infsup (2, 3), infsup (1, 3))));
***** assert (gt (infsup (2, 3.1), infsup (1, 3)));
2 tests, 2 passed, 0 known failure, 0 skipped
[inst/@infsup/rem.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/rem.m
***** assert (rem (infsup (), infsup ()) == infsup ());
***** assert (rem (infsup (0), infsup ()) == infsup ());
***** assert (rem (infsup (), infsup (0)) == infsup ());
***** assert (rem (infsup (0), infsup (0)) == infsup ());
***** assert (rem (infsup (1), infsup (0)) == infsup ());
***** assert (rem (infsup (0, 1), infsup (0)) == infsup ());
***** assert (rem (infsup (1, 2), infsup (0)) == infsup ());
***** assert (rem (infsup (0, inf), infsup (0)) == infsup ());
***** assert (rem (infsup (1, inf), infsup (0)) == infsup ());
***** assert (rem (infsup (realmax, inf), infsup (0)) == infsup ());
***** assert (rem (infsup (0), infsup (1)) == infsup (0));
***** assert (rem (infsup (0), infsup (0, 1)) == infsup (0));
***** assert (rem (infsup (0), infsup (1, 2)) == infsup (0));
***** assert (rem (infsup (0), infsup (0, inf)) == infsup (0));
***** assert (rem (infsup (0), infsup (1, inf)) == infsup (0));
***** assert (rem (infsup (0), infsup (realmax, inf)) == infsup (0));
***** assert (rem (infsup (1), infsup (1)) == infsup (0));
***** assert (rem (infsup (2), infsup (1)) == infsup (0));
***** assert (rem (infsup (4), infsup (2)) == infsup (0));
***** assert (rem (infsup (6), infsup (3)) == infsup (0));
***** assert (rem (infsup (8), infsup (2)) == infsup (0));
***** assert (rem (infsup (9), infsup (3)) == infsup (0));
***** assert (rem (infsup (realmax), infsup (realmax)) == infsup (0));
***** assert (rem (infsup (realmax), infsup (realmax / 2)) == infsup (0));
***** assert (rem (infsup (realmax), infsup (realmax / 4)) == infsup (0));
***** assert (rem (infsup (realmax), infsup (realmax / 8)) == infsup (0));
***** assert (rem (infsup (realmax), infsup (realmax / 16)) == infsup (0));
***** assert (rem (infsup (realmax), infsup (realmax / 32)) == infsup (0));
***** assert (rem (infsup (0.1), infsup (0.1)) == infsup (0));
***** assert (rem (infsup (0.1 * 2), infsup (0.1)) == infsup (0));
***** assert (rem (infsup (0.1 * 4), infsup (0.1)) == infsup (0));
***** assert (rem (infsup (pi), infsup (pi)) == infsup (0));
***** assert (rem (infsup (pi), infsup (pi / 2)) == infsup (0));
***** assert (rem (infsup (pi), infsup (pi / 4)) == infsup (0));
***** assert (rem (infsup (pow2 (-1074)), infsup (pow2 (-1074))) == infsup (0));
***** assert (rem (infsup (pow2 (-1073)), infsup (pow2 (-1074))) == infsup (0));
***** assert (rem (infsup (pow2 (-1072)), infsup (pow2 (-1074))) == infsup (0));
***** assert (rem (infsup (1), infsup (2)) == infsup (1));
***** assert (rem (infsup (0.5), infsup (1)) == infsup (0.5));
***** assert (rem (infsup (pi), infsup (3.15)) == infsup (pi));
***** assert (rem (infsup (1), infsup (2, 3)) == infsup (1));
***** assert (rem (infsup (1), infsup (2, inf)) == infsup (1));
***** assert (rem (infsup (0.5), infsup (1, 2)) == infsup (0.5));
***** assert (rem (infsup (0.5), infsup (1, inf)) == infsup (0.5));
***** assert (rem (infsup (pi), infsup (3.15)) == infsup (pi));
***** assert (rem (infsup (pi), infsup (3.15, inf)) == infsup (pi));
***** assert (rem (infsup (0, 1), infsup (0, 1)) == infsup (0, 1));
***** assert (rem (infsup (0, 2), infsup (0, 1)) == infsup (0, 1));
***** assert (rem (infsup (0, 1), infsup (0, 2)) == infsup (0, 1));
***** assert (rem (infsup (0, realmax), infsup (0, realmax)) == infsup (0, realmax));
***** assert (rem (infsup (realmax, inf), infsup (realmax, inf)) == infsup (0, inf));
***** assert (rem (infsup (0, inf), infsup (0, inf)) == infsup (0, inf));
***** assert (rem (infsup (0), infsup (1)) == infsup (0));
***** assert (rem (infsup (1), infsup (1)) == infsup (0));
***** assert (rem (infsup (0, 1), infsup (1)) == infsup (0, 1));
***** assert (rem (infsup (1, 2), infsup (1)) == infsup (0, 1));
***** assert (rem (infsup (0, inf), infsup (1)) == infsup (0, 1));
***** assert (rem (infsup (1, inf), infsup (1)) == infsup (0, 1));
***** assert (rem (infsup (realmax, inf), infsup (1)) == infsup (0, 1));
***** assert (rem (infsup (1), infsup (1)) == infsup (0));
***** assert (rem (infsup (1), infsup (0, 1)) == infsup (0, 0.5));
***** assert (rem (infsup (1), infsup (1, 2)) == infsup (0, 1));
***** assert (rem (infsup (1), infsup (0, inf)) == infsup (0, 1));
***** assert (rem (infsup (1), infsup (1, inf)) == infsup (0, 1));
***** assert (rem (infsup (1), infsup (2, inf)) == infsup (1));
***** assert (rem (infsup (1), infsup (realmax, inf)) == infsup (1));
66 tests, 66 passed, 0 known failure, 0 skipped
[inst/@infsup/roundb.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/roundb.m
***** # Empty interval
***** assert (roundb (infsup ()) == infsup ());
***** # Singleton intervals
***** assert (roundb (infsup (0)) == infsup (0));
***** assert (roundb (infsup (0.5)) == infsup (0));
***** assert (roundb (infsup (0.25)) == infsup (0));
***** assert (roundb (infsup (0.75)) == infsup (1));
***** assert (roundb (infsup (1.5)) == infsup (2));
***** assert (roundb (infsup (-0.5)) == infsup (0));
***** assert (roundb (infsup (-1.5)) == infsup (-2));
***** # Bounded intervals
***** assert (roundb (infsup (-0.5, 0)) == infsup (0));
***** assert (roundb (infsup (0, 0.5)) == infsup (0));
***** assert (roundb (infsup (0.25, 0.5)) == infsup (0));
***** assert (roundb (infsup (-1, 0)) == infsup (-1, 0));
***** assert (roundb (infsup (-1, 1)) == infsup (-1, 1));
***** assert (roundb (infsup (-realmin, realmin)) == infsup (0));
***** assert (roundb (infsup (-realmax, realmax)) == infsup (-realmax, realmax));
***** # Unbounded intervals
***** assert (roundb (infsup (-realmin, inf)) == infsup (0, inf));
***** assert (roundb (infsup (-realmax, inf)) == infsup (-realmax, inf));
***** assert (roundb (infsup (-inf, realmin)) == infsup (-inf, 0));
***** assert (roundb (infsup (-inf, realmax)) == infsup (-inf, realmax));
***** assert (roundb (infsup (-inf, inf)) == infsup (-inf, inf));
***** # correct use of signed zeros
***** test
 x = roundb (infsup (0));
 assert (signbit (inf (x)));
 assert (not (signbit (sup (x))));
***** test
 x = roundb (infsup (-0.25, 0.25));
 assert (signbit (inf (x)));
 assert (not (signbit (sup (x))));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.roundTiesToEven;
 for testcase = [testcases]'
   assert (isequaln (...
     roundb (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.roundTiesToEven;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (roundb (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.roundTiesToEven;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (roundb (in1), out));
25 tests, 25 passed, 0 known failure, 0 skipped
[inst/@infsup/times.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/times.m
***** # from the documentation string
***** assert (infsup (2, 3) .* infsup (1, 2) == infsup (2, 6));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.mul;
 for testcase = [testcases]'
   assert (isequaln (...
     times (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.mul;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (times (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.mul;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (times (in1, in2), out));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsup/lu.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/lu.m
***** test
 [l, u] = lu (infsup (magic (3)));
 assert (l == infsup ({1, 0, 0; .375, 1, 0; .5, "68/37", 1}));, ...
 assert (subset (u, infsup ({8, 1, 6; 0, 4.625, 4.75; 0, 0, "-0x1.3759F2298375Bp3"}, ...
                            {8, 1, 6; 0, 4.625, 4.75; 0, 0, "-0x1.3759F22983759p3"})));
***** test
 A = magic (3);
 A([1, 5, 9]) = 0;
 [l, u, p] = lu (infsup (A));
 assert (p, [0, 0, 1; 1, 0, 0; 0, 1, 0]);
 assert (l == infsup ({1, 0, 0; "4/3", 1, 0; 0, "1/9", 1}));
 assert (subset (u, infsup ({3, 0, 7; 0, 9, "-0x1.2AAAAAAAAAAACp3"; 0, 0, "0x1.C25ED097B425Ep2"}, ...
                            {3, 0, 7; 0, 9, "-0x1.2AAAAAAAAAAAAp3"; 0, 0, "0x1.C25ED097B426p2"})));
2 tests, 2 passed, 0 known failure, 0 skipped
[inst/@infsup/intersect.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/intersect.m
***** # Empty interval
***** assert (intersect (infsup (), infsup ()) == infsup ());
***** assert (intersect (infsup (), infsup (1)) == infsup ());
***** assert (intersect (infsup (0), infsup ()) == infsup ());
***** assert (intersect (infsup (-inf, inf), infsup ()) == infsup ());
***** # Singleton intervals
***** assert (intersect (infsup (0), infsup (1)) == infsup ());
***** assert (intersect (infsup (0), infsup (0)) == infsup (0));
***** # Bounded intervals
***** assert (intersect (infsup (1, 2), infsup (3, 4)) == infsup ());
***** assert (intersect (infsup (1, 2), infsup (2, 3)) == infsup (2));
***** assert (intersect (infsup (1, 2), infsup (1.5, 2.5)) == infsup (1.5, 2));
***** assert (intersect (infsup (1, 2), infsup (1, 2)) == infsup (1, 2));
***** # Unbounded intervals
***** assert (intersect (infsup (0, inf), infsup (-inf, 0)) == infsup (0));
***** assert (intersect (infsup (1, inf), infsup (-inf, -1)) == infsup ());
***** assert (intersect (infsup (-1, inf), infsup (-inf, 1)) == infsup (-1, 1));
***** assert (intersect (infsup (-inf, inf), infsup (42)) == infsup (42));
***** assert (intersect (infsup (42), infsup (-inf, inf)) == infsup (42));
***** assert (intersect (infsup (-inf, 0), infsup (-inf, inf)) == infsup (-inf, 0));
***** assert (intersect (infsup (-inf, inf), infsup (-inf, inf)) == infsup (-inf, inf));
***** # from the documentation string
***** assert (intersect (infsup (1, 3), infsup (2, 4)) == infsup (2, 3));
***** # correct use of signed zeros
***** test
 x = intersect (infsup (0), infsup (0));
 assert (signbit (inf (x)));
 assert (not (signbit (sup (x))));
***** test
 x = intersect (infsup (0), infsup (0, 1));
 assert (signbit (inf (x)));
 assert (not (signbit (sup (x))));
***** test
 x = intersect (infsup (0, 1), infsup (0));
 assert (signbit (inf (x)));
 assert (not (signbit (sup (x))));
***** test
 x = intersect (infsup (-1, 0), infsup (0, 1));
 assert (signbit (inf (x)));
 assert (not (signbit (sup (x))));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.intersection;
 for testcase = [testcases]'
   assert (isequaln (...
     intersect (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.intersection;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (intersect (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.intersection;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (intersect (in1, in2), out));
25 tests, 25 passed, 0 known failure, 0 skipped
[inst/@infsup/cos.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/cos.m
***** # from the documentation string
***** assert (cos (infsup (1)) == "[0x1.14A280FB5068Bp-1, 0x1.14A280FB5068Cp-1]");
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.cos;
 for testcase = [testcases]'
   assert (isequaln (...
     cos (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.cos;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (cos (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.cos;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (cos (in1), out));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsup/eq.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/eq.m
***** test "Empty interval";
 assert (eq (infsup (), infsup ()) == true);
 assert (eq (infsup (), infsup (1)) == false);
 assert (eq (infsup (0), infsup ()) == false);
 assert (eq (infsup (-inf, inf), infsup ()) == false);
***** test "Singleton intervals";
 assert (eq (infsup (0), infsup (1)) == false);
 assert (eq (infsup (0), infsup (0)) == true);
***** test "Bounded intervals";
 assert (eq (infsup (1, 2), infsup (3, 4)) == false);
 assert (eq (infsup (1, 2), infsup (2, 3)) == false);
 assert (eq (infsup (1, 2), infsup (1.5, 2.5)) == false);
 assert (eq (infsup (1, 2), infsup (1, 2)) == true);
***** test "Unbounded intervals";
 assert (eq (infsup (0, inf), infsup (-inf, 0)) == false);
 assert (eq (infsup (0, inf), infsup (0, inf)) == true);
 assert (eq (infsup (-inf, 0), infsup (-inf, 0)) == true);
 assert (eq (infsup (-inf, inf), infsup (42)) == false);
 assert (eq (infsup (-inf, 0), infsup (-inf, inf)) == false);
 assert (eq (infsup (-inf, inf), infsup (-inf, inf)) == true);
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.equal;
 for testcase = [testcases]'
   assert (isequaln (...
     eq (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.equal;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (eq (in1, in2), out));
***** test
 # N-dimensional array evaluations
 testcases = testdata.NoSignal.infsup.equal;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (eq (in1, in2), out));
7 tests, 7 passed, 0 known failure, 0 skipped
[inst/@infsup/coth.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/coth.m
***** # from the documentation string
***** assert (coth (infsup (1)) == "[0x1.50231499B6B1D, 0x1.50231499B6B1E]");
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.coth;
 for testcase = [testcases]'
   assert (isequaln (...
     coth (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.coth;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (coth (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.coth;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (coth (in1), out));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsup/iscommoninterval.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/iscommoninterval.m
***** assert (iscommoninterval (infsup (2, 3)));
***** assert (not (iscommoninterval (infsup (2, inf))));
***** assert (not (iscommoninterval (infsup ())));
***** assert (not (iscommoninterval (infsup (-inf, inf))));
***** assert (iscommoninterval (infsupdec (2, 3, "com")));
***** assert (iscommoninterval (infsupdec (2, 3, "trv")));
***** assert (not (iscommoninterval (infsupdec (2, inf, "trv"))));
***** assert (not (iscommoninterval (empty ())));
***** assert (not (iscommoninterval (entire ())));
***** warning assert (not (iscommoninterval (infsupdec (2, 1))));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.isCommonInterval;
 for testcase = [testcases]'
   assert (isequaln (...
     iscommoninterval (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.isCommonInterval;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (iscommoninterval (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.isCommonInterval;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (iscommoninterval (in1), out));
***** test
 # Decorated scalar evaluation
 testcases = testdata.NoSignal.infsupdec.isCommonInterval;
 for testcase = [testcases]'
   assert (isequaln (...
     iscommoninterval (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Decorated vector evaluation
 testcases = testdata.NoSignal.infsupdec.isCommonInterval;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (iscommoninterval (in1), out));
***** test
 # Decorated N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.isCommonInterval;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (iscommoninterval (in1), out));
16 tests, 16 passed, 0 known failure, 0 skipped
[inst/@infsup/sech.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/sech.m
***** # from the documentation string
***** assert (sech (infsup (1)) == "[0x1.4BCDC50ED6BE7p-1, 0x1.4BCDC50ED6BE8p-1]");
***** # correct use of signed zeros
***** test
 x = sech (infsup (0, inf));
 assert (signbit (inf (x)));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.sech;
 for testcase = [testcases]'
   assert (isequaln (...
     sech (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.sech;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (sech (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.sech;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (sech (in1), out));
5 tests, 5 passed, 0 known failure, 0 skipped
[inst/@infsup/nextout.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/nextout.m
***** # from the documentation string
***** test
 x = nextout (infsup (1));
 assert (inf (x), 1 - eps / 2);
 assert (sup (x), 1 + eps);
***** # correct use of signed zeros
***** test
 x = nextout (infsup (pow2 (-1074)));
 assert (signbit (inf (x)));
***** test
 x = nextout (infsup (-pow2 (-1074)));
 assert (not (signbit (sup (x))));
3 tests, 3 passed, 0 known failure, 0 skipped
[inst/@infsup/sdist.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/sdist.m
***** # from the documentation string
***** assert (sdist (infsup (0, 6), infsup (7, 20)), -1);
***** assert (sdist (infsup (3, 5), infsup (0, 1)), 2);
2 tests, 2 passed, 0 known failure, 0 skipped
[inst/@infsup/union.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/union.m
***** # from the documentation string
***** assert (union (infsup (1, 3), infsup (2, 4)) == infsup (1, 4));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.convexHull;
 for testcase = [testcases]'
   assert (isequaln (...
     union (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.convexHull;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (union (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.convexHull;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (union (in1, in2), out));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsup/ismatrix.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/ismatrix.m
***** assert (ismatrix (infsup ([])));
***** assert (ismatrix (infsup (0)));
***** assert (ismatrix (infsup (zeros (3, 1))));
***** assert (ismatrix (infsup (zeros (1, 4))));
***** assert (ismatrix (infsup (zeros (3, 4))));
5 tests, 5 passed, 0 known failure, 0 skipped
[inst/@infsup/pow10.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/pow10.m
***** # from the documentation string
 assert (pow10 (infsup (5)) == infsup (100000));
***** # correct use of signed zeros
***** test
 x = pow10 (infsup (-inf, -realmax));
 assert (signbit (inf (x)));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.exp10;
 for testcase = [testcases]'
   assert (isequaln (...
     pow10 (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.exp10;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (pow10 (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.exp10;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (pow10 (in1), out));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsup/psi.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/psi.m
***** assert (isempty (psi (infsup (0))));
***** assert (isempty (psi (infsup (-1))));
***** assert (isempty (psi (infsup (-2))));
***** assert (isempty (psi (infsup (-3))));
***** assert (isentire (psi (infsup (-inf, -42.23))));
***** assert (isentire (psi (infsup (0, inf))));
***** assert (isentire (psi (infsup (-1, 0))));
***** assert (isentire (psi (infsup (-2, -1))));
***** assert (isentire (psi (infsup (-eps, eps))));
***** assert (isentire (psi (infsup (-1-eps, -1+eps))));
***** assert (isentire (psi (infsup (-4.1, -3.9))));
***** # from the documentation string
***** assert (psi (infsup (1)) == "[-0x1.2788CFC6FB619p-1, -0x1.2788CFC6FB618p-1]");
12 tests, 12 passed, 0 known failure, 0 skipped
[inst/@infsup/power.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/power.m
***** # from the documentation string
***** assert (infsup (-5, 6) .^ infsup (2, 3) == infsup (-125, 216));
***** assert (infsup (-10, 0) .^ infsup (0, 1:8) == infsup ([-1e1, -1e1, -1e3, -1e3, -1e5, -1e5, -1e7, -1e7], [1e0, 1e2, 1e2, 1e4, 1e4, 1e6, 1e6, 1e8]));
***** # correct use of signed zeros
***** test
 x = power (infsup (0), infsup (1));
 assert (signbit (inf (x)));
 assert (not (signbit (sup (x))));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.sqr;
 for testcase = [testcases]'
   assert (isequaln (...
     power (testcase.in{1}, 2), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.sqr;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (power (in1, 2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.sqr;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (power (in1, 2), out));
6 tests, 6 passed, 0 known failure, 0 skipped
[inst/@infsup/issquare.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/issquare.m
***** assert (issquare (infsup ([])));
***** assert (issquare (infsup (0)));
***** assert (not (issquare (infsup (zeros (1, 2)))));
***** assert (not (issquare (infsup (zeros (2, 1)))));
***** assert (issquare (infsup (zeros (5))));
5 tests, 5 passed, 0 known failure, 0 skipped
[inst/@infsup/rsqrt.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/rsqrt.m
***** # from the documentation string
***** assert (rsqrt (infsup (-6, 4)) == infsup (.5, inf));
***** # correct use of signed zeros
***** test
 x = rsqrt (infsup (0, inf));
 assert (signbit (inf (x)));
2 tests, 2 passed, 0 known failure, 0 skipped
[inst/@infsup/atanh.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/atanh.m
***** # from the documentation string
***** assert (atanh (infsup (.5)) == "[0x1.193EA7AAD030Ap-1, 0x1.193EA7AAD030Bp-1]");
***** # correct use of signed zeros
***** test
 x = atanh (infsup (0));
 assert (signbit (inf (x)));
 assert (not (signbit (sup (x))));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.atanh;
 for testcase = [testcases]'
   assert (isequaln (...
     atanh (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.atanh;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (atanh (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.atanh;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (atanh (in1), out));
5 tests, 5 passed, 0 known failure, 0 skipped
[inst/@infsup/sqrrev.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/sqrrev.m
***** # from the documentation string
***** assert (sqrrev (infsup (-2, 1)) == infsup (-1, 1));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.sqrRev;
 for testcase = [testcases]'
   assert (isequaln (...
     sqrrev (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.sqrRev;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (sqrrev (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.sqrRev;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (sqrrev (in1), out));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.sqrRevBin;
 for testcase = [testcases]'
   assert (isequaln (...
     sqrrev (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.sqrRevBin;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (sqrrev (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.sqrRevBin;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (sqrrev (in1, in2), out));
7 tests, 7 passed, 0 known failure, 0 skipped
[inst/@infsup/sign.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/sign.m
***** # from the documentation string
***** assert (sign (infsup (2, 3)) == infsup (1));
***** assert (sign (infsup (0, 5)) == infsup (0, 1));
***** assert (sign (infsup (-17)) == infsup (-1));
***** # correct use of signed zeros
***** test
 x = sign (infsup (0));
 assert (signbit (inf (x)));
 assert (not (signbit (sup (x))));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.sign;
 for testcase = [testcases]'
   assert (isequaln (...
     sign (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.sign;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (sign (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.sign;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (sign (in1), out));
7 tests, 7 passed, 0 known failure, 0 skipped
[inst/@infsup/end.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/end.m
***** assert (infsup (magic (3))(end) == 2);
***** assert (infsup (magic (3))(end, 2) == 9);
***** assert (infsup (magic (3))(2, end) == 7);
***** assert (infsup ([1 2; 3 4; 5 6])(end:-1:1, :) == [5 6; 3 4; 1 2]);
***** assert (reshape (infsup (1:24), 2, 3, 4)(end, end) == 24)
5 tests, 5 passed, 0 known failure, 0 skipped
[inst/@infsup/subsasgn.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/subsasgn.m
***** test
 A = infsup (magic (3));
 A(4, 4) = 42;
 assert (inf (A), [magic(3),[0;0;0];0,0,0,42]);
 assert (sup (A), [magic(3),[0;0;0];0,0,0,42]);
1 test, 1 passed, 0 known failure, 0 skipped
[inst/@infsup/coshrev.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/coshrev.m
***** # from the documentation string
***** assert (coshrev (infsup (-2, 1)) == 0);
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.coshRev;
 for testcase = [testcases]'
   assert (isequaln (...
     coshrev (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.coshRev;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (coshrev (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.coshRev;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (coshrev (in1), out));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.coshRevBin;
 for testcase = [testcases]'
   assert (isequaln (...
     coshrev (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.coshRevBin;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (coshrev (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.coshRevBin;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (coshrev (in1, in2), out));
7 tests, 7 passed, 0 known failure, 0 skipped
[inst/@infsup/tan.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/tan.m
***** # from the documentation string
***** assert (tan (infsup (1)) == "[0x1.8EB245CBEE3A5, 0x1.8EB245CBEE3A6]");
***** # correct use of signed zeros
***** test
 x = tan (infsup (0));
 assert (signbit (inf (x)));
 assert (not (signbit (sup (x))));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.tan;
 for testcase = [testcases]'
   assert (isequaln (...
     tan (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.tan;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (tan (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.tan;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (tan (in1), out));
5 tests, 5 passed, 0 known failure, 0 skipped
[inst/@infsup/isrow.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/isrow.m
***** assert (not (isrow (infsup ([]))));
***** assert (isrow (infsup (0)));
***** assert (isrow (infsup (zeros (1, 2))));
***** assert (not (isrow (infsup (zeros (2, 1)))));
***** assert (not (isrow (infsup (zeros (5)))));
5 tests, 5 passed, 0 known failure, 0 skipped
[inst/@infsup/strictsubset.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/strictsubset.m
***** assert (strictsubset (infsup (1, 2), infsup (1, 3)));
***** assert (strictsubset (infsup (2, 3), infsup (1, 3)));
***** assert (not (strictsubset (infsup (1, 2), infsup (1, 2))));
***** assert (not (strictsubset (infsup (1, 3), infsup (1, 2))));
***** assert (strictsubset (infsup (), infsup (1, 3)));
***** assert (not (strictsubset (infsup (), infsup ())));
***** assert (strictsubset (infsup (), infsup (-inf, inf)));
***** assert (strictsubset (infsup (0, inf), infsup (-inf, inf)));
***** assert (strictsubset (infsup (-inf, 0), infsup (-inf, inf)));
***** assert (not (strictsubset (infsup (-inf, inf), infsup (-inf, inf))));
10 tests, 10 passed, 0 known failure, 0 skipped
[inst/@infsup/subsref.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/subsref.m
***** assert (infsup (magic (3))([1, 2, 3]) == magic (3)([1, 2, 3]));
***** # from the documentation string
***** test
 x = infsup (magic (3), magic (3) + 1);
 assert (x(1) == infsup (8, 9));
 assert (x(:, 2) == infsup ([1; 5; 9], [2; 6; 10]));
 assert (x.inf, magic (3));
***** assert (reshape (infsup (1:16), 2, 2, 2, 2)(2, 7) == infsup (14))
***** assert (reshape (infsup (1:16), 2, 2, 2, 2)(:, 2, 2, 2) == infsup ([15; 16]))
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsup/issingleton.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/issingleton.m
***** assert (issingleton (infsup (0)));
***** assert (issingleton (infsupdec (0)));
***** assert (not (issingleton (entire ())));
***** assert (not (issingleton (intervalpart (entire ()))));
***** assert (not (issingleton (empty ())));
***** assert (not (issingleton (intervalpart (empty ()))));
***** warning assert (not (issingleton (infsupdec (2, 1))));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.isSingleton;
 for testcase = [testcases]'
   assert (isequaln (...
     issingleton (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.isSingleton;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (issingleton (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.isSingleton;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (issingleton (in1), out));
***** test
 # Decorated scalar evaluation
 testcases = testdata.NoSignal.infsupdec.isSingleton;
 for testcase = [testcases]'
   assert (isequaln (...
     issingleton (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Decorated vector evaluation
 testcases = testdata.NoSignal.infsupdec.isSingleton;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (issingleton (in1), out));
***** test
 # Decorated N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.isSingleton;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (issingleton (in1), out));
13 tests, 13 passed, 0 known failure, 0 skipped
[inst/@infsup/precedes.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/precedes.m
***** assert (precedes (infsup (1, 2), infsup (2, 3)));
***** assert (not (precedes (infsup (1, 2.1), infsup (1.9, 3))));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.precedes;
 for testcase = [testcases]'
   assert (isequaln (...
     precedes (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.precedes;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (precedes (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.precedes;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (precedes (in1, in2), out));
5 tests, 5 passed, 0 known failure, 0 skipped
[inst/@infsup/sup.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/sup.m
***** # from the documentation string
***** assert (sup (infsup (2.5, 3.5)), 3.5);
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.sup;
 for testcase = [testcases]'
   assert (isequaln (...
     sup (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.sup;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (sup (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.sup;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (sup (in1), out));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsup/tril.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/tril.m
***** assert (tril (infsup (magic (10))) == tril (magic (10)));
***** assert (tril (infsup (magic (10)), 1) == tril (magic (10), 1));
***** assert (tril (infsup (magic (10)), -1) == tril (magic (10), -1));
***** assert (tril (infsup (magic (10)), 0, "pack") == tril (magic (10), 0, "pack"));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsup/wid.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/wid.m
***** # from the documentation string
***** assert (wid (infsup (2.5, 3.5)), 1);
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.wid;
 for testcase = [testcases]'
   assert (isequaln (...
     wid (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.wid;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (wid (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.wid;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (wid (in1), out));
***** test
 # Decorated scalar evaluation
 testcases = testdata.NoSignal.infsupdec.wid;
 for testcase = [testcases]'
   assert (isequaln (...
     wid (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Decorated vector evaluation
 testcases = testdata.NoSignal.infsupdec.wid;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (wid (in1), out));
***** test
 # Decorated N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.wid;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (wid (in1), out));
7 tests, 7 passed, 0 known failure, 0 skipped
[inst/@infsup/erfc.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/erfc.m
***** # from the documentation string
***** assert (erfc (infsup (1)) == "[0x1.4226162FBDDD4p-3, 0x1.4226162FBDDD5p-3]");
***** # correct use of signed zeros
***** test
 x = erfc (infsup (realmax));
 assert (signbit (inf (x)));
 assert (not (signbit (sup (x))));
2 tests, 2 passed, 0 known failure, 0 skipped
[inst/@infsup/cot.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/cot.m
***** # from the documentation string
***** assert (cot (infsup (1)) == "[0x1.48C05D04E1CFDp-1, 0x1.48C05D04E1CFEp-1]");
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.cot;
 for testcase = [testcases]'
   assert (isequaln (...
     cot (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.cot;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (cot (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.cot;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (cot (in1), out));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsup/log1p.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/log1p.m
***** # from the documentation string
***** assert (log1p (infsup (eps)) == "[0x1.FFFFFFFFFFFFFp-53, 0x1p-52]");
***** # correct use of signed zeros
***** test
 x = log1p (infsup (0));
 assert (signbit (inf (x)));
 assert (not (signbit (sup (x))));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.logp1;
 for testcase = [testcases]'
   assert (isequaln (...
     log1p (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.logp1;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (log1p (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.logp1;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (log1p (in1), out));
5 tests, 5 passed, 0 known failure, 0 skipped
[inst/@infsup/setdiff.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/setdiff.m
***** assert (isempty (setdiff (infsup (), infsup (1, 4))));
***** assert (setdiff (infsup (1, 3), infsup ()) == infsup (1, 3));
***** assert (isempty (setdiff (infsup (1, 3), infsup (-inf, inf))));
***** assert (isempty (setdiff (infsup (1, 3), infsup (1, 4))));
***** assert (setdiff (infsup (-inf, inf), infsup (1, 4)) == infsup (-inf, inf));
***** # from the documentation string
 assert (setdiff (infsup (1, 3), infsup (2, 4)) == infsup (1, 2));
5 tests, 5 passed, 0 known failure, 0 skipped
[inst/@infsup/ndims.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/ndims.m
***** assert (ndims (infsup ([])), 2);
***** assert (ndims (infsup (0)), 2);
***** assert (ndims (infsup (magic (3))), 2);
3 tests, 3 passed, 0 known failure, 0 skipped
[inst/@infsup/linspace.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/linspace.m
***** assert (isequal (linspace (infsup (0), infsup (10), 9), infsup (linspace (0, 10, 9))));
***** # correct use of signed zeros
***** test
 x = linspace (infsup (0), infsup (0));
 assert (all (signbit (inf (x))));
 assert (all (not (signbit (sup (x)))));
2 tests, 2 passed, 0 known failure, 0 skipped
[inst/@infsup/min.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/min.m
***** # from the documentation string
***** assert (min (infsup (2, 3), infsup (1, 2)) == infsup (1, 2));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.min;
 for testcase = [testcases]'
   assert (isequaln (...
     min (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.min;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (min (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.min;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (min (in1, in2), out));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsup/disjoint.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/disjoint.m
***** assert (disjoint (infsup (3, 4), infsup (5, 6)));
***** assert (not (disjoint (infsup (3, 4), infsup (4, 5))));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.disjoint;
 for testcase = [testcases]'
   assert (isequaln (...
     disjoint (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.disjoint;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (disjoint (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.disjoint;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (disjoint (in1, in2), out));
5 tests, 5 passed, 0 known failure, 0 skipped
[inst/@infsup/prod.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/prod.m
***** # from the documentation string
***** assert (prod (infsup (1 : 4)) == 24);
***** assert (prod (infsup ([])) == 1);
***** assert (prod (infsup (magic (3))) == [96, 45, 84]);
***** assert (prod (infsup (magic (3)), 2) == [48; 105; 72]);
***** assert (prod (infsup (magic (3)), 3) == magic (3));
***** assert (prod (prod (reshape (infsup (1:24), 1, 2, 3, 4))) == reshape ([720, 665280, 13366080, 96909120], 1, 1, 1, 4))
6 tests, 6 passed, 0 known failure, 0 skipped
[inst/@infsup/cosh.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/cosh.m
***** # from the documentation string
***** assert (cosh (infsup (1)) == "[0x1.8B07551D9F55, 0x1.8B07551D9F551]");
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.cosh;
 for testcase = [testcases]'
   assert (isequaln (...
     cosh (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.cosh;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (cosh (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.cosh;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (cosh (in1), out));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsup/isentire.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/isentire.m
***** assert (isentire (entire ()));
***** assert (isentire (intervalpart (entire ())));
***** assert (not (isentire (empty ())));
***** assert (not (isentire (intervalpart (empty ()))));
***** warning assert (not (isentire (infsupdec (2, 1))));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.isEntire;
 for testcase = [testcases]'
   assert (isequaln (...
     isentire (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.isEntire;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (isentire (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.isEntire;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (isentire (in1), out));
***** test
 # Decorated scalar evaluation
 testcases = testdata.NoSignal.infsupdec.isEntire;
 for testcase = [testcases]'
   assert (isequaln (...
     isentire (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Decorated vector evaluation
 testcases = testdata.NoSignal.infsupdec.isEntire;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (isentire (in1), out));
***** test
 # Decorated N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.isEntire;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (isentire (in1), out));
11 tests, 11 passed, 0 known failure, 0 skipped
[inst/@infsup/asin.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/asin.m
***** # Empty interval
***** assert (asin (infsup ()) == infsup ());
***** # from the documentation string
***** assert (asin (infsup (.5)) == "[0x1.0C152382D7365p-1, 0x1.0C152382D7366p-1]");
***** # correct use of signed zeros
***** test
 x = asin (infsup (0));
 assert (signbit (inf (x)));
 assert (not (signbit (sup (x))));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.asin;
 for testcase = [testcases]'
   assert (isequaln (...
     asin (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.asin;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (asin (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.asin;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (asin (in1), out));
6 tests, 6 passed, 0 known failure, 0 skipped
[inst/@infsup/resize.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/resize.m
***** assert (resize (infsup (magic (3)), 4, 2) == infsup ([8, 1; 3, 5; 4, 9; 0, 0]));
***** assert (resize (infsup (ones (2, 2, 2)), 4, 1, 2) == infsup (resize (ones (2, 2, 2), 4, 1, 2)))
2 tests, 2 passed, 0 known failure, 0 skipped
[inst/@infsup/acos.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/acos.m
***** # Empty interval
***** assert (acos (infsup ()) == infsup ());
***** # Singleton intervals
***** assert (acos (infsup (-1)) == infsup ("pi"));
***** assert (subset (acos (infsup (-.5)), union ((infsup ("pi") / 2), infsup ("pi"))));
***** assert (acos (infsup (0)) == infsup ("pi") / 2);
***** assert (subset (acos (infsup (.5)), union ((infsup ("pi") / 2), infsup (0))));
***** assert (acos (infsup (1)) == infsup (0));
***** # Bounded intervals
***** assert (acos (infsup (-1, 0)) == union ((infsup ("pi") / 2), infsup ("pi")));
***** assert (acos (infsup (0, 1)) == union ((infsup ("pi") / 2), infsup (0)));
***** assert (acos (infsup (-1, 1)) == infsup (0, "pi"));
***** assert (acos (infsup (-2, 2)) == infsup (0, "pi"));
***** # Unbounded intervals
***** assert (acos (infsup (0, inf)) == union ((infsup ("pi") / 2), infsup (0)));
***** assert (acos (infsup (-inf, 0)) == union ((infsup ("pi") / 2), infsup ("pi")));
***** assert (acos (infsup (-inf, inf)) == infsup (0, "pi"));
***** # from the documentation string
***** assert (acos (infsup (.5)) == "[0x1.0C152382D7365, 0x1.0C152382D7366]");
***** # correct use of signed zeros
***** test
 x = acos (infsup (1));
 assert (signbit (inf (x)));
 assert (not (signbit (sup (x))));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.acos;
 for testcase = [testcases]'
   assert (isequaln (...
     acos (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.acos;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (acos (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.acos;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (acos (in1), out));
18 tests, 18 passed, 0 known failure, 0 skipped
[inst/@infsup/subset.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/subset.m
***** assert (subset (infsup (1, 2), infsup (1, 3)));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.subset;
 for testcase = [testcases]'
   assert (isequaln (...
     subset (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.subset;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (subset (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.subset;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (subset (in1, in2), out));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsup/mid.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/mid.m
***** assert (mid (infsup (-inf, inf)), 0);
***** # from the documentation string
***** assert (mid (infsup (2.5, 3.5)), 3);
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.mid;
 for testcase = [testcases]'
   assert (isequaln (...
     mid (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.mid;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (mid (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.mid;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (mid (in1), out));
***** test
 # Decorated scalar evaluation
 testcases = testdata.NoSignal.infsupdec.mid;
 for testcase = [testcases]'
   assert (isequaln (...
     mid (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Decorated vector evaluation
 testcases = testdata.NoSignal.infsupdec.mid;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (mid (in1), out));
***** test
 # Decorated N-dimensional array evaluation
 testcases = testdata.NoSignal.infsupdec.mid;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (mid (in1), out));
8 tests, 8 passed, 0 known failure, 0 skipped
[inst/@infsup/sqrt.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/sqrt.m
***** # from the documentation string
***** assert (sqrt (infsup (-6, 4)) == infsup (0, 2));
1 test, 1 passed, 0 known failure, 0 skipped
[inst/@infsup/mpower.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/mpower.m
***** # from the documentation string
***** assert (isequal (infsup (magic (3)) ^ 2, infsup (magic (3) ^ 2)));
***** # correct use of signed zeros
***** test
 x = mpower (infsup (eye (2)), 2);
 assert (signbit (inf (x(1, 2))));
 assert (not (signbit (sup (x(1, 2)))));
2 tests, 2 passed, 0 known failure, 0 skipped
[inst/@infsup/rad.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/rad.m
***** test;
 [m, r] = rad (infsup (2.5, 3.5));
 assert (m, 3);
 assert (r, .5);
***** # from the documentation string
***** assert (rad (infsup (2.5, 3.5)), .5);
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.rad;
 for testcase = [testcases]'
   assert (isequaln (...
     rad (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.rad;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (rad (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.rad;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (rad (in1), out));
***** test
 # Decorated scalar evaluation
 testcases = testdata.NoSignal.infsupdec.rad;
 for testcase = [testcases]'
   assert (isequaln (...
     rad (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Decorated vector evaluation
 testcases = testdata.NoSignal.infsupdec.rad;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (rad (in1), out));
***** test
 # Decorated N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.rad;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (rad (in1), out));
8 tests, 8 passed, 0 known failure, 0 skipped
[inst/@infsup/chol.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/chol.m
***** assert (chol (infsup (pascal (10))) == chol (pascal (10)));
***** assert (chol (infsupdec (pascal (10))) == chol (pascal (10)));
***** test
 A = infsup ([2, 1; 1, 1]);
 R = chol (A);
 assert (ismember ([sqrt(2), 1/sqrt(2); 0, 1/sqrt(2)], R));
 assert (wid (R) < 1e-15);
3 tests, 3 passed, 0 known failure, 0 skipped
[inst/@infsup/length.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/length.m
***** assert (length (infsup ([])), 0);
***** assert (length (infsup (0)), 1);
***** assert (length (infsup (zeros (3, 1))), 3);
***** assert (length (infsup (zeros (1, 4))), 4);
***** assert (length (infsup (zeros (3, 4))), 4);
5 tests, 5 passed, 0 known failure, 0 skipped
[inst/@infsup/setxor.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/setxor.m
***** test
 [z, z1, z2] = setxor (infsup (), infsup ());
 assert (isempty (z));
 assert (isempty (z1));
 assert (isempty (z2));
***** test
 [z, z1, z2] = setxor (infsup (-inf, inf), infsup ());
 assert (isentire (z));
 assert (isentire (z1));
 assert (isempty (z2));
***** test
 [z, z1, z2] = setxor (infsup (-inf, inf), infsup (2));
 assert (isentire (z));
 assert (z1 == infsup (-inf, 2));
 assert (z2 == infsup (2, inf));
***** test
 [z, z1, z2] = setxor (infsup (2, 3), infsup (2));
 assert (z == infsup (2, 3));
 assert (z1 == infsup ());
 assert (z2 == infsup (2, 3));
***** test
 [z, z1, z2] = setxor (infsup (2, 3), infsup (2, 2.5));
 assert (z == infsup (2.5, 3));
 assert (z1 == infsup ());
 assert (z2 == infsup (2.5, 3));
***** # from the documentation string
***** test
 [z, z1, z2] = setxor (infsup (1, 3), infsup (2, 4));
 assert (z == infsup (1, 4));
 assert (z1 == infsup (1, 2));
 assert (z2 == infsup (3, 4));
6 tests, 6 passed, 0 known failure, 0 skipped
[inst/@infsup/fzero.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/fzero.m
***** test "from the documentation string";
 f = @(x) cos (x);
 df = @(x) -sin (x);
 zeros = fzero (f, infsup ("[-10, 10]"), df);
 assert (all (subset (pi * (-2.5:1:2.5)', zeros)));
 assert (max (rad (zeros)) < 8 * eps);
 sqr = @(x) x .^ 2;
 zeros = fzero (sqr, infsup ("[Entire]"));
 assert (all (subset (0, zeros)));
 assert (max (rad (zeros)) < eps);
1 test, 1 passed, 0 known failure, 0 skipped
[inst/@infsup/asinh.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/asinh.m
***** # from the documentation string
***** assert (asinh (infsup (1)) == "[0x1.C34366179D426p-1, 0x1.C34366179D427p-1]");
***** # correct use of signed zeros
***** test
 x = asinh (infsup (0));
 assert (signbit (inf (x)));
 assert (not (signbit (sup (x))));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.asinh;
 for testcase = [testcases]'
   assert (isequaln (...
     asinh (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.asinh;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (asinh (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.asinh;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (asinh (in1), out));
5 tests, 5 passed, 0 known failure, 0 skipped
[inst/@infsup/round.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/round.m
***** # Empty interval
***** assert (round (infsup ()) == infsup ());
***** # Singleton intervals
***** assert (round (infsup (0)) == infsup (0));
***** assert (round (infsup (0.5)) == infsup (1));
***** assert (round (infsup (0.25)) == infsup (0));
***** assert (round (infsup (0.75)) == infsup (1));
***** assert (round (infsup (-0.5)) == infsup (-1));
***** # Bounded intervals
***** assert (round (infsup (-0.5, 0)) == infsup (-1, 0));
***** assert (round (infsup (0, 0.5)) == infsup (0, 1));
***** assert (round (infsup (0.25, 0.5)) == infsup (0, 1));
***** assert (round (infsup (-1, 0)) == infsup (-1, 0));
***** assert (round (infsup (-1, 1)) == infsup (-1, 1));
***** assert (round (infsup (-realmin, realmin)) == infsup (0));
***** assert (round (infsup (-realmax, realmax)) == infsup (-realmax, realmax));
***** # Unbounded intervals
***** assert (round (infsup (-realmin, inf)) == infsup (0, inf));
***** assert (round (infsup (-realmax, inf)) == infsup (-realmax, inf));
***** assert (round (infsup (-inf, realmin)) == infsup (-inf, 0));
***** assert (round (infsup (-inf, realmax)) == infsup (-inf, realmax));
***** assert (round (infsup (-inf, inf)) == infsup (-inf, inf));
***** # correct use of signed zeros
***** test
 x = round (infsup (0));
 assert (signbit (inf (x)));
 assert (not (signbit (sup (x))));
***** test
 x = round (infsup (-0.25, 0.25));
 assert (signbit (inf (x)));
 assert (not (signbit (sup (x))));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.roundTiesToAway;
 for testcase = [testcases]'
   assert (isequaln (...
     round (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.roundTiesToAway;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (round (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.roundTiesToAway;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (round (in1), out));
23 tests, 23 passed, 0 known failure, 0 skipped
[inst/@infsup/powrev2.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/powrev2.m
***** # from the documentation string
***** assert (powrev2 (infsup (2, 5), infsup (3, 6)) == "[0x1.5D7E8F22BA886p-1, 0x1.4AE00D1CFDEB5p1]");
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.powRev2;
 for testcase = [testcases]'
   assert (isequaln (...
     powrev2 (testcase.in{1}, testcase.in{2}, testcase.in{3}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.powRev2;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 in3 = vertcat (vertcat (testcases.in){:, 3});
 out = vertcat (testcases.out);
 assert (isequaln (powrev2 (in1, in2, in3), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.powRev2;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 in3 = vertcat (vertcat (testcases.in){:, 3});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 in3 = reshape ([in3; in3(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (powrev2 (in1, in2, in3), out));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsup/exp.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/exp.m
***** # from the documentation string
***** assert (exp (infsup (1)) == infsup ("e"));
***** # correct use of signed zeros
***** test
 x = exp (infsup (-realmax));
 assert (signbit (inf (x)));
 assert (not (signbit (sup (x))));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.exp;
 for testcase = [testcases]'
   assert (isequaln (...
     exp (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.exp;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (exp (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.exp;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (exp (in1), out));
5 tests, 5 passed, 0 known failure, 0 skipped
[inst/@infsup/qr.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/qr.m
***** test
 A = infsup ([1 2 3; 4 5 6]);
 [Q, R] = qr (A);
 assert (all (all (subset (A, Q * R))));
 assert (all (all (subset (eye (length (Q)), Q' * Q))));
 assert (max (max (wid (Q))) < 1e-14);
***** test
 A = infsup ([1 2; 3 4; 5 6]);
 [Q, R] = qr (A);
 assert (all (all (subset (A, Q * R))));
 assert (all (all (subset (eye (length (Q)), Q' * Q))));
 assert (max (max (wid (Q (:, [1 2])))) < 1e-14);
***** test
 A = infsup ([1 2 3; 4 9 6; 9 8 7]);
 [Q, R] = qr (A);
 assert (all (all (subset (A, Q * R))));
 assert (all (all (subset (eye (length (Q)), Q' * Q))));
 assert (max (max (wid (Q))) < 1e-13);
***** test
 for n = 3 : 2 : 10
   A = infsup (magic (n));
   [Q, R] = qr (A);
   assert (all (all (subset (A, Q * R))));
   assert (all (all (subset (eye (length (Q)), Q' * Q))));
   assert (max (max (wid (Q))) < 1e-10);
 endfor
***** test
 A = infsup (magic (3)) + "[2, 2.2]";
 [Q, R] = qr (A);
 assert (all (all (subset (A, Q * R))));
 assert (all (all (subset (eye (length (Q)), Q' * Q))));
 assert (max (max (wid (Q))) < 1.5);
***** function result = is_permutation_matrix (P)
 result = isequal (P, eye (length (P))) || ...
          isequal (typeinfo (P), "permutation matrix");
***** endfunction
***** test
 A = infsup ([1 2 3; 4 5 6]);
 [Q, R, P] = qr (A);
 assert (all (all (subset (A, Q * R * P))));
 assert (all (all (subset (eye (length (Q)), Q' * Q))));
 assert (max (max (wid (Q))) < 1e-14);
 assert (is_permutation_matrix (P));
***** test
 A = infsup ([1 2; 3 4; 5 6]);
 [Q, R, P] = qr (A);
 assert (all (all (subset (A, Q * R * P))));
 assert (all (all (subset (eye (length (Q)), Q' * Q))));
 assert (max (max (wid (Q (:, [1 2])))) < 1e-14);
 assert (is_permutation_matrix (P));
***** test
 A = infsup ([1 2 3; 4 9 6; 9 8 7]);
 [Q, R, P] = qr (A);
 assert (all (all (subset (A, Q * R * P))));
 assert (all (all (subset (eye (length (Q)), Q' * Q))));
 assert (max (max (wid (Q))) < 1e-13);
 assert (is_permutation_matrix (P));
***** test
 for n = 3 : 2 : 10
   A = infsup (magic (n));
   [Q, R, P] = qr (A);
   assert (all (all (subset (A, Q * R * P))));
   assert (all (all (subset (eye (length (Q)), Q' * Q))));
   assert (max (max (wid (Q))) < 1e-10);
   assert (is_permutation_matrix (P));
 endfor
***** test
 A = infsup (magic (3)) + "[2, 2.2]";
 [Q, R, P] = qr (A);
 assert (all (all (subset (A, Q * R * P))));
 assert (all (all (subset (eye (length (Q)), Q' * Q))));
 assert (max (max (wid (Q))) < 1.5);
 assert (is_permutation_matrix (P));
10 tests, 10 passed, 0 known failure, 0 skipped
[inst/@infsup/log2.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/log2.m
***** # from the documentation string
***** assert (log2 (infsup (2)) == 1);
***** # correct use of signed zeros
***** test
 x = log2 (infsup (1));
 assert (signbit (inf (x)));
 assert (not (signbit (sup (x))));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.log2;
 for testcase = [testcases]'
   assert (isequaln (...
     log2 (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.log2;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (log2 (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.log2;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (log2 (in1), out));
5 tests, 5 passed, 0 known failure, 0 skipped
[inst/@infsup/bitunpack.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/bitunpack.m
***** test;
  littleendian = bitunpack (uint16 (1))(1);
  b = zeros (1, 128);
  if (littleendian)
    b([52, 63, 117, 127]) = 1;
  else
    b([7, 12, 71, 77]) = 1;
  endif
  assert (bitunpack (infsup (3, 4)), logical (b));
1 test, 1 passed, 0 known failure, 0 skipped
[inst/@infsup/uplus.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/uplus.m
***** # from the documentation string
***** assert (+infsup (2, 3) == infsup (2, 3));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.pos;
 for testcase = [testcases]'
   assert (isequaln (...
     uplus (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.pos;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (uplus (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.pos;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (uplus (in1), out));
***** test
 # Decorated scalar evaluation
 testcases = testdata.NoSignal.infsupdec.pos;
 for testcase = [testcases]'
   assert (isequaln (...
     uplus (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Decorated vector evaluation
 testcases = testdata.NoSignal.infsupdec.pos;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (uplus (in1), out));
***** test
 # Decorated N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.pos;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (uplus (in1), out));
7 tests, 7 passed, 0 known failure, 0 skipped
[inst/@infsup/isscalar.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/isscalar.m
***** assert (not (isscalar (infsup ([]))));
***** assert (isscalar (infsup (0)));
***** assert (not (isscalar (infsup (zeros (1, 2)))));
***** assert (not (isscalar (infsup (zeros (2, 1)))));
***** assert (not (isscalar (infsup (zeros (5)))));
5 tests, 5 passed, 0 known failure, 0 skipped
[inst/@infsup/minus.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/minus.m
***** # from the documentation string
***** assert (infsup (2, 3) - infsup (1, 2) == infsup (0, 2));
***** # correct use of signed zeros
***** test
 x = minus (infsup (0), infsup (0));
 assert (signbit (inf (x)));
 assert (not (signbit (sup (x))));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.sub;
 for testcase = [testcases]'
   assert (isequaln (...
     minus (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.sub;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (minus (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.sub;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (minus (in1, in2), out));
5 tests, 5 passed, 0 known failure, 0 skipped
[inst/@infsup/mig.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/mig.m
***** assert (mig (infsup (-1, 2)), 0);
***** assert (mig (infsup (-42, -23)), 23);
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.mig;
 for testcase = [testcases]'
   assert (isequaln (...
     mig (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.mig;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (mig (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.mig;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (mig (in1), out));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.mig;
 for testcase = [testcases]'
   assert (isequaln (...
     mig (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.mig;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (mig (in1), out));
***** test
 # Decorated N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.mig;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (mig (in1), out));
8 tests, 8 passed, 0 known failure, 0 skipped
[inst/@infsup/expm1.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/expm1.m
***** # from the documentation string
***** assert (expm1 (infsup (eps)) == "[0x1p-52, 0x1.0000000000001p-52]");
***** # correct use of signed zeros
***** test
 x = expm1 (infsup (0));
 assert (signbit (inf (x)));
 assert (not (signbit (sup (x))));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.expm1;
 for testcase = [testcases]'
   assert (isequaln (...
     expm1 (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.expm1;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (expm1 (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.expm1;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (expm1 (in1), out));
5 tests, 5 passed, 0 known failure, 0 skipped
[inst/@infsup/interior.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/interior.m
***** assert (interior (infsup (1, 2), infsup (0, 3)));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.interior;
 for testcase = [testcases]'
   assert (isequaln (...
     interior (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.interior;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (interior (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.interior;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (interior (in1, in2), out));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsup/tanh.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/tanh.m
***** # from the documentation string
***** assert (tanh (infsup (1)) == "[0x1.85EFAB514F394p-1, 0x1.85EFAB514F395p-1]");
***** # correct use of signed zeros
***** test
 x = tanh (infsup (0));
 assert (signbit (inf (x)));
 assert (not (signbit (sup (x))));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.tanh;
 for testcase = [testcases]'
   assert (isequaln (...
     tanh (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.tanh;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (tanh (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.tanh;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (tanh (in1), out));
5 tests, 5 passed, 0 known failure, 0 skipped
[inst/@infsup/log.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/log.m
***** # from the documentation string
***** assert (log (infsup (2)) == "[0x1.62E42FEFA39EFp-1, 0x1.62E42FEFA39Fp-1]");
***** # correct use of signed zeros
***** test
 x = log (infsup (1));
 assert (signbit (inf (x)));
 assert (not (signbit (sup (x))));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.log;
 for testcase = [testcases]'
   assert (isequaln (...
     log (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.log;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (log (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.log;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (log (in1), out));
5 tests, 5 passed, 0 known failure, 0 skipped
[inst/ctc_union.m]
>>>>> /<<PKGBUILDDIR>>/inst/ctc_union.m
***** function [fval, cx] = ctc_sin (y, x)
  fval = sin (x);
  y = intersect (y, fval);
  cx = sinrev (y, x);
***** endfunction
***** function [fval, cx] = ctc_cos (y, x)
  fval = cos (x);
  y = intersect (y, fval);
  cx = cosrev (y, x);
***** endfunction
***** shared c
  c = ctc_union (@ctc_sin, 0, @ctc_cos, 0);
***** test
  x = infsup (0);
  y = infsup (0);
  [fval, cx] = c (y, x);
  assert (fval == 0);
  assert (cx == 0)
***** test
  x = infsup ("pi") / 2;
  y = infsup (0);
  [fval, cx] = c (y, x);
  assert (fval == "[0, 1]");
  assert (cx == x);
***** test
  x = infsup ("pi") / 4;
  y = infsup (0);
  [fval, cx] = c (y, x);
  assert (fval > 0);
  assert (isempty (cx));
***** test
  x = infsup (0, eps);
  y = infsup (0);
  [fval, cx] = c (y, x);
  assert (fval == "[0, 1]");
  assert (cx == 0);
***** test
  x = infsup ("[0, pi]") / 2;
  y = infsup (0);
  [fval, cx] = c (y, x);
  assert (fval == "[0, 1]");
  assert (cx == x);
5 tests, 5 passed, 0 known failure, 0 skipped
[inst/interval_bitpack.m]
>>>>> /<<PKGBUILDDIR>>/inst/interval_bitpack.m
***** test "bare";
  littleendian = bitunpack (uint16 (1))(1);
  b = zeros (1, 128);
  if (littleendian)
    b([52, 63, 117, 127]) = 1;
  else
    b([7, 12, 71, 77]) = 1;
  endif
  decoded = interval_bitpack (logical (b));
  assert (eq (decoded, infsup (3, 4)));
***** test "decorated";
  littleendian = bitunpack (uint16 (1))(1);
  b = zeros (1, 136);
  if (littleendian)
    b([52, 63, 117, 127, 133]) = 1;
  else
    b([7, 12, 71, 77, 133]) = 1;
  endif
  decoded = interval_bitpack (logical (b));
  assert (eq (decoded, infsupdec (3, 4)));
2 tests, 2 passed, 0 known failure, 0 skipped
[inst/__split_interval_literals__.m]
>>>>> /<<PKGBUILDDIR>>/inst/__split_interval_literals__.m
***** assert (__split_interval_literals__ (""), {""});
***** assert (__split_interval_literals__ (","), {""});
***** assert (__split_interval_literals__ ("1"), {"1"});
***** assert (__split_interval_literals__ ("1?"), {"1?"});
***** assert (__split_interval_literals__ ("1?u"), {"1?u"});
***** assert (__split_interval_literals__ ("1?u3"), {"1?u3"});
***** assert (__split_interval_literals__ ("[Empty]"), {"[Empty]"});
***** assert (__split_interval_literals__ ("[Entire]"), {"[Entire]"});
***** assert (__split_interval_literals__ ("[]"), {"[]"});
***** assert (__split_interval_literals__ ("[,]"), {"[,]"});
***** assert (__split_interval_literals__ ("[1]"), {"[1]"});
***** assert (__split_interval_literals__ ("[1,2]"), {"[1,2]"});
***** assert (__split_interval_literals__ ("1             2"), {"1", "2"});
***** assert (__split_interval_literals__ ("1, , , , , , ,2"), {"1", "2"});
***** assert (__split_interval_literals__ ("1;;2"), {"1"; ""; "2"});
***** assert (__split_interval_literals__ ("1; ;2"), {"1"; ""; "2"});
***** assert (__split_interval_literals__ ("[1,2] [3,4]"), {"[1,2]", "[3,4]"});
***** assert (__split_interval_literals__ ("[1,2],[3,4]"), {"[1,2]", "[3,4]"});
***** assert (__split_interval_literals__ ("[1,2], [3,4]"), {"[1,2]", "[3,4]"});
***** assert (__split_interval_literals__ ("[1,2]\n[3,4]"), {"[1,2]"; "[3,4]"});
***** assert (__split_interval_literals__ ("[1,2];[3,4]"), {"[1,2]"; "[3,4]"});
***** assert (__split_interval_literals__ ("[1,2]; [3,4]"), {"[1,2]"; "[3,4]"});
***** assert (__split_interval_literals__ (["[1,2]"; "[3,4]"]), {"[1,2]"; "[3,4]"});
***** assert (__split_interval_literals__ ("1 [3,4]"), {"1", "[3,4]"});
***** assert (__split_interval_literals__ ("1,[3,4]"), {"1", "[3,4]"});
***** assert (__split_interval_literals__ ("1, [3,4]"), {"1", "[3,4]"});
***** assert (__split_interval_literals__ ("1\n[3,4]"), {"1"; "[3,4]"});
***** assert (__split_interval_literals__ ("1;[3,4]"), {"1"; "[3,4]"});
***** assert (__split_interval_literals__ ("1; [3,4]"), {"1"; "[3,4]"});
***** assert (__split_interval_literals__ (["1"; "[3,4]"]), {"1"; "[3,4]"});
***** assert (__split_interval_literals__ ("[1,2] 3"), {"[1,2]", "3"});
***** assert (__split_interval_literals__ ("[1,2],3"), {"[1,2]", "3"});
***** assert (__split_interval_literals__ ("[1,2], 3"), {"[1,2]", "3"});
***** assert (__split_interval_literals__ ("[1,2]\n3"), {"[1,2]"; "3"});
***** assert (__split_interval_literals__ ("[1,2];3"), {"[1,2]"; "3"});
***** assert (__split_interval_literals__ ("[1,2]; 3"), {"[1,2]"; "3"});
***** assert (__split_interval_literals__ (["[1,2]"; "3"]), {"[1,2]"; "3"});
***** assert (__split_interval_literals__ ("1 3"), {"1", "3"});
***** assert (__split_interval_literals__ ("1,3"), {"1", "3"});
***** assert (__split_interval_literals__ ("1, 3"), {"1", "3"});
***** assert (__split_interval_literals__ ("1\n3"), {"1"; "3"});
***** assert (__split_interval_literals__ ("1;3"), {"1"; "3"});
***** assert (__split_interval_literals__ ("1; 3"), {"1"; "3"});
***** assert (__split_interval_literals__ (["1"; "3"]), {"1"; "3"});
***** assert (__split_interval_literals__ ("[1,2] [3,4] [5,6]"), {"[1,2]", "[3,4]", "[5,6]"});
***** assert (__split_interval_literals__ ("[1,2],[3,4],[5,6]"), {"[1,2]", "[3,4]", "[5,6]"});
***** assert (__split_interval_literals__ ("[1,2], [3,4], [5,6]"), {"[1,2]", "[3,4]", "[5,6]"});
***** assert (__split_interval_literals__ ("[1,2]\n[3,4];[5,6]"), {"[1,2]"; "[3,4]"; "[5,6]"});
***** assert (__split_interval_literals__ ("[1,2];[3,4] [5,6]"), {"[1,2]", "[Empty]"; "[3,4]", "[5,6]"});
***** assert (__split_interval_literals__ ("[1,2] [3,4];[5,6]"), {"[1,2]", "[3,4]"; "[5,6]", "[Empty]"});
***** assert (__split_interval_literals__ ("1 [3,4] [5,6]"), {"1", "[3,4]", "[5,6]"});
***** assert (__split_interval_literals__ ("1,[3,4],[5,6]"), {"1", "[3,4]", "[5,6]"});
***** assert (__split_interval_literals__ ("1, [3,4], [5,6]"), {"1", "[3,4]", "[5,6]"});
***** assert (__split_interval_literals__ ("1\n[3,4];[5,6]"), {"1"; "[3,4]"; "[5,6]"});
***** assert (__split_interval_literals__ ("1;[3,4] [5,6]"), {"1", "[Empty]"; "[3,4]", "[5,6]"});
***** assert (__split_interval_literals__ ("1 [3,4];[5,6]"), {"1", "[3,4]"; "[5,6]", "[Empty]"});
***** assert (__split_interval_literals__ ("[1,2] 3 [5,6]"), {"[1,2]", "3", "[5,6]"});
***** assert (__split_interval_literals__ ("[1,2],3,[5,6]"), {"[1,2]", "3", "[5,6]"});
***** assert (__split_interval_literals__ ("[1,2], 3, [5,6]"), {"[1,2]", "3", "[5,6]"});
***** assert (__split_interval_literals__ ("[1,2]\n3;[5,6]"), {"[1,2]"; "3"; "[5,6]"});
***** assert (__split_interval_literals__ ("[1,2];3 [5,6]"), {"[1,2]", "[Empty]"; "3", "[5,6]"});
***** assert (__split_interval_literals__ ("[1,2] 3;[5,6]"), {"[1,2]", "3"; "[5,6]", "[Empty]"});
***** assert (__split_interval_literals__ ("[1,2] [3,4] 5"), {"[1,2]", "[3,4]", "5"});
***** assert (__split_interval_literals__ ("[1,2],[3,4],5"), {"[1,2]", "[3,4]", "5"});
***** assert (__split_interval_literals__ ("[1,2], [3,4], 5"), {"[1,2]", "[3,4]", "5"});
***** assert (__split_interval_literals__ ("[1,2]\n[3,4];5"), {"[1,2]"; "[3,4]"; "5"});
***** assert (__split_interval_literals__ ("[1,2];[3,4] 5"), {"[1,2]", "[Empty]"; "[3,4]", "5"});
***** assert (__split_interval_literals__ ("[1,2] [3,4];5"), {"[1,2]", "[3,4]"; "5", "[Empty]"});
***** assert (__split_interval_literals__ ("1 [3,4] 5"), {"1", "[3,4]", "5"});
***** assert (__split_interval_literals__ ("1,[3,4],5"), {"1", "[3,4]", "5"});
***** assert (__split_interval_literals__ ("1, [3,4], 5"), {"1", "[3,4]", "5"});
***** assert (__split_interval_literals__ ("1\n[3,4];5"), {"1"; "[3,4]"; "5"});
***** assert (__split_interval_literals__ ("1;[3,4] 5"), {"1", "[Empty]"; "[3,4]", "5"});
***** assert (__split_interval_literals__ ("1 [3,4];5"), {"1", "[3,4]"; "5", "[Empty]"});
***** assert (__split_interval_literals__ ("1 3 [5,6]"), {"1", "3", "[5,6]"});
***** assert (__split_interval_literals__ ("1,3,[5,6]"), {"1", "3", "[5,6]"});
***** assert (__split_interval_literals__ ("1, 3, [5,6]"), {"1", "3", "[5,6]"});
***** assert (__split_interval_literals__ ("1\n3;[5,6]"), {"1"; "3"; "[5,6]"});
***** assert (__split_interval_literals__ ("1;3 [5,6]"), {"1", "[Empty]"; "3", "[5,6]"});
***** assert (__split_interval_literals__ ("1 3;[5,6]"), {"1", "3"; "[5,6]", "[Empty]"});
***** assert (__split_interval_literals__ ("[1,2] 3 5"), {"[1,2]", "3", "5"});
***** assert (__split_interval_literals__ ("[1,2],3,5"), {"[1,2]", "3", "5"});
***** assert (__split_interval_literals__ ("[1,2], 3, 5"), {"[1,2]", "3", "5"});
***** assert (__split_interval_literals__ ("[1,2]\n3;5"), {"[1,2]"; "3"; "5"});
***** assert (__split_interval_literals__ ("[1,2];3 5"), {"[1,2]", "[Empty]"; "3", "5"});
***** assert (__split_interval_literals__ ("[1,2] 3;5"), {"[1,2]", "3"; "5", "[Empty]"});
***** assert (__split_interval_literals__ ("1 3 5"), {"1", "3", "5"});
***** assert (__split_interval_literals__ ("1,3,5"), {"1", "3", "5"});
***** assert (__split_interval_literals__ ("1, 3, 5"), {"1", "3", "5"});
***** assert (__split_interval_literals__ ("1\n3;5"), {"1"; "3"; "5"});
***** assert (__split_interval_literals__ ("1;3 5"), {"1", "[Empty]"; "3", "5"});
***** assert (__split_interval_literals__ ("1 3;5"), {"1", "3"; "5", "[Empty]"});
92 tests, 92 passed, 0 known failure, 0 skipped
[inst/hull.m]
>>>>> /<<PKGBUILDDIR>>/inst/hull.m
***** assert (isnai (hull (nai)));
***** assert (isempty (hull (nan)));
***** assert (isequal (hull (2, nan, 3, 5), infsupdec (2, 5, "trv")));
***** assert (isequal (hull ([1, 2, 3], [5; 0; 2]), infsupdec ([1, 2, 3; 0, 0, 0; 1, 2, 2], [5, 5, 5; 1, 2, 3; 2, 2, 3], "com")));
***** assert (isequal (hull (magic (3), 10), infsupdec (magic (3), 10 (ones (3)), "com")));
***** assert (isequal (hull (2, magic (3), [nan, 2, 3; nan, 1, 1; 99, 100, nan]), infsupdec ([2, 1, 2; 2, 1, 1; 2, 2, 2], [8, 2, 6; 3, 5, 7; 99, 100, 2], {"trv", "com", "com"; "trv", "com", "com"; "com", "com", "trv"})));
***** assert (isnai (hull ([nai, 2])), logical ([1 0]));
***** assert (isnai (hull ([nai, 2], [nai, 3])), logical ([1 0]));
***** assert (isnai (hull ([nai, 2], nai)), logical ([1 1]));
***** assert (isnai (hull ([nai, 2], [2, nai])), logical ([1 1]));
***** assert (isequal (hull (zeros (2, 2, 2, 2), ones (2, 2, 2, 2)), infsupdec (zeros (2, 2, 2, 2), ones (2, 2, 2, 2))))
***** assert (isequal (hull (zeros (2, 1, 4, 1), ones (1, 3, 1, 5), -1), infsupdec (-ones (2, 3, 4, 5), ones (2, 3, 4, 5))))
***** assert (isnai (hull (zeros (2, 2, 2, 2), ones (2, 2, 2, 2), nai)), logical (ones (2, 2, 2, 2)))
***** error <dimensions mismatch> hull (1:2, 1:3);
***** error <dimensions mismatch> hull ((1:2)', (1:3)');
***** error <dimensions mismatch> hull (ones (2, 2, 2), ones (2, 2, 3));
***** test "from the documentation string";
 assert (isequal (hull (1, 2, 3, 4), infsupdec (1, 4, "com")));
 assert (isequal (hull (empty, entire), infsupdec (-inf, inf, "trv")));
 assert (isequal (hull ("0.1", "pi", "e"), infsupdec (0.1 - eps / 16, pi + eps * 2, "com")));
 assert (isequal (hull ("[0, 3]", "[4, 7]"), infsupdec ("[0, 7]_com")));
17 tests, 17 passed, 0 known failure, 0 skipped
[inst/ctc_intersect.m]
>>>>> /<<PKGBUILDDIR>>/inst/ctc_intersect.m
***** function [fval, x] = ctc_abs (y, x)
    fval = abs (x);
    x = absrev (intersect (fval, y), x);
***** endfunction
***** shared c
  c = ctc_intersect (@ctc_abs, "[0, 2]", @ctc_abs, "[1, 3]");
***** test
 [fval, x] = c (infsup (0), infsup ("[1, 3]"));
 assert (ismember (0, fval) && 0 != fval);
 assert (x == infsup ("[1, 2]"));
***** test
 [fval, x] = c (infsup (0), infsup ("[1, 2]"));
 assert (0 == fval);
 assert (x == infsup ("[1, 2]"));
***** test
 [fval, x] = c (infsup (0), infsup ("[entire]"));
 assert (ismember (0, fval) && 0 != fval);
 assert (x == infsup ("[-2, 2]"));
***** test
 [fval, x] = c (infsup (0), infsup ("[0, inf]"));
 assert (ismember (0, fval) && 0 != fval);
 assert (x == infsup ("[1, 2]"));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/verlinprog.m]
>>>>> /<<PKGBUILDDIR>>/inst/verlinprog.m
***** test
 A = [-2, -3; -2, -1];
 b = [-1500, -1000];
 c = [1; 1];
 [flag, x, y, h] = verlinprog (A, b, c);
 assert (flag, "verified optimum");
 assert (ismember ([375; 250], x));
 assert (wid (x) < 1e-12);
 assert (ismember ([-0.25; -0.25], y));
 assert (wid (y) < 1e-16);
 assert (ismember (625, h));
 assert (wid (h) < 1e-12);
1 test, 1 passed, 0 known failure, 0 skipped
[inst/exacttointerval.m]
>>>>> /<<PKGBUILDDIR>>/inst/exacttointerval.m
***** assert (isempty (exacttointerval ("[Empty]")));
***** assert (isentire (exacttointerval ("[Entire]")));
***** test "common interval";
 y = exacttointerval ("[0, 1]");
 assert (inf (y), 0);
 assert (sup (y), 1);
***** test "point interval";
 y = exacttointerval ("[42]");
 assert (inf (y), 42);
 assert (sup (y), 42);
***** test "unbound interval";
 y = exacttointerval ("[-4, Infinity]");
 assert (inf (y), -4);
 assert (sup (y), inf);
***** error exacttointerval ("[0, 0.1]");
***** error exacttointerval ("[1, 0]");
***** test "N-dimensional array";
 i = infsup (reshape (1:24, 2, 3, 4));
 assert (exacttointerval (intervaltoexact (i)) == i);
8 tests, 8 passed, 0 known failure, 0 skipped
[inst/vereigback.m]
>>>>> /<<PKGBUILDDIR>>/inst/vereigback.m
***** test
 [lambda, X, ep] = vereigback (eye (2));
 assert (lambda, [1; 1]);
 assert (X, eye (2));
 assert (ep, zeros (2, 1));
***** test
 [lambda, X, ep] = vereigback ([2 1; 1 2]);
 assert (lambda, [1; 3]);
 assert (X, [-1 1; 1 1] ./ sqrt (2), eps);
 assert (ep, zeros (2, 1));
***** test
 [lambda, X, ep] = vereigback ([2 0 0; 0 3 4; 0 4 9]);
 assert (lambda, [1; 2; 11]);
 assert (ep, zeros (3, 1));
***** test
 [lambda, X, ep] = vereigback ([1 2 3; 0 1 2; 1 1 1]);
 assert (max (ep) < 1e-14);
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/__check_crlibm__.m]
>>>>> /<<PKGBUILDDIR>>/inst/__check_crlibm__.m
***** assert (__check_crlibm__ ());
!!!!! test failed
assert (__check_crlibm__ ()) failed
1 test, 0 passed, 0 known failure, 0 skipped
[inst/entire.m]
>>>>> /<<PKGBUILDDIR>>/inst/entire.m
***** assert (inf (entire ()), -inf);
***** assert (sup (entire ()), inf);
***** assert (decorationpart (entire ()), {"dac"});
***** assert (inf (entire (5)), -inf (5));
***** assert (sup (entire (5)), inf (5));
***** assert (strcmp (decorationpart (entire (5)), "dac"), true (5));
***** assert (inf (entire (5, 6)), -inf (5, 6));
***** assert (sup (entire (5, 6)), inf (5, 6));
***** assert (strcmp (decorationpart (entire (5, 6)), "dac"), true (5, 6));
***** assert (inf (entire (5, 6, 7)), -inf (5, 6, 7));
***** assert (sup (entire (5, 6, 7)), inf (5, 6, 7));
***** assert (strcmp (decorationpart (entire (5, 6, 7)), "dac"), true (5, 6, 7));
12 tests, 12 passed, 0 known failure, 0 skipped
[inst/verintlinineqs.m]
>>>>> /<<PKGBUILDDIR>>/inst/verintlinineqs.m
***** test
 A = [-2, -3; -2, -1];
 b = [-1500; -1000];
 [x, As] = verintlinineqs (A, b);
 assert (x, [375; 250], 1e-9);
 assert (all (x >= [375; 250]));
 assert (all (all (isempty (As))));
1 test, 1 passed, 0 known failure, 0 skipped
[inst/@infsupdec/mulrev.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/mulrev.m
***** # IEEE Std 1788-2015 mulRevToPair examples
***** test
  [u, v] = mulrev (infsupdec (0), infsupdec (1, 2));
  assert (isempty (u) & isempty (v));
***** test
  [u, v] = mulrev (infsupdec (0), infsupdec (0, 1));
  assert (isentire (u) & isempty (v));
***** test
  [u, v] = mulrev (infsupdec (1), infsupdec (1, 2));
  assert (isequal (u, infsupdec (1, 2)) & isempty (v));
***** test
  [u, v] = mulrev (infsupdec (1, inf), infsupdec (1));
  assert (isequal (u, infsupdec (0, 1, "dac")) & isempty (v));
***** test
  [u, v] = mulrev (infsupdec (-1, 1), infsupdec (1, 2));
  assert (isequal (u, infsupdec (-inf, -1, "trv")) & isequal (v, infsupdec (1, inf, "trv")));
***** test
  [u, v] = mulrev (infsupdec (-inf, inf), infsupdec (1));
  assert (isequal (u, infsupdec (-inf, 0, "trv")) & isequal (v, infsupdec (0, inf, "trv")));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.mulRevToPair1;
 for testcase = [testcases]'
   assert (isequaln (...
     nthargout (1, 2, @mulrev, testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.mulRevToPair1;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (nthargout (1, 2, @mulrev, in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsupdec.mulRevToPair1;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (nthargout (1, 2, @mulrev, in1, in2), out));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.mulRevToPair2;
 for testcase = [testcases]'
   assert (isequaln (...
     nthargout (2, @mulrev, testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.mulRevToPair2;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (nthargout (2, @mulrev, in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsupdec.mulRevToPair2;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (nthargout (2, @mulrev, in1, in2), out));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.mulRev;
 for testcase = [testcases]'
   assert (isequaln (...
     mulrev (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.mulRev;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (mulrev (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsupdec.mulRev;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (mulrev (in1, in2), out));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.mulRevTen;
 for testcase = [testcases]'
   assert (isequaln (...
     mulrev (testcase.in{1}, testcase.in{2}, testcase.in{3}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.mulRevTen;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 in3 = vertcat (vertcat (testcases.in){:, 3});
 out = vertcat (testcases.out);
 assert (isequaln (mulrev (in1, in2, in3), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsupdec.mulRevTen;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 in3 = vertcat (vertcat (testcases.in){:, 3});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 in3 = reshape ([in3; in3(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (mulrev (in1, in2, in3), out));
18 tests, 18 passed, 0 known failure, 0 skipped
[inst/@infsupdec/prepad.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/prepad.m
***** assert (isequal (prepad (infsupdec (2:4), 4, 1), infsupdec (1:4)));
***** assert (isequal (prepad (infsupdec (0:2), 2, 1), infsupdec (1:2)));
***** test
 if (compare_versions (OCTAVE_VERSION (), "4.0.0", ">="))
   assert (isequal (prepad (infsupdec (0), 10, 0, 3), infsupdec (zeros (1, 1, 10))));
 else
   # In Octave 3.8.x it is not possible to increase the number of dimensions.
 endif
***** assert (isequal (prepad (infsupdec (zeros (1, 2, 2)), 3), infsupdec (zeros (1, 3, 2))));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsupdec/factorial.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/factorial.m
***** # from the documentation string
***** assert (isequal (factorial (infsupdec (6)), infsupdec (720)));
***** assert (isequal (factorial (infsupdec (0)), infsupdec (1)));
***** assert (isequal (factorial (infsupdec ("[0, 1.99]")), infsupdec (1, "trv")));
***** assert (isequal (factorial (infsupdec ("[0, 2]")), infsupdec (1, 2, "trv")));
***** assert (isequal (factorial (infsupdec ("[1.4, 1.6]")), empty ()));
***** assert (isequal (factorial (infsupdec (23)), infsupdec ("[0x1.5e5c335f8a4cdp+74, 0x1.5e5c335f8a4cep+74]_com")));
***** assert (isequal (factorial (infsupdec (171)), infsupdec ("[0x1.fffffffffffffp+1023, Inf]_dac")));
7 tests, 7 passed, 0 known failure, 0 skipped
[inst/@infsupdec/pow2.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/pow2.m
***** # from the documentation string
***** assert (isequal (pow2 (infsupdec (5)), infsupdec (32)));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.exp2;
 for testcase = [testcases]'
   assert (isequaln (...
     pow2 (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.exp2;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (pow2 (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsupdec.exp2;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2 | i == numel (in1))
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (pow2 (in1), out));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsupdec/ceil.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/ceil.m
***** # from the documentation string
***** assert (isequal (ceil (infsupdec (2.5, 3.5)), infsupdec (3, 4, "def")));
***** assert (isequal (ceil (infsupdec (-.5, 5)), infsupdec (0, 5, "def")));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.ceil;
 for testcase = [testcases]'
   assert (isequaln (...
     ceil (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.ceil;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (ceil (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.ceil;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (ceil (in1), out));
5 tests, 5 passed, 0 known failure, 0 skipped
[inst/@infsupdec/mtimes.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/mtimes.m
***** assert (isequal (infsupdec ([1, 2; 7, 15], [2, 2; 7.5, 15], {"com", "def"; "dac", "com"}) * infsupdec ([3, 3; 0, 1], [3, 3.25; 0, 2]), infsupdec ([3, 5; 21, 36], [6, 10.5; 22.5, 54.375], {"def", "def"; "dac", "dac"})));
***** # from the documentation string
***** assert (isequal (infsupdec ([1, 2; 7, 15], [2, 2; 7.5, 15]) * infsupdec ([3, 3; 0, 1], [3, 3.25; 0, 2]), infsupdec ([3, 5; 21, 36], [6, 10.5; 22.5, 54.375])));
2 tests, 2 passed, 0 known failure, 0 skipped
[inst/@infsupdec/cosrev.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/cosrev.m
***** # from the documentation string
***** assert (isequal (cosrev (0, infsupdec (6, 9)), infsupdec ("[0x1.F6A7A2955385Ep2, 0x1.F6A7A2955386p2]_trv")));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.cosRev;
 for testcase = [testcases]'
   assert (isequaln (...
     cosrev (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.cosRev;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (cosrev (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsupdec.cosRev;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (cosrev (in1), out));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.cosRevBin;
 for testcase = [testcases]'
   assert (isequaln (...
     cosrev (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.cosRevBin;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (cosrev (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsupdec.cosRevBin;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (cosrev (in1, in2), out));
7 tests, 7 passed, 0 known failure, 0 skipped
[inst/@infsupdec/tanrev.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/tanrev.m
***** # from the documentation string
***** assert (isequal (tanrev (infsupdec (0), infsupdec (2, 4)), infsupdec ("pi", "trv")));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.tanRev;
 for testcase = [testcases]'
   assert (isequaln (...
     tanrev (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.tanRev;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (tanrev (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsupdec.tanRev;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (tanrev (in1), out));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.tanRevBin;
 for testcase = [testcases]'
   assert (isequaln (...
     tanrev (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.tanRevBin;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (tanrev (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsupdec.tanRevBin;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (tanrev (in1, in2), out));
7 tests, 7 passed, 0 known failure, 0 skipped
[inst/@infsupdec/isnai.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/isnai.m
***** assert (isnai (infsupdec ("[nai]")));
***** assert (not (isnai (infsupdec (2, 3))));
***** warning assert (isnai (infsupdec ("happy 42 hacking")), logical ([1 0 1]));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.isNaI;
 for testcase = [testcases]'
   assert (isequaln (...
     isnai (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.isNaI;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (isnai (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsupdec.isNaI;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (isnai (in1), out));
6 tests, 6 passed, 0 known failure, 0 skipped
[inst/@infsupdec/dilog.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/dilog.m
***** assert (isequal (dilog (infsupdec (-inf, inf)), infsupdec ("[-Inf, +0x1.3BD3CC9BE45DFp1]_dac")));
***** # from the documentation string
***** assert (isequal (dilog (infsupdec (1)), infsupdec ("[0x1.A51A6625307D3, 0x1.A51A6625307D4]_com")));
2 tests, 2 passed, 0 known failure, 0 skipped
[inst/@infsupdec/gauss.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/gauss.m
***** # from the documentation string
***** assert (isequal (gauss (infsupdec ([1, 0; 0, 2]), [2, 0; 0, 4]), infsupdec ([2, 0; 0, 2], "trv")));
1 test, 1 passed, 0 known failure, 0 skipped
[inst/@infsupdec/polyval.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/polyval.m
***** assert (isequal (polyval (infsupdec (3, "trv"), 0), infsupdec (3, "trv")));
1 test, 1 passed, 0 known failure, 0 skipped
[inst/@infsupdec/rdivide.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/rdivide.m
***** # from the documentation string
***** assert (isequal (infsupdec (2, 3) ./ infsupdec (1, 2), infsupdec (1, 3)));
***** assert (1 ./ infsupdec (1, 4) == infsupdec (0.25, 1));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.div;
 for testcase = [testcases]'
   assert (isequaln (...
     rdivide (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.div;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (rdivide (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsupdec.div;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (rdivide (in1, in2), out));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.recip;
 for testcase = [testcases]'
   assert (isequaln (...
     rdivide (1, testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.recip;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (rdivide (1, in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsupdec.recip;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (rdivide (1, in1), out));
8 tests, 8 passed, 0 known failure, 0 skipped
[inst/@infsupdec/infsupdec.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/infsupdec.m
***** # [NaI]s
***** assert (isnai (infsupdec ("[nai]"))); # quiet [NaI]
***** assert (isnai (infsupdec (" [ nai ] "))); # quiet [NaI]
***** assert (isnai (infsupdec ({0, "[nai]"})), [false, true]); # quiet [NaI]
***** warning id=interval:UndefinedOperation
 assert (isnai (infsupdec (3, 2))); # illegal boundaries
***** warning id=interval:UndefinedOperation
 assert (isnai (infsupdec (inf, -inf))); # illegal boundaries
***** warning id=interval:UndefinedOperation
 assert (isnai (infsupdec ("Flugeldufel"))); # illegal literal
***** warning id=interval:UndefinedOperation
 assert (isnai (infsupdec ("[1, Inf]_com"))); # illegal decorated literal
***** warning id=interval:UndefinedOperation
 assert (isnai (infsupdec ("[Empty]_def"))); # illegal decorated literal
***** # decoration adjustments, setDec function
***** test
 x = infsupdec (42, inf, "com");
 assert (inf (x), 42);
 assert (sup (x), inf);
 assert (decorationpart (x), {"dac"});
***** test
 x = infsupdec (-inf, inf, {"com"});
 assert (inf (x), -inf);
 assert (sup (x), inf);
 assert (decorationpart (x), {"dac"});
***** test
 x = infsupdec ("def");
 assert (inf (x), inf);
 assert (sup (x), -inf);
 assert (decorationpart (x), {"trv"});
***** # overflow
***** test
 x = infsupdec ("[1, 1e999]_com");
 assert (inf (x), 1);
 assert (sup (x), inf);
 assert (decorationpart (x), {"dac"});
***** # decorated interval literal
***** test
 x = infsupdec ("[2, 3]_def");
 assert (inf (x), 2);
 assert (sup (x), 3);
 assert (decorationpart (x), {"def"});
***** test
 x = infsupdec ("[1, 5]_dac");
 assert (inf (x), 1);
 assert (sup (x), 5);
 assert (decorationpart (x), {"dac"});
***** test
 x = infsupdec ("[1, Infinity]_dac");
 assert (inf (x), 1);
 assert (sup (x), inf);
 assert (decorationpart (x), {"dac"});
***** test
 x = infsupdec ("[Empty]_trv");
 assert (inf (x), inf);
 assert (sup (x), -inf);
 assert (decorationpart (x), {"trv"});
***** # automatic decoration / undecorated interval literal / newDec function
***** test
 x = infsupdec ("[2, 3]");
 assert (inf (x), 2);
 assert (sup (x), 3);
 assert (decorationpart (x), {"com"});
***** test
 x = infsupdec ("[Empty]");
 assert (inf (x), inf);
 assert (sup (x), -inf);
 assert (decorationpart (x), {"trv"});
***** test
 x = infsupdec ("[Entire]");
 assert (inf (x), -inf);
 assert (sup (x), inf);
 assert (decorationpart (x), {"dac"});
***** test
 x = infsupdec ("");
 assert (inf (x), -inf);
 assert (sup (x), inf);
 assert (decorationpart (x), {"dac"});
***** # separate decoration information
***** test
 x = infsupdec ("[2, 3]", "def");
 assert (inf (x), 2);
 assert (sup (x), 3);
 assert (decorationpart (x), {"def"});
***** # cell array with decorated interval literals
***** test
 x = infsupdec ({"[2, 3]_def", "[4, 5]_dac"});
 assert (inf (x), [2, 4]);
 assert (sup (x), [3, 5]);
 assert (decorationpart (x), {"def", "dac"});
***** #cell array with separate decoration cell array
***** test
 x = infsupdec ({"[2, 3]", "[4, 5]"}, {"def", "dac"});
 assert (inf (x), [2, 4]);
 assert (sup (x), [3, 5]);
 assert (decorationpart (x), {"def", "dac"});
***** # cell array with separate decoration vector
***** test
 x = infsupdec ({"[2, 3]"; "[4, 5]"}, ["def"; "dac"]);
 assert (inf (x), [2; 4]);
 assert (sup (x), [3; 5]);
 assert (decorationpart (x), {"def"; "dac"});
***** # cell array with broadcasting decoration
***** test
 x = infsupdec ({"[2, 3]", "[4, 5]"}, "def");
 assert (inf (x), [2, 4]);
 assert (sup (x), [3, 5]);
 assert (decorationpart (x), {"def", "def"});
***** test
 x = infsupdec ({"[2, 3]", "[4, 5]"}, "def; dac");
 assert (inf (x), [2, 4; 2, 4]);
 assert (sup (x), [3, 5; 3, 5]);
 assert (decorationpart (x), {"def", "def"; "dac", "dac"});
***** # separate boundaries with decoration
***** test
 x = infsupdec (2, 3, "def");
 assert (inf (x), 2);
 assert (sup (x), 3);
 assert (decorationpart (x), {"def"});
***** # matrix boundaries with decoration
***** test
 x = infsupdec ([3, 16], {"def", "trv"});
 assert (inf (x), [3, 16]);
 assert (sup (x), [3, 16]);
 assert (decorationpart (x), {"def", "trv"});
***** # separate matrix boundaries with broadcasting decoration
***** test
 x = infsupdec (magic (3), magic (3) + 1, "def");
 assert (inf (x), magic (3));
 assert (sup (x), magic (3) + 1);
 assert (decorationpart (x), {"def", "def", "def"; "def", "def", "def"; "def", "def", "def"});
***** # N-dimensional arrays
***** test
 x = infsupdec (zeros (2, 2, 2));
 assert (x.inf, zeros (2, 2, 2));
 assert (x.sup, zeros (2, 2, 2));
 assert (decorationpart (x), repmat ({"com"}, [2, 2, 2]));
***** test
 x = infsupdec (zeros (2, 2, 2), ones (2, 2, 2), repmat ({"trv"}, [2, 2, 2]));
 assert (x.inf, zeros (2, 2, 2));
 assert (x.sup, ones (2, 2, 2));
 assert (decorationpart (x), repmat ({"trv"}, [2, 2, 2]));
***** test
 x = infsupdec (zeros (1, 1, 2), ones (1, 2, 1), {"trv"; "trv"});
 assert (x.inf, zeros (2, 2, 2));
 assert (x.sup, ones (2, 2, 2));
 assert (decorationpart (x), repmat ({"trv"}, [2, 2, 2]));
***** test
 c1 = reshape ({1, 2, 3, 4, 5, 6, 7, 8}, 2, 2, 2);
 c2 = reshape ({2, 3, 4, 5, 6, 7, 8, 9}, 2, 2, 2);
 decpart = reshape ({"trv", "def", "dac", "com", "trv", "def", "dac", "com"}, 2, 2, 2);
 x = infsupdec (c1, c2, decpart);
 assert (x.inf, reshape (1:8, 2, 2, 2));
 assert (x.sup, reshape (2:9, 2, 2, 2));
 assert (decorationpart (x), decpart)
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.setDec;
 for testcase = [testcases]'
   assert (isequaln (...
     infsupdec (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.setDec;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (infsupdec (in1, in2), out));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.("d-numsToInterval");
 for testcase = [testcases]'
   assert (isequaln (...
     infsupdec (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.("d-numsToInterval");
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (infsupdec (in1, in2), out));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.("d-textToInterval");
 for testcase = [testcases]'
   assert (isequaln (...
     infsupdec (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.("d-textToInterval");
 in1 = vertcat (testcases.in);
 out = vertcat (testcases.out);
 assert (isequaln (infsupdec (in1), out));
***** warning
 testcases = testdata.PossiblyUndefinedOperation.infsupdec.("d-textToInterval");
 for testcase = [testcases]'
   lastwarn ("", "");
   assert (isequaln (...
     infsupdec (testcase.in{1}), ...
     testcase.out));
   assert (nthargout (2, @lastwarn), "interval:PossiblyUndefinedOperation");
 endfor
***** warning
 testcases = testdata.UndefinedOperation.infsupdec.("d-textToInterval");
 for testcase = [testcases]'
   lastwarn ("", "");
   assert (isequaln (...
     infsupdec (testcase.in{1}), ...
     testcase.out));
   assert (nthargout (2, @lastwarn), "interval:UndefinedOperation");
 endfor
***** warning
 testcases = testdata.UndefinedOperation.infsupdec.("d-numsToInterval");
 for testcase = [testcases]'
   lastwarn ("", "");
   assert (isequaln (...
     infsupdec (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
   assert (nthargout (2, @lastwarn), "interval:UndefinedOperation");
 endfor
***** warning
 testcases = testdata.UndefinedOperation.infsup.setDec;
 for testcase = [testcases]'
   lastwarn ("", "");
   assert (isequaln (...
     infsupdec (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
   assert (nthargout (2, @lastwarn), "interval:UndefinedOperation");
 endfor
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsupdec.("d-numsToInterval");
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (infsupdec (in1, in2), out));
44 tests, 44 passed, 0 known failure, 0 skipped
[inst/@infsupdec/realsqrt.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/realsqrt.m
***** # from the documentation string
***** assert (isequal (realsqrt (infsupdec (-6, 4)), infsupdec (0, 2, "trv")));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.sqrt;
 for testcase = [testcases]'
   assert (isequaln (...
     realsqrt (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.sqrt;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (realsqrt (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.sqrt;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (realsqrt (in1), out));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsupdec/gammaln.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/gammaln.m
***** assert (isequal (gammaln (infsupdec (-inf, inf)), infsupdec ("[-0x1.F19B9BCC38A42p-4, +Inf]_trv")));
***** # from the documentation string
***** assert (isequal (gammaln (infsupdec (1.5)), infsupdec ("[-0x1.EEB95B094C192p-4, -0x1.EEB95B094C191p-4]_com")));
2 tests, 2 passed, 0 known failure, 0 skipped
[inst/@infsupdec/floor.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/floor.m
***** # from the documentation string
***** assert (isequal (floor (infsupdec (2.5, 3.5)), infsupdec (2, 3, "def")));
***** assert (isequal (floor (infsupdec (-0.5, 5)), infsupdec (-1, 5, "def")));
***** warning
 _ = @infsupdec;
 assert (isequal (...
   floor (_ ("jansen")), nai)) #ghtwish
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.floor;
 for testcase = [testcases]'
   assert (isequaln (...
     floor (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.floor;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (floor (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.floor;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (floor (in1), out));
6 tests, 6 passed, 0 known failure, 0 skipped
[inst/@infsupdec/sinh.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/sinh.m
***** # from the documentation string
***** assert (isequal (sinh (infsupdec (1)), infsupdec ("[0x1.2CD9FC44EB982, 0x1.2CD9FC44EB983]")));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.sinh;
 for testcase = [testcases]'
   assert (isequaln (...
     sinh (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.sinh;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (sinh (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsupdec.sinh;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (sinh (in1), out));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsupdec/reshape.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/reshape.m
***** assert (isequal (reshape (infsupdec (1 : 6), 2, 3), infsupdec (reshape (1 : 6, 2, 3))));
***** assert (isequal (reshape (infsupdec (1 : 24), 2, [], 4), infsupdec (reshape (1 : 24, 2, 3, 4))));
2 tests, 2 passed, 0 known failure, 0 skipped
[inst/@infsupdec/powrev1.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/powrev1.m
***** # from the documentation string
***** assert (isequal (powrev1 (infsupdec (2, 5), infsupdec (3, 6)), infsupdec ("[0x1.3EE8390D43955, 0x1.3988E1409212Fp1]_trv")));
1 test, 1 passed, 0 known failure, 0 skipped
[inst/@infsupdec/log10.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/log10.m
***** # from the documentation string
***** assert (isequal (log10 (infsupdec (2)), infsupdec ("[0x1.34413509F79FEp-2, 0x1.34413509F79FFp-2]")));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.log10;
 for testcase = [testcases]'
   assert (isequaln (...
     log10 (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.log10;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (log10 (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.log10;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (log10 (in1), out));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsupdec/pown.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/pown.m
***** # from the documentation string
***** assert (isequal (pown (infsupdec (5, 6), 2), infsupdec (25, 36)));
***** assert (pown (infsupdec (-2, 1), 2) == infsupdec (0, 4));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.sqr;
 for testcase = [testcases]'
   assert (isequaln (...
     pown (testcase.in{1}, 2), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.sqr;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (pown (in1, 2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsupdec.sqr;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (pown (in1, 2), out));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.pown;
 for testcase = [testcases]'
   assert (isequaln (...
     pown (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.pown;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (pown (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsupdec.pown;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (pown (in1, in2), out));
8 tests, 8 passed, 0 known failure, 0 skipped
[inst/@infsupdec/le.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/le.m
***** assert (le (infsupdec (1, 3), infsupdec (3)));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.less;
 for testcase = [testcases]'
   assert (isequaln (...
     le (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.less;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (le (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsupdec.less;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (le (in1, in2), out));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsupdec/ei.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/ei.m
***** assert (isempty (ei (infsupdec (0))));
***** assert (isempty (ei (infsupdec (-inf, -2))));
***** assert (isequal (ei (infsupdec (0, inf)), infsupdec ("[Entire]_trv")));
***** assert (isequal (ei (infsupdec (1, inf)), infsupdec ("[0x1.E52670F350D08, Inf]_dac")));
***** # from the documentation string
***** assert (isequal (ei (infsupdec (1)), infsupdec ("[0x1.E52670F350D08, 0x1.E52670F350D09]_com")));
5 tests, 5 passed, 0 known failure, 0 skipped
[inst/@infsupdec/uminus.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/uminus.m
***** # from the documentation string
***** assert (isequal (-infsupdec (2, 3), infsupdec (-3, -2)));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.neg;
 for testcase = [testcases]'
   assert (isequaln (...
     uminus (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.neg;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (uminus (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.neg;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (uminus (in1), out));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsupdec/cancelminus.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/cancelminus.m
***** # from the documentation string
***** assert (isequal (cancelminus (infsupdec (2, 3), infsupdec (1, 1.5)), infsupdec (1, 1.5, "trv")));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.cancelMinus;
 for testcase = [testcases]'
   assert (isequaln (...
     cancelminus (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.cancelMinus;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (cancelminus (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsupdec.cancelMinus;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (cancelminus (in1, in2), out));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsupdec/fma.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/fma.m
***** # from the documentation string
***** assert (isequal (fma (infsupdec (1+eps), infsupdec (7), infsupdec ("0.1")), infsupdec ("[0x1.C666666666668p2, 0x1.C666666666669p2]")));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.fma;
 for testcase = [testcases]'
   assert (isequaln (...
     fma (testcase.in{1}, testcase.in{2}, testcase.in{3}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.fma;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 in3 = vertcat (vertcat (testcases.in){:, 3});
 out = vertcat (testcases.out);
 assert (isequaln (fma (in1, in2, in3), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsupdec.fma;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 in3 = vertcat (vertcat (testcases.in){:, 3});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2 | i == numel (in1))
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 in3 = reshape ([in3; in3(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (fma (in1, in2, in3), out));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsupdec/decorationpart.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/decorationpart.m
***** assert (decorationpart (infsupdec (3, 4)), {"com"});
***** assert (decorationpart (infsupdec (3, inf)), {"dac"});
***** assert (decorationpart (infsupdec ("[3, 4]_def")), {"def"});
***** assert (decorationpart (infsupdec ()), {"trv"});
***** assert (decorationpart (nai), {"ill"});
***** assert (decorationpart (nai, "uint8") ...
      < decorationpart (infsupdec ("[3, 4]_trv"), "uint8"));
***** assert (decorationpart (infsupdec ("[3, 4]_trv"), "uint8") ...
      < decorationpart (infsupdec ("[3, 4]_def"), "uint8"));
***** assert (decorationpart (infsupdec ("[3, 4]_def"), "uint8") ...
      < decorationpart (infsupdec ("[3, 4]_dac"), "uint8"));
***** assert (decorationpart (infsupdec ("[3, 4]_dac"), "uint8") ...
      < decorationpart (infsupdec ("[3, 4]_com"), "uint8"));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.decorationPart;
 for testcase = [testcases]'
   assert (isequaln (...
     decorationpart (testcase.in{1}), ...
     {testcase.out}));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.decorationPart;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = {testcases.out}';
 assert (isequaln (decorationpart (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsupdec.decorationPart;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = {testcases.out}';
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (decorationpart (in1), out));
12 tests, 12 passed, 0 known failure, 0 skipped
[inst/@infsupdec/atan2rev2.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/atan2rev2.m
***** # from the documentation string
***** assert (isequal (atan2rev2 (infsupdec (1, 2), infsupdec ("pi") / 4), infsupdec ("[0x1.FFFFFFFFFFFFEp-1, 0x1.0000000000001p1]_trv")));
1 test, 1 passed, 0 known failure, 0 skipped
[inst/@infsupdec/det.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/det.m
***** # from the documentation string
***** assert (det (infsupdec (magic (3))) == -360);
1 test, 1 passed, 0 known failure, 0 skipped
[inst/@infsupdec/max.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/max.m
***** # from the documentation string
***** assert (isequal (max (infsupdec (2, 3), infsupdec (1, 2)), infsupdec (2, 3)));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.max;
 for testcase = [testcases]'
   assert (isequaln (...
     max (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.max;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (max (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsupdec.max;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (max (in1, in2), out));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsupdec/abs.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/abs.m
***** # Empty interval
***** assert (isequal (abs (infsupdec ()), infsupdec ()));
***** # Singleton intervals
***** assert (isequal (abs (infsupdec (1)), infsupdec (1)));
***** assert (isequal (abs (infsupdec (0)), infsupdec (0)));
***** assert (isequal (abs (infsupdec (-1)), infsupdec (1)));
***** assert (isequal (abs (infsupdec (realmax)), infsupdec (realmax)));
***** assert (isequal (abs (infsupdec (realmin)), infsupdec (realmin)));
***** assert (isequal (abs (infsupdec (-realmin)), infsupdec (realmin)));
***** assert (isequal (abs (infsupdec (-realmax)), infsupdec (realmax)));
***** # Bounded intervals
***** assert (isequal (abs (infsupdec (1, 2)), infsupdec (1, 2)));
***** assert (isequal (abs (infsupdec (0, 1)), infsupdec (0, 1)));
***** assert (isequal (abs (infsupdec (-1, 1)), infsupdec (0, 1)));
***** assert (isequal (abs (infsupdec (-1, 0)), infsupdec (0, 1)));
***** assert (isequal (abs (infsupdec (-2, -1)), infsupdec (1, 2)));
***** # Unbounded intervals
***** assert (isequal (abs (infsupdec (0, inf)), infsupdec (0, inf)));
***** assert (isequal (abs (infsupdec (-inf, inf)), infsupdec (0, inf)));
***** assert (isequal (abs (infsupdec (-inf, 0)), infsupdec (0, inf)));
***** assert (isequal (abs (infsupdec (1, inf)), infsupdec (1, inf)));
***** assert (isequal (abs (infsupdec (-1, inf)), infsupdec (0, inf)));
***** assert (isequal (abs (infsupdec (-inf, -1)), infsupdec (1, inf)));
***** assert (isequal (abs (infsupdec (-inf, 1)), infsupdec (0, inf)));
***** # from the documentation string
***** assert (isequal (abs (infsupdec (2.5, 3.5)), infsupdec (2.5, 3.5)));
***** assert (isequal (abs (infsupdec (-0.5, 5.5)), infsupdec (0, 5.5)));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.abs;
 for testcase = [testcases]'
   assert (isequaln (...
     abs (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.abs;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (abs (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.abs;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (abs (in1), out));
25 tests, 25 passed, 0 known failure, 0 skipped
[inst/@infsupdec/csch.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/csch.m
***** # from the documentation string
***** assert (isequal (csch (infsupdec (1)), infsupdec ("[0x1.B3AB8A78B90Cp-1, 0x1.B3AB8A78B90C1p-1]_com")));
1 test, 1 passed, 0 known failure, 0 skipped
[inst/@infsupdec/hypot.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/hypot.m
***** # from the documentation string
***** assert (isequal (hypot (infsupdec (2, 3), infsupdec (1, 2)), infsupdec ("[0x1.1E3779B97F4A7p1, 0x1.CD82B446159F4p1]")));
1 test, 1 passed, 0 known failure, 0 skipped
[inst/@infsupdec/mod.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/mod.m
***** assert (isequal (mod (infsupdec (), infsupdec ()), infsupdec ()));
***** assert (isequal (mod (infsupdec (0), infsupdec ()), infsupdec ()));
***** assert (isequal (mod (infsupdec (), infsupdec (0)), infsupdec ()));
***** assert (isequal (mod (infsupdec (0), infsupdec (0)), infsupdec ()));
***** assert (isequal (mod (infsupdec (1), infsupdec (0)), infsupdec ()));
***** assert (isequal (mod (infsupdec (0, 1), infsupdec (0)), infsupdec ()));
***** assert (isequal (mod (infsupdec (1, 2), infsupdec (0)), infsupdec ()));
***** assert (isequal (mod (infsupdec (0, inf), infsupdec (0)), infsupdec ()));
***** assert (isequal (mod (infsupdec (1, inf), infsupdec (0)), infsupdec ()));
***** assert (isequal (mod (infsupdec (realmax, inf), infsupdec (0)), infsupdec ()));
***** assert (isequal (mod (infsupdec (0), infsupdec (1)), infsupdec (0, "dac")));
***** assert (isequal (mod (infsupdec (0), infsupdec (0, 1)), infsupdec (0, "trv")));
***** assert (isequal (mod (infsupdec (0), infsupdec (1, 2)), infsupdec (0, "dac")));
***** assert (isequal (mod (infsupdec (0), infsupdec (0, inf)), infsupdec (0, "trv")));
***** assert (isequal (mod (infsupdec (0), infsupdec (1, inf)), infsupdec (0, "dac")));
***** assert (isequal (mod (infsupdec (0), infsupdec (realmax, inf)), infsupdec (0, "dac")));
***** assert (isequal (mod (infsupdec (1), infsupdec (1)), infsupdec (0, "dac")));
***** assert (isequal (mod (infsupdec (2), infsupdec (1)), infsupdec (0, "dac")));
***** assert (isequal (mod (infsupdec (4), infsupdec (2)), infsupdec (0, "dac")));
***** assert (isequal (mod (infsupdec (6), infsupdec (3)), infsupdec (0, "dac")));
***** assert (isequal (mod (infsupdec (8), infsupdec (2)), infsupdec (0, "dac")));
***** assert (isequal (mod (infsupdec (9), infsupdec (3)), infsupdec (0, "dac")));
***** assert (isequal (mod (infsupdec (realmax), infsupdec (realmax)), infsupdec (0, "dac")));
***** assert (isequal (mod (infsupdec (realmax), infsupdec (realmax / 2)), infsupdec (0, "dac")));
***** assert (isequal (mod (infsupdec (realmax), infsupdec (realmax / 4)), infsupdec (0, "dac")));
***** assert (isequal (mod (infsupdec (realmax), infsupdec (realmax / 8)), infsupdec (0, "dac")));
***** assert (isequal (mod (infsupdec (realmax), infsupdec (realmax / 16)), infsupdec (0, "dac")));
***** assert (isequal (mod (infsupdec (realmax), infsupdec (realmax / 32)), infsupdec (0, "dac")));
***** assert (isequal (mod (infsupdec (0.1), infsupdec (0.1)), infsupdec (0, "dac")));
***** assert (isequal (mod (infsupdec (0.1 * 2), infsupdec (0.1)), infsupdec (0, "dac")));
***** assert (isequal (mod (infsupdec (0.1 * 4), infsupdec (0.1)), infsupdec (0, "dac")));
***** assert (isequal (mod (infsupdec (pi), infsupdec (pi)), infsupdec (0, "dac")));
***** assert (isequal (mod (infsupdec (pi), infsupdec (pi / 2)), infsupdec (0, "dac")));
***** assert (isequal (mod (infsupdec (pi), infsupdec (pi / 4)), infsupdec (0, "dac")));
***** assert (isequal (mod (infsupdec (pow2 (-1074)), infsupdec (pow2 (-1074))), infsupdec (0, "dac")));
***** assert (isequal (mod (infsupdec (pow2 (-1073)), infsupdec (pow2 (-1074))), infsupdec (0, "dac")));
***** assert (isequal (mod (infsupdec (pow2 (-1072)), infsupdec (pow2 (-1074))), infsupdec (0, "dac")));
***** assert (isequal (mod (infsupdec (1), infsupdec (2)), infsupdec (1)));
***** assert (isequal (mod (infsupdec (0.5), infsupdec (1)), infsupdec (0.5)));
***** assert (isequal (mod (infsupdec (pi), infsupdec (3.15)), infsupdec (pi)));
***** assert (isequal (mod (infsupdec (1), infsupdec (2, 3)), infsupdec (1)));
***** assert (isequal (mod (infsupdec (1), infsupdec (2, inf)), infsupdec (1, "dac")));
***** assert (isequal (mod (infsupdec (0.5), infsupdec (1, 2)), infsupdec (0.5)));
***** assert (isequal (mod (infsupdec (0.5), infsupdec (1, inf)), infsupdec (0.5, "dac")));
***** assert (isequal (mod (infsupdec (pi), infsupdec (3.15)), infsupdec (pi)));
***** assert (isequal (mod (infsupdec (pi), infsupdec (3.15, inf)), infsupdec (pi, "dac")));
***** assert (isequal (mod (infsupdec (0, 1), infsupdec (0, 1)), infsupdec (0, 1, "trv")));
***** assert (isequal (mod (infsupdec (0, 2), infsupdec (0, 1)), infsupdec (0, 1, "trv")));
***** assert (isequal (mod (infsupdec (0, 1), infsupdec (0, 2)), infsupdec (0, 1, "trv")));
***** assert (isequal (mod (infsupdec (0, realmax), infsupdec (0, realmax)), infsupdec (0, realmax, "trv")));
***** assert (isequal (mod (infsupdec (realmax, inf), infsupdec (realmax, inf)), infsupdec (0, inf, "def")));
***** assert (isequal (mod (infsupdec (0, inf), infsupdec (0, inf)), infsupdec (0, inf, "trv")));
***** assert (isequal (mod (infsupdec (0), infsupdec (1)), infsupdec (0, "dac")));
***** assert (isequal (mod (infsupdec (1), infsupdec (1)), infsupdec (0, "dac")));
***** assert (isequal (mod (infsupdec (0, 1), infsupdec (1)), infsupdec (0, 1, "def")));
***** assert (isequal (mod (infsupdec (1, 2), infsupdec (1)), infsupdec (0, 1, "def")));
***** assert (isequal (mod (infsupdec (0, inf), infsupdec (1)), infsupdec (0, 1, "def")));
***** assert (isequal (mod (infsupdec (1, inf), infsupdec (1)), infsupdec (0, 1, "def")));
***** assert (isequal (mod (infsupdec (realmax, inf), infsupdec (1)), infsupdec (0, 1, "def")));
***** assert (isequal (mod (infsupdec (1), infsupdec (1)), infsupdec (0, "dac")));
***** assert (isequal (mod (infsupdec (1), infsupdec (0, 1)), infsupdec (0, 0.5, "trv")));
***** assert (isequal (mod (infsupdec (1), infsupdec (1, 2)), infsupdec (0, 1, "def")));
***** assert (isequal (mod (infsupdec (1), infsupdec (0, inf)), infsupdec (0, 1, "trv")));
***** assert (isequal (mod (infsupdec (1), infsupdec (1, inf)), infsupdec (0, 1, "def")));
***** assert (isequal (mod (infsupdec (1), infsupdec (2, inf)), infsupdec (1, "dac")));
***** assert (isequal (mod (infsupdec (1), infsupdec (realmax, inf)), infsupdec (1, "dac")));
66 tests, 66 passed, 0 known failure, 0 skipped
[inst/@infsupdec/atan2.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/atan2.m
***** # from the documentation string
***** assert (isequal (atan2 (infsupdec (1), infsupdec (-1)), infsupdec ("[0x1.2D97C7F3321D2p1, 0x1.2D97C7F3321D3p1]")));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.atan2;
 for testcase = [testcases]'
   assert (isequaln (...
     atan2 (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.atan2;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (atan2 (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsupdec.atan2;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (atan2 (in1, in2), out));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsupdec/inf.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/inf.m
***** assert (inf (infsupdec (2.5, 3.5)), 2.5);
***** assert (inf (infsupdec ()), +inf);
***** assert (inf (infsupdec ("[nai]")), nan);
***** warning id=interval:UndefinedOperation
 assert (inf (infsupdec (2, 1)), nan);
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.inf;
 for testcase = [testcases]'
   assert (isequaln (...
     inf (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.inf;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (inf (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.inf;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (inf (in1), out));
7 tests, 7 passed, 0 known failure, 0 skipped
[inst/@infsupdec/acosh.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/acosh.m
***** # from the documentation string
***** assert (isequal (acosh (infsupdec (2)), infsupdec ("[0x1.5124271980434, 0x1.5124271980435]")));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.acosh;
 for testcase = [testcases]'
   assert (isequaln (...
     acosh (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.acosh;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (acosh (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.acosh;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (acosh (in1), out));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsupdec/erf.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/erf.m
***** # from the documentation string
***** assert (erf (infsupdec (1)) == "[0x1.AF767A741088Ap-1, 0x1.AF767A741088Bp-1]");
1 test, 1 passed, 0 known failure, 0 skipped
[inst/@infsupdec/isempty.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/isempty.m
***** assert (isempty (infsupdec ()));
***** assert (not (isempty (infsupdec (1, 2))));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.isEmpty;
 for testcase = [testcases]'
   assert (isequaln (...
     isempty (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.isEmpty;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (isempty (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.isEmpty;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (isempty (in1), out));
5 tests, 5 passed, 0 known failure, 0 skipped
[inst/@infsupdec/bisect.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/bisect.m
***** # from the documentation string
***** test
 [a, b] = bisect (infsupdec (2, 32));
 assert (a == infsupdec (2, 8, "trv"));
 assert (b == infsupdec (8, 32, "trv"));
1 test, 1 passed, 0 known failure, 0 skipped
[inst/@infsupdec/lt.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/lt.m
***** assert (not (lt (infsupdec (1, 3), infsupdec (3))));
***** assert (lt (infsupdec (1, 3), infsupdec (3.1)));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.strictLess;
 for testcase = [testcases]'
   assert (isequaln (...
     lt (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.strictLess;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (lt (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsupdec.strictLess;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (lt (in1, in2), out));
5 tests, 5 passed, 0 known failure, 0 skipped
[inst/@infsupdec/cat.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/cat.m
***** assert (size (cat (1, infsupdec ([]), infsupdec ([]))), [0 0]);
***** assert (isequal (cat (1, infsupdec (1), infsupdec (2)), infsupdec (cat (1, 1, 2))));
***** assert (isequal (cat (2, infsupdec (1), infsupdec (2)), infsupdec (cat (2, 1, 2))));
***** assert (isequal (horzcat (infsupdec (1), infsupdec (2)), infsupdec (horzcat (1, 2))));
***** test
 a = infsupdec (2, 5);
 assert (isequal (horzcat (a, a, a), infsupdec ([2, 2, 2], [5, 5, 5])));
***** assert (isequal (vertcat (infsupdec (1), infsupdec (2)), infsupdec (vertcat (1, 2))));
***** test
 a = infsupdec (2, 5);
 assert (isequal (vertcat (a, a, a), infsupdec ([2; 2; 2], [5; 5; 5])));
***** assert (isequal (cat (5, infsupdec (1), infsupdec (2)), infsupdec (cat (5, 1, 2))));
***** assert (isequal (cat (1, infsupdec (zeros (2, 2, 2)), infsupdec (ones (2, 2, 2))), infsupdec (cat (1, zeros (2, 2, 2), ones (2, 2, 2)))));
9 tests, 9 passed, 0 known failure, 0 skipped
[inst/@infsupdec/fix.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/fix.m
***** # from the documentation string
***** assert (isequal (fix (infsupdec (2.5, 3.5)), infsupdec (2, 3, "def")));
***** assert (isequal (fix (infsupdec (-0.5, 5)), infsupdec (0, 5, "def")));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.trunc;
 for testcase = [testcases]'
   assert (isequaln (...
     fix (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.trunc;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (fix (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsupdec.trunc;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (fix (in1), out));
5 tests, 5 passed, 0 known failure, 0 skipped
[inst/@infsupdec/transpose.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/transpose.m
***** assert (isequal (transpose (infsupdec (magic (3))), infsupdec (magic (3).')));
***** # from the documentation string
***** assert (isequal (transpose (infsupdec (zeros (1, 3), ones (1, 3))), infsupdec (zeros (3, 1), ones (3, 1))));
2 tests, 2 passed, 0 known failure, 0 skipped
[inst/@infsupdec/triu.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/triu.m
***** assert (triu (infsupdec (magic (10))) == triu (magic (10)));
***** assert (triu (infsupdec (magic (10)), 1) == triu (magic (10), 1));
***** assert (triu (infsupdec (magic (10)), -1) == triu (magic (10), -1));
***** assert (triu (infsupdec (magic (10)), 0, "pack") == triu (magic (10), 0, "pack"));
***** test
 A = infsupdec (zeros (3), "trv");
 assert (decorationpart (triu (A)), {"trv", "trv", "trv"; "com", "trv", "trv"; "com", "com", "trv"});
5 tests, 5 passed, 0 known failure, 0 skipped
[inst/@infsupdec/sum.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/sum.m
***** # from the documentation string
***** assert (isequal (sum ([infsupdec(1), pow2(-1074), -1]), infsupdec (pow2 (-1074))));
1 test, 1 passed, 0 known failure, 0 skipped
[inst/@infsupdec/postpad.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/postpad.m
***** assert (isequal (postpad (infsupdec (1:3), 4, 4), infsupdec (1:4)));
***** assert (isequal (postpad (infsupdec (1:3), 2, 4), infsupdec (1:2)));
***** test
 if (compare_versions (OCTAVE_VERSION (), "4.0.0", ">="))
   assert (isequal (postpad (infsupdec (0), 10, 0, 3), infsupdec (zeros (1, 1, 10))));
 else
   # In Octave 3.8.x it is not possible to increase the number of dimensions.
 endif
***** assert (isequal (postpad (infsupdec (zeros (1, 2, 2)), 3), infsupdec (zeros (1, 3, 2))));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsupdec/overlap.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/overlap.m
***** assert (overlap (infsupdec (1, 2), infsupdec (3, 4)), "before");
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.overlap;
 for testcase = [testcases]'
   assert (isequaln (...
     overlap (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.overlap;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = {testcases.out}';
 assert (isequaln (overlap (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsupdec.overlap;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = {testcases.out}';
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (overlap (in1, in2), out));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsupdec/sin.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/sin.m
***** # from the documentation string
***** assert (isequal (sin (infsupdec (1)), infsupdec ("[0x1.AED548F090CEEp-1, 0x1.AED548F090CEFp-1]")));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.sin;
 for testcase = [testcases]'
   assert (isequaln (...
     sin (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.sin;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (sin (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.sin;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (sin (in1), out));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsupdec/mldivide.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/mldivide.m
***** # unique solution
***** assert (isequal (infsupdec ([1, 0; 0, 2]) \ [2, 0; 0, 4], infsupdec ([2, 0; 0 2], "trv")));
***** # no solution
***** assert (all (isempty (infsupdec ([1, 0; 2, 0]) \ [3; 0])));
***** # many solutions
***** assert (isequal (infsupdec ([1, 0; 2, 0]) \ [4; 8], infsupdec ([4; -inf], [4; inf], "trv")));
3 tests, 3 passed, 0 known failure, 0 skipped
[inst/@infsupdec/nthroot.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/nthroot.m
***** assert (isequal (nthroot (infsupdec (25, 36), 2), infsupdec (5, 6)));
***** assert (isequal (nthroot (infsupdec (-1, 1), 2), infsupdec (0, 1, "trv")));
***** assert (isequal (nthroot (infsupdec (-1, 1), 3), infsupdec (-1, 1)));
***** assert (isequal (nthroot (infsupdec (-1, 1), -2), infsupdec (1, inf, "trv")));
***** assert (isequal (nthroot (infsupdec (-1, 1), -3), infsupdec (-inf, inf, "trv")));
5 tests, 5 passed, 0 known failure, 0 skipped
[inst/@infsupdec/absrev.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/absrev.m
***** # Empty interval
***** assert (isequal (absrev (infsupdec ()), infsupdec ()));
***** assert (isequal (absrev (infsupdec (0, 1), infsupdec ()), infsupdec ()));
***** assert (isequal (absrev (infsupdec (0, 1), infsupdec (7, 9)), infsupdec ()));
***** assert (isequal (absrev (infsupdec (), infsupdec (0, 1)), infsupdec ()));
***** assert (isequal (absrev (infsupdec (-2, -1)), infsupdec ()));
***** # Singleton intervals
***** assert (isequal (absrev (infsupdec (1)), infsupdec (-1, 1, "trv")));
***** assert (isequal (absrev (infsupdec (0)), infsupdec (0, "trv")));
***** assert (isequal (absrev (infsupdec (-1)), infsupdec ()));
***** assert (isequal (absrev (infsupdec (realmax)), infsupdec (-realmax, realmax, "trv")));
***** assert (isequal (absrev (infsupdec (realmin)), infsupdec (-realmin, realmin, "trv")));
***** assert (isequal (absrev (infsupdec (-realmin)), infsupdec ()));
***** assert (isequal (absrev (infsupdec (-realmax)), infsupdec ()));
***** # Bound intervals
***** assert (isequal (absrev (infsupdec (1, 2)), infsupdec (-2, 2, "trv")));
***** assert (isequal (absrev (infsupdec (1, 2), infsupdec (0, 2)), infsupdec (1, 2, "trv")));
***** assert (isequal (absrev (infsupdec (0, 1), infsupdec (-0.5, 2)), infsupdec (-0.5, 1, "trv")));
***** assert (isequal (absrev (infsupdec (-1, 1)), infsupdec (-1, 1, "trv")));
***** assert (isequal (absrev (infsupdec (-1, 0)), infsupdec (0, "trv")));
***** # Unbound intervals
***** assert (isequal (absrev (infsupdec (0, inf)), infsupdec (-inf, inf, "trv")));
***** assert (isequal (absrev (infsupdec (-inf, inf)), infsupdec (-inf, inf, "trv")));
***** assert (isequal (absrev (infsupdec (-inf, 0)), infsupdec (0, "trv")));
***** assert (isequal (absrev (infsupdec (1, inf), infsupdec (-inf, 0)), infsupdec (-inf, -1, "trv")));
***** assert (isequal (absrev (infsupdec (-1, inf)), infsupdec (-inf, inf, "trv")));
***** assert (isequal (absrev (infsupdec (-inf, -1)), infsupdec ()));
***** assert (isequal (absrev (infsupdec (-inf, 1)), infsupdec (-1, 1, "trv")));
***** # from the documentation string
***** assert (isequal (absrev (infsupdec (-2, 1)), infsupdec (-1, 1, "trv")));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation with one argument
 testcases = testdata.NoSignal.infsupdec.absRev;
 for testcase = [testcases]'
   assert (isequaln (...
     absrev (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation with one argument
 testcases = testdata.NoSignal.infsupdec.absRev;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (absrev (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsupdec.absRev;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (absrev (in1), out));
***** test
 # Scalar evaluation with two arguments
 testcases = testdata.NoSignal.infsupdec.absRevBin;
 for testcase = [testcases]'
   assert (isequaln (...
     absrev (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation with two arguments
 testcases = testdata.NoSignal.infsupdec.absRevBin;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (absrev (in1, in2), out));
***** test
 # N-dimensional array evaluation with two arguments
 testcases = testdata.NoSignal.infsupdec.absRevBin;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (absrev (in1, in2), out));
31 tests, 31 passed, 0 known failure, 0 skipped
[inst/@infsupdec/plus.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/plus.m
***** # from the documentation string
***** assert (isequal (infsupdec (2, 3) + infsupdec (1, 2), infsupdec (3, 5)));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.add;
 for testcase = [testcases]'
   assert (isequaln (...
     plus (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.add;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (plus (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsupdec.add;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (plus (in1, in2), out));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsupdec/atan.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/atan.m
***** # from the documentation string
***** assert (isequal (atan (infsupdec (1)), infsupdec ("[0x1.921FB54442D18p-1, 0x1.921FB54442D19p-1]")));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.atan;
 for testcase = [testcases]'
   assert (isequaln (...
     atan (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.atan;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (atan (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.atan;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (atan (in1), out));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsupdec/mince.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/mince.m
***** assert (isequal (mince (infsupdec (0, 10), 10), infsupdec (0 : 9, 1 : 10, "trv")));
1 test, 1 passed, 0 known failure, 0 skipped
[inst/@infsupdec/sec.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/sec.m
***** # from the documentation string
***** assert (isequal (sec (infsupdec (1)), infsupdec ("[0x1.D9CF0F125CC29, 0x1.D9CF0F125CC2A]_com")));
1 test, 1 passed, 0 known failure, 0 skipped
[inst/@infsupdec/pownrev.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/pownrev.m
***** assert (isequal (pownrev (infsupdec (25, 36), infsupdec (0, inf), 2), infsupdec (5, 6, "trv")));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.pownRev;
 for testcase = [testcases]'
   assert (isequaln (...
     pownrev (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.pownRev;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (pownrev (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsupdec.pownRev;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (pownrev (in1, in2), out));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.pownRevBin;
 for testcase = [testcases]'
   assert (isequaln (...
     pownrev (testcase.in{1}, testcase.in{2}, testcase.in{3}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.pownRevBin;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 in3 = vertcat (vertcat (testcases.in){:, 3});
 out = vertcat (testcases.out);
 assert (isequaln (pownrev (in1, in2, in3), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsupdec.pownRevBin;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 in3 = vertcat (vertcat (testcases.in){:, 3});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 in3 = reshape ([in3; in3(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (pownrev (in1, in2, in3), out));
7 tests, 7 passed, 0 known failure, 0 skipped
[inst/@infsupdec/diag.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/diag.m
***** assert (diag (infsupdec (-inf, inf)) == "[Entire]");
***** assert (diag (infsupdec ()) == "[Empty]");
***** assert (numel (diag (infsupdec ([]))), 0);
***** assert (isequal (diag (infsupdec (magic (3))), infsupdec ([8; 5; 2])));
***** assert (isequal (diag (infsupdec ([8 5 3])), infsupdec ([8 0 0; 0 5 0; 0 0 3])));
5 tests, 5 passed, 0 known failure, 0 skipped
[inst/@infsupdec/cbrt.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/cbrt.m
***** # from the documentation string
***** assert (isequal (cbrt (infsupdec (-27, 27)), infsupdec (-3, 3)));
1 test, 1 passed, 0 known failure, 0 skipped
[inst/@infsupdec/sinrev.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/sinrev.m
***** # from the documentation string
***** assert (isequal (sinrev (infsupdec (-1), infsupdec (0, 6)), infsupdec ("[0x1.2D97C7F3321D2p2, 0x1.2D97C7F3321D3p2]_trv")));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.sinRev;
 for testcase = [testcases]'
   assert (isequaln (...
     sinrev (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.sinRev;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (sinrev (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsupdec.sinRev;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (sinrev (in1), out));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.sinRevBin;
 for testcase = [testcases]'
   assert (isequaln (...
     sinrev (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.sinRevBin;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (sinrev (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsupdec.sinRevBin;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (sinrev (in1, in2), out));
7 tests, 7 passed, 0 known failure, 0 skipped
[inst/@infsupdec/csc.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/csc.m
***** # from the documentation string
***** assert (isequal (csc (infsupdec (1)), infsupdec ("[0x1.303AA9620B223, 0x1.303AA9620B224]_com")));
1 test, 1 passed, 0 known failure, 0 skipped
[inst/@infsupdec/dot.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/dot.m
***** # matrix  matrix
***** assert (isequal (dot (infsupdec (magic (3)), magic (3)), infsupdec([89, 107, 89])));
***** assert (isequal (dot (infsupdec (magic (3)), magic (3), 1), infsupdec([89, 107, 89])));
***** assert (isequal (dot (infsupdec (magic (3)), magic (3), 2), infsupdec([101; 83; 101])));
***** # matrix  vector
***** assert (isequal (dot (infsupdec (magic (3)), [1, 2, 3]), infsupdec([28; 34; 28])));
***** assert (isequal (dot (infsupdec (magic (3)), [1, 2, 3], 1), infsupdec([15, 30, 45])));
***** assert (isequal (dot (infsupdec (magic (3)), [1, 2, 3], 2), infsupdec([28; 34; 28])));
***** assert (isequal (dot (infsupdec (magic (3)), [1; 2; 3]), infsupdec([26, 38, 26])));
***** assert (isequal (dot (infsupdec (magic (3)), [1; 2; 3], 1), infsupdec([26, 38, 26])));
***** assert (isequal (dot (infsupdec (magic (3)), [1; 2; 3], 2), infsupdec([15; 30; 45])));
***** # matrix  scalar
***** assert (isequal (dot (infsupdec (magic (3)), 42), infsupdec([630, 630, 630])));
***** assert (isequal (dot (infsupdec (magic (3)), 42, 1), infsupdec([630, 630, 630])));
***** assert (isequal (dot (infsupdec (magic (3)), 42, 2), infsupdec([630; 630; 630])));
***** # vector x vector
***** assert (isequal (dot (infsupdec([1, 2, 3]), [4, 5, 6]), infsupdec(32)));
***** assert (isequal (dot (infsupdec([1, 2, 3]), [4, 5, 6], 1), infsupdec([4, 10, 18])));
***** assert (isequal (dot (infsupdec([1, 2, 3]), [4, 5, 6], 2), infsupdec(32)));
***** assert (isequal (dot (infsupdec([1; 2; 3]), [4; 5; 6]), infsupdec(32)));
***** assert (isequal (dot (infsupdec([1; 2; 3]), [4; 5; 6], 1), infsupdec(32)));
***** assert (isequal (dot (infsupdec([1; 2; 3]), [4; 5; 6], 2), infsupdec([4; 10; 18])));
***** # vector  scalar
***** assert (isequal (dot (infsupdec ([1, 2, 3]), 42), infsupdec(252)));
***** assert (isequal (dot (infsupdec ([1, 2, 3]), 42, 1), infsupdec([42, 84, 126])));
***** assert (isequal (dot (infsupdec ([1, 2, 3]), 42, 2), infsupdec(252)));
***** assert (isequal (dot (infsupdec ([1; 2; 3]), 42), infsupdec(252)));
***** assert (isequal (dot (infsupdec ([1; 2; 3]), 42, 1), infsupdec(252)));
***** assert (isequal (dot (infsupdec ([1; 2; 3]), 42, 2), infsupdec([42; 84; 126])));
***** # empty matrix x empty matrix
***** assert (isequal (dot (infsupdec (ones (0, 2)), infsupdec (ones (0, 2))), infsupdec ([0, 0])));
***** # N-dimensional arrays
***** test
  x = infsupdec (reshape (1:24, 2, 3, 4));
  y = infsupdec (2.*ones (2, 3, 4));
  assert (isequal (dot (x, y, 3), infsupdec ([80, 96, 112; 88, 104, 120])))
***** test
  x = infsupdec (ones (2, 2, 2, 2));
  y = infsupdec (1);
  assert (size (dot (x, y)), [1, 2, 2, 2]);
  assert (size (dot (x, y, 1)), [1, 2, 2, 2]);
  assert (size (dot (x, y, 2)), [2, 1, 2, 2]);
  assert (size (dot (x, y, 3)), [2, 2, 1, 2]);
  assert (size (dot (x, y, 4)), [2, 2, 2]);
  assert (size (dot (x, y, 5)), [2, 2, 2, 2]);
***** # from the documentation string
***** assert (isequal (dot ([infsupdec(1), 2, 3], [infsupdec(2), 3, 4]), infsupdec (20)));
***** assert (isequal (dot (infsupdec ([realmax; realmin; realmax]), [1; -1; -1], 1), infsupdec (-realmin)));
29 tests, 29 passed, 0 known failure, 0 skipped
[inst/@infsupdec/atan2rev1.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/atan2rev1.m
***** # from the documentation string
***** assert (isequal (atan2rev1 (infsupdec (1, 2), infsupdec ("pi") / 4), infsupdec ("[0x1.FFFFFFFFFFFFFp-1, 0x1.0000000000001p1]_trv")));
1 test, 1 passed, 0 known failure, 0 skipped
[inst/@infsupdec/pow.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/pow.m
***** # from the documentation string
***** assert (isequal (pow (infsupdec (5, 6), infsupdec (2, 3)), infsupdec (25, 216)));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.pow;
 for testcase = [testcases]'
   assert (isequaln (...
     pow (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.pow;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (pow (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsupdec.pow;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (pow (in1, in2), out));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsupdec/strictprecedes.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/strictprecedes.m
***** assert (strictprecedes (infsupdec (1, 1.9), infsupdec (2.1, 3)));
***** assert (not (strictprecedes (infsupdec (1, 2), infsupdec (2, 3))));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.strictPrecedes;
 for testcase = [testcases]'
   assert (isequaln (...
     strictprecedes (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.strictPrecedes;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (strictprecedes (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsupdec.strictPrecedes;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (strictprecedes (in1, in2), out));
5 tests, 5 passed, 0 known failure, 0 skipped
[inst/@infsupdec/gamma.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/gamma.m
***** # from the documentation string
***** assert (isequal (gamma (infsupdec (1.5)), infsupdec ("[0x1.C5BF891B4EF6Ap-1, 0x1.C5BF891B4EF6Bp-1]_com")));
1 test, 1 passed, 0 known failure, 0 skipped
[inst/@infsupdec/rem.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/rem.m
***** assert (isequal (rem (infsupdec (), infsupdec ()), infsupdec ()));
***** assert (isequal (rem (infsupdec (0), infsupdec ()), infsupdec ()));
***** assert (isequal (rem (infsupdec (), infsupdec (0)), infsupdec ()));
***** assert (isequal (rem (infsupdec (0), infsupdec (0)), infsupdec ()));
***** assert (isequal (rem (infsupdec (1), infsupdec (0)), infsupdec ()));
***** assert (isequal (rem (infsupdec (0, 1), infsupdec (0)), infsupdec ()));
***** assert (isequal (rem (infsupdec (1, 2), infsupdec (0)), infsupdec ()));
***** assert (isequal (rem (infsupdec (0, inf), infsupdec (0)), infsupdec ()));
***** assert (isequal (rem (infsupdec (1, inf), infsupdec (0)), infsupdec ()));
***** assert (isequal (rem (infsupdec (realmax, inf), infsupdec (0)), infsupdec ()));
***** assert (isequal (rem (infsupdec (0), infsupdec (1)), infsupdec (0)));
***** assert (isequal (rem (infsupdec (0), infsupdec (0, 1)), infsupdec (0, "trv")));
***** assert (isequal (rem (infsupdec (0), infsupdec (1, 2)), infsupdec (0)));
***** assert (isequal (rem (infsupdec (0), infsupdec (0, inf)), infsupdec (0, "trv")));
***** assert (isequal (rem (infsupdec (0), infsupdec (1, inf)), infsupdec (0, "dac")));
***** assert (isequal (rem (infsupdec (0), infsupdec (realmax, inf)), infsupdec (0, "dac")));
***** assert (isequal (rem (infsupdec (1), infsupdec (1)), infsupdec (0, "dac")));
***** assert (isequal (rem (infsupdec (2), infsupdec (1)), infsupdec (0, "dac")));
***** assert (isequal (rem (infsupdec (4), infsupdec (2)), infsupdec (0, "dac")));
***** assert (isequal (rem (infsupdec (6), infsupdec (3)), infsupdec (0, "dac")));
***** assert (isequal (rem (infsupdec (8), infsupdec (2)), infsupdec (0, "dac")));
***** assert (isequal (rem (infsupdec (9), infsupdec (3)), infsupdec (0, "dac")));
***** assert (isequal (rem (infsupdec (realmax), infsupdec (realmax)), infsupdec (0, "dac")));
***** assert (isequal (rem (infsupdec (realmax), infsupdec (realmax / 2)), infsupdec (0, "dac")));
***** assert (isequal (rem (infsupdec (realmax), infsupdec (realmax / 4)), infsupdec (0, "dac")));
***** assert (isequal (rem (infsupdec (realmax), infsupdec (realmax / 8)), infsupdec (0, "dac")));
***** assert (isequal (rem (infsupdec (realmax), infsupdec (realmax / 16)), infsupdec (0, "dac")));
***** assert (isequal (rem (infsupdec (realmax), infsupdec (realmax / 32)), infsupdec (0, "dac")));
***** assert (isequal (rem (infsupdec (0.1), infsupdec (0.1)), infsupdec (0, "dac")));
***** assert (isequal (rem (infsupdec (0.1 * 2), infsupdec (0.1)), infsupdec (0, "dac")));
***** assert (isequal (rem (infsupdec (0.1 * 4), infsupdec (0.1)), infsupdec (0, "dac")));
***** assert (isequal (rem (infsupdec (pi), infsupdec (pi)), infsupdec (0, "dac")));
***** assert (isequal (rem (infsupdec (pi), infsupdec (pi / 2)), infsupdec (0, "dac")));
***** assert (isequal (rem (infsupdec (pi), infsupdec (pi / 4)), infsupdec (0, "dac")));
***** assert (isequal (rem (infsupdec (pow2 (-1074)), infsupdec (pow2 (-1074))), infsupdec (0, "dac")));
***** assert (isequal (rem (infsupdec (pow2 (-1073)), infsupdec (pow2 (-1074))), infsupdec (0, "dac")));
***** assert (isequal (rem (infsupdec (pow2 (-1072)), infsupdec (pow2 (-1074))), infsupdec (0, "dac")));
***** assert (isequal (rem (infsupdec (1), infsupdec (2)), infsupdec (1)));
***** assert (isequal (rem (infsupdec (0.5), infsupdec (1)), infsupdec (0.5)));
***** assert (isequal (rem (infsupdec (pi), infsupdec (3.15)), infsupdec (pi)));
***** assert (isequal (rem (infsupdec (1), infsupdec (2, 3)), infsupdec (1)));
***** assert (isequal (rem (infsupdec (1), infsupdec (2, inf)), infsupdec (1, "dac")));
***** assert (isequal (rem (infsupdec (0.5), infsupdec (1, 2)), infsupdec (0.5)));
***** assert (isequal (rem (infsupdec (0.5), infsupdec (1, inf)), infsupdec (0.5, "dac")));
***** assert (isequal (rem (infsupdec (pi), infsupdec (3.15)), infsupdec (pi)));
***** assert (isequal (rem (infsupdec (pi), infsupdec (3.15, inf)), infsupdec (pi, "dac")));
***** assert (isequal (rem (infsupdec (0, 1), infsupdec (0, 1)), infsupdec (0, 1, "trv")));
***** assert (isequal (rem (infsupdec (0, 2), infsupdec (0, 1)), infsupdec (0, 1, "trv")));
***** assert (isequal (rem (infsupdec (0, 1), infsupdec (0, 2)), infsupdec (0, 1, "trv")));
***** assert (isequal (rem (infsupdec (0, realmax), infsupdec (0, realmax)), infsupdec (0, realmax, "trv")));
***** assert (isequal (rem (infsupdec (realmax, inf), infsupdec (realmax, inf)), infsupdec (0, inf, "def")));
***** assert (isequal (rem (infsupdec (0, inf), infsupdec (0, inf)), infsupdec (0, inf, "trv")));
***** assert (isequal (rem (infsupdec (0), infsupdec (1)), infsupdec (0)));
***** assert (isequal (rem (infsupdec (1), infsupdec (1)), infsupdec (0, "dac")));
***** assert (isequal (rem (infsupdec (0, 1), infsupdec (1)), infsupdec (0, 1, "def")));
***** assert (isequal (rem (infsupdec (1, 2), infsupdec (1)), infsupdec (0, 1, "def")));
***** assert (isequal (rem (infsupdec (0, inf), infsupdec (1)), infsupdec (0, 1, "def")));
***** assert (isequal (rem (infsupdec (1, inf), infsupdec (1)), infsupdec (0, 1, "def")));
***** assert (isequal (rem (infsupdec (realmax, inf), infsupdec (1)), infsupdec (0, 1, "def")));
***** assert (isequal (rem (infsupdec (1), infsupdec (1)), infsupdec (0, "dac")));
***** assert (isequal (rem (infsupdec (1), infsupdec (0, 1)), infsupdec (0, 0.5, "trv")));
***** assert (isequal (rem (infsupdec (1), infsupdec (1, 2)), infsupdec (0, 1, "def")));
***** assert (isequal (rem (infsupdec (1), infsupdec (0, inf)), infsupdec (0, 1, "trv")));
***** assert (isequal (rem (infsupdec (1), infsupdec (1, inf)), infsupdec (0, 1, "def")));
***** assert (isequal (rem (infsupdec (1), infsupdec (2, inf)), infsupdec (1, "dac")));
***** assert (isequal (rem (infsupdec (1), infsupdec (realmax, inf)), infsupdec (1, "dac")));
66 tests, 66 passed, 0 known failure, 0 skipped
[inst/@infsupdec/roundb.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/roundb.m
***** # Empty interval
***** assert (isequal (roundb (infsupdec ()), infsupdec ()));
***** # Singleton intervals
***** assert (isequal (roundb (infsupdec (0)), infsupdec (0)));
***** assert (isequal (roundb (infsupdec (0.5)), infsupdec (0, "dac")));
***** assert (isequal (roundb (infsupdec (0.25)), infsupdec (0)));
***** assert (isequal (roundb (infsupdec (0.75)), infsupdec (1)));
***** assert (isequal (roundb (infsupdec (1.5)), infsupdec (2, "dac")));
***** assert (isequal (roundb (infsupdec (-0.5)), infsupdec (0, "dac")));
***** assert (isequal (roundb (infsupdec (-1.5)), infsupdec (-2, "dac")));
***** # Bounded intervals
***** assert (isequal (roundb (infsupdec (-0.5, 0)), infsupdec (0, "dac")));
***** assert (isequal (roundb (infsupdec (0, 0.5)), infsupdec (0, "dac")));
***** assert (isequal (roundb (infsupdec (0.25, 0.5)), infsupdec (0, "dac")));
***** assert (isequal (roundb (infsupdec (-1, 0)), infsupdec (-1, 0, "def")));
***** assert (isequal (roundb (infsupdec (-1, 1)), infsupdec (-1, 1, "def")));
***** assert (isequal (roundb (infsupdec (-realmin, realmin)), infsupdec (0)));
***** assert (isequal (roundb (infsupdec (-realmax, realmax)), infsupdec (-realmax, realmax, "def")));
***** # Unbounded intervals
***** assert (isequal (roundb (infsupdec (-realmin, inf)), infsupdec (0, inf, "def")));
***** assert (isequal (roundb (infsupdec (-realmax, inf)), infsupdec (-realmax, inf, "def")));
***** assert (isequal (roundb (infsupdec (-inf, realmin)), infsupdec (-inf, 0, "def")));
***** assert (isequal (roundb (infsupdec (-inf, realmax)), infsupdec (-inf, realmax, "def")));
***** assert (isequal (roundb (infsupdec (-inf, inf)), infsupdec (-inf, inf, "def")));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.roundTiesToEven;
 for testcase = [testcases]'
   assert (isequaln (...
     roundb (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.roundTiesToEven;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (roundb (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.roundTiesToEven;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (roundb (in1), out));
23 tests, 23 passed, 0 known failure, 0 skipped
[inst/@infsupdec/times.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/times.m
***** # from the documentation string
***** assert (isequal (infsupdec (2, 3) .* infsupdec (1, 2), infsupdec (2, 6)));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.mul;
 for testcase = [testcases]'
   assert (isequaln (...
     times (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.mul;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (times (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsupdec.mul;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (times (in1, in2), out));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsupdec/lu.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/lu.m
***** test
 [l, u] = lu (infsupdec (magic (3)));
 assert (isequal (l, infsupdec ({1, 0, 0; .375, 1, 0; .5, "68/37", 1}, "trv")));, ...
 assert (subset (u, infsupdec ({8, 1, 6; 0, 4.625, 4.75; 0, 0, "-0x1.3759F2298375Bp3"}, ...
                               {8, 1, 6; 0, 4.625, 4.75; 0, 0, "-0x1.3759F22983759p3"})));
 A = magic (3);
 A ([1, 5, 9]) = 0;
 [l, u, p] = lu (infsupdec (A));
 assert (p, [0, 0, 1; 1, 0, 0; 0, 1, 0]);
 assert (isequal (l, infsupdec ({1, 0, 0; "4/3", 1, 0; 0, "1/9", 1}, "trv")));
 assert (subset (u, infsupdec ({3, 0, 7; 0, 9, "-0x1.2AAAAAAAAAAACp3"; 0, 0, "0x1.C25ED097B425Ep2"}, ...
                               {3, 0, 7; 0, 9, "-0x1.2AAAAAAAAAAAAp3"; 0, 0, "0x1.C25ED097B426p2"})));
1 test, 1 passed, 0 known failure, 0 skipped
[inst/@infsupdec/intersect.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/intersect.m
***** # from the documentation string
***** assert (isequal (intersect (infsupdec (1, 3), infsupdec (2, 4)), infsupdec (2, 3, "trv")));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.intersection;
 for testcase = [testcases]'
   assert (isequaln (...
     intersect (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.intersection;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (intersect (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsupdec.intersection;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (intersect (in1, in2), out));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsupdec/cos.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/cos.m
***** # from the documentation string
***** assert (isequal (cos (infsupdec (1)), infsupdec ("[0x1.14A280FB5068Bp-1, 0x1.14A280FB5068Cp-1]")));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.cos;
 for testcase = [testcases]'
   assert (isequaln (...
     cos (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.cos;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (cos (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.cos;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (cos (in1), out));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsupdec/eq.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/eq.m
***** # Empty interval
***** assert (eq (infsupdec (), infsupdec ()) == true);
***** assert (eq (infsupdec (), infsupdec (1)) == false);
***** assert (eq (infsupdec (0), infsupdec ()) == false);
***** assert (eq (infsupdec (-inf, inf), infsupdec ()) == false);
***** # Singleton intervals
***** assert (eq (infsupdec (0), infsupdec (1)) == false);
***** assert (eq (infsupdec (0), infsupdec (0)) == true);
***** # Bounded intervals
***** assert (eq (infsupdec (1, 2), infsupdec (3, 4)) == false);
***** assert (eq (infsupdec (1, 2), infsupdec (2, 3)) == false);
***** assert (eq (infsupdec (1, 2), infsupdec (1.5, 2.5)) == false);
***** assert (eq (infsupdec (1, 2), infsupdec (1, 2)) == true);
***** # Unbounded intervals
***** assert (eq (infsupdec (0, inf), infsupdec (-inf, 0)) == false);
***** assert (eq (infsupdec (0, inf), infsupdec (0, inf)) == true);
***** assert (eq (infsupdec (-inf, 0), infsupdec (-inf, 0)) == true);
***** assert (eq (infsupdec (-inf, inf), infsupdec (42)) == false);
***** assert (eq (infsupdec (-inf, 0), infsupdec (-inf, inf)) == false);
***** assert (eq (infsupdec (-inf, inf), infsupdec (-inf, inf)) == true);
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.equal;
 for testcase = [testcases]'
   assert (isequaln (...
     eq (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.equal;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (eq (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsupdec.equal;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (eq (in1, in2), out));
19 tests, 19 passed, 0 known failure, 0 skipped
[inst/@infsupdec/intervalpart.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/intervalpart.m
***** warning id=interval:IntvlPartOfNaI
 assert (intervalpart (nai ()) == infsup ());
***** assert (intervalpart (infsupdec (2, 3)) == infsup (2, 3));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.intervalPart;
 for testcase = [testcases]'
   assert (isequaln (...
     intervalpart (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.intervalPart;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (intervalpart (in1), out));
***** warning
 testcases = testdata.IntvlPartOfNaI.infsupdec.intervalPart;
 for testcase = [testcases]'
   lastwarn ("", "");
   assert (isequaln (...
     intervalpart (testcase.in{1}), ...
     testcase.out));
   assert (nthargout (2, @lastwarn), "interval:IntvlPartOfNaI");
 endfor
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsupdec.intervalPart;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (intervalpart (in1), out));
6 tests, 6 passed, 0 known failure, 0 skipped
[inst/@infsupdec/coth.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/coth.m
***** # from the documentation string
***** assert (isequal (coth (infsupdec (1)), infsupdec ("[0x1.50231499B6B1D, 0x1.50231499B6B1E]_com")));
1 test, 1 passed, 0 known failure, 0 skipped
[inst/@infsupdec/sech.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/sech.m
***** # from the documentation string
***** assert (isequal (sech (infsupdec (1)), infsupdec ("[0x1.4BCDC50ED6BE7p-1, 0x1.4BCDC50ED6BE8p-1]_com")));
1 test, 1 passed, 0 known failure, 0 skipped
[inst/@infsupdec/nextout.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/nextout.m
***** # from the documentation string
***** test
 x = nextout (infsupdec (1));
 assert (inf (x), 1 - eps / 2);
 assert (sup (x), 1 + eps);
 assert (decorationpart (x), {"trv"});
1 test, 1 passed, 0 known failure, 0 skipped
[inst/@infsupdec/union.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/union.m
***** # from the documentation string
***** assert (isequal (union (infsupdec (1, 3), infsupdec (2, 4)), infsupdec (1, 4, "trv")));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.convexHull;
 for testcase = [testcases]'
   assert (isequaln (...
     union (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.convexHull;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (union (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsupdec.convexHull;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (union (in1, in2), out));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsupdec/pow10.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/pow10.m
***** # from the documentation string
***** assert (isequal (pow10 (infsupdec (5)), infsupdec (100000)));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.exp10;
 for testcase = [testcases]'
   assert (isequaln (...
     pow10 (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.exp10;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (pow10 (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsupdec.exp10;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2 || i == numel (in1))
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (pow10 (in1), out));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsupdec/psi.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/psi.m
***** assert (isempty (psi (infsupdec (0))));
***** assert (isempty (psi (infsupdec (-1))));
***** assert (isempty (psi (infsupdec (-2))));
***** assert (isempty (psi (infsupdec (-3))));
***** assert (isequal (psi (infsupdec (pow2 (-1074), inf)), infsupdec ("[Entire]_dac")));
***** assert (isequal (psi (infsupdec (0, inf)), infsupdec ("[Entire]_trv")));
***** assert (isequal (psi (infsupdec (-inf, -43.23)), infsupdec ("[Entire]_trv")));
***** assert (isequal (psi (infsupdec (-1, 0)), infsupdec ("[Entire]_trv")));
***** assert (isequal (psi (infsupdec (-2, -1)), infsupdec ("[Entire]_trv")));
***** assert (isequal (psi (infsupdec (-eps, eps)), infsupdec ("[Entire]_trv")));
***** assert (isequal (psi (infsupdec (-1-eps, -1+eps)), infsupdec ("[Entire]_trv")));
***** assert (isequal (psi (infsupdec (-4.1, -3.9)), infsupdec ("[Entire]_trv")));
***** # from the documentation string
***** assert (isequal (psi (infsupdec (1)), infsupdec ("[-0x1.2788CFC6FB619p-1, -0x1.2788CFC6FB618p-1]_com")));
13 tests, 13 passed, 0 known failure, 0 skipped
[inst/@infsupdec/power.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/power.m
***** # from the documentation string
***** assert (isequal (infsupdec (-5, 6) .^ infsupdec (2, 3), infsupdec (-125, 216, "trv")));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.sqr;
 for testcase = [testcases]'
   assert (isequaln (...
     power (testcase.in{1}, 2), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.sqr;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (power (in1, 2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.sqr;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (power (in1, 2), out));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsupdec/rsqrt.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/rsqrt.m
***** # from the documentation string
***** assert (isequal (rsqrt (infsupdec (-6, 4)), infsupdec (.5, inf, "trv")));
1 test, 1 passed, 0 known failure, 0 skipped
[inst/@infsupdec/atanh.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/atanh.m
***** # from the documentation string
***** assert (isequal (atanh (infsupdec (.5)), infsupdec ("[0x1.193EA7AAD030Ap-1, 0x1.193EA7AAD030Bp-1]")));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.atanh;
 for testcase = [testcases]'
   assert (isequaln (...
     atanh (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.atanh;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (atanh (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.atanh;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (atanh (in1), out));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsupdec/sqrrev.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/sqrrev.m
***** # from the documentation string
***** assert (isequal (sqrrev (infsupdec (-2, 1)), infsupdec (-1, 1, "trv")));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.sqrRev;
 for testcase = [testcases]'
   assert (isequaln (...
     sqrrev (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.sqrRev;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (sqrrev (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsupdec.sqrRev;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (sqrrev (in1), out));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.sqrRevBin;
 for testcase = [testcases]'
   assert (isequaln (...
     sqrrev (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.sqrRevBin;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (sqrrev (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsupdec.sqrRevBin;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (sqrrev (in1, in2), out));
7 tests, 7 passed, 0 known failure, 0 skipped
[inst/@infsupdec/sign.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/sign.m
***** # from the documentation string
***** assert (isequal (sign (infsupdec (2, 3)), infsupdec (1)));
***** assert (isequal (sign (infsupdec (0)), infsupdec (0, "dac")));
***** assert (isequal (sign (infsupdec (0, 5)), infsupdec (0, 1, "def")));
***** assert (isequal (sign (infsupdec (-17)), infsupdec (-1)));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.sign;
 for testcase = [testcases]'
   assert (isequaln (...
     sign (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.sign;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (sign (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.sign;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (sign (in1), out));
7 tests, 7 passed, 0 known failure, 0 skipped
[inst/@infsupdec/subsasgn.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/subsasgn.m
***** test
 A = infsupdec (magic (3));
 A(4, 4) = 42;
 assert (inf (A), [magic(3),[0;0;0];0,0,0,42]);
 assert (sup (A), [magic(3),[0;0;0];0,0,0,42]);
 assert (decorationpart (A), {"com", "com", "com", "com"; "com", "com", "com", "com"; "com", "com", "com", "com"; "com", "com", "com", "com"});
1 test, 1 passed, 0 known failure, 0 skipped
[inst/@infsupdec/coshrev.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/coshrev.m
***** # from the documentation string
***** assert (isequal (coshrev (infsupdec (-2, 1)), infsupdec (0, "trv")));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.coshRev;
 for testcase = [testcases]'
   assert (isequaln (...
     coshrev (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.coshRev;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (coshrev (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsupdec.coshRev;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (coshrev (in1), out));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.coshRevBin;
 for testcase = [testcases]'
   assert (isequaln (...
     coshrev (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.coshRevBin;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (coshrev (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsupdec.coshRevBin;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (coshrev (in1, in2), out));
7 tests, 7 passed, 0 known failure, 0 skipped
[inst/@infsupdec/tan.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/tan.m
***** # from the documentation string
***** assert (isequal (tan (infsupdec (1)), infsupdec ("[0x1.8EB245CBEE3A5, 0x1.8EB245CBEE3A6]")));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.tan;
 for testcase = [testcases]'
   assert (isequaln (...
     tan (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.tan;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (tan (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.tan;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (tan (in1), out));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsupdec/strictsubset.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/strictsubset.m
***** assert (strictsubset (infsupdec (1, 2), infsupdec (1, 3)));
***** assert (strictsubset (infsupdec (2, 3), infsupdec (1, 3)));
***** assert (not (strictsubset (infsupdec (1, 2), infsupdec (1, 2))));
***** assert (not (strictsubset (infsupdec (1, 3), infsupdec (1, 2))));
***** assert (strictsubset (infsupdec (), infsupdec (1, 3)));
***** assert (not (strictsubset (infsupdec (), infsupdec ())));
***** assert (strictsubset (infsupdec (), infsupdec (-inf, inf)));
***** assert (strictsubset (infsupdec (0, inf), infsupdec (-inf, inf)));
***** assert (strictsubset (infsupdec (-inf, 0), infsupdec (-inf, inf)));
***** assert (not (strictsubset (infsupdec (-inf, inf), infsupdec (-inf, inf))));
10 tests, 10 passed, 0 known failure, 0 skipped
[inst/@infsupdec/subsref.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/subsref.m
***** assert (isequal (infsupdec (magic (3))([1, 2, 3]), infsupdec (magic (3)([1, 2, 3]))));
***** # from the documentation string
***** test
 x = infsupdec (magic (3), magic (3) + 1);
 assert (x(1) == infsupdec (8, 9));
 assert (x(:, 2) == infsupdec ([1; 5; 9], [2; 6; 10]));
 assert (x.inf, magic (3));
***** assert (isequal (reshape (infsupdec (1:16), 2, 2, 2, 2)(2, 7), infsupdec (14)))
***** assert (isequal (reshape (infsupdec (1:16), 2, 2, 2, 2)(:, 2, 2, 2), infsupdec ([15; 16])))
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsupdec/precedes.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/precedes.m
***** assert (precedes (infsupdec (1, 2), infsupdec (2, 3)));
***** assert (not (precedes (infsupdec (1, 2.1), infsupdec (1.9, 3))));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.precedes;
 for testcase = [testcases]'
   assert (isequaln (...
     precedes (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.precedes;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (precedes (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsupdec.precedes;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (precedes (in1, in2), out));
5 tests, 5 passed, 0 known failure, 0 skipped
[inst/@infsupdec/sup.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/sup.m
***** assert (sup (infsupdec (2.5, 3.5)), 3.5);
***** assert (sup (infsupdec ()), -inf);
***** assert (sup (infsupdec ("[nai]")), nan);
***** warning id=interval:UndefinedOperation
 assert (sup (infsupdec (3, 2)), nan);
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.sup;
 for testcase = [testcases]'
   assert (isequaln (...
     sup (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.sup;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (sup (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.sup;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (sup (in1), out));
7 tests, 7 passed, 0 known failure, 0 skipped
[inst/@infsupdec/tril.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/tril.m
***** assert (tril (infsupdec (magic (10))) == tril (magic (10)));
***** assert (tril (infsupdec (magic (10)), 1) == tril (magic (10), 1));
***** assert (tril (infsupdec (magic (10)), -1) == tril (magic (10), -1));
***** assert (tril (infsupdec (magic (10)), 0, "pack") == tril (magic (10), 0, "pack"));
***** test
 A = infsupdec (zeros (3), "trv");
 assert (decorationpart (tril (A)), {"trv", "com", "com"; "trv", "trv", "com"; "trv", "trv", "trv"});
5 tests, 5 passed, 0 known failure, 0 skipped
[inst/@infsupdec/erfc.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/erfc.m
***** # from the documentation string
***** assert (erfc (infsupdec (1)) == "[0x1.4226162FBDDD4p-3, 0x1.4226162FBDDD5p-3]");
1 test, 1 passed, 0 known failure, 0 skipped
[inst/@infsupdec/cot.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/cot.m
***** # from the documentation string
***** assert (isequal (cot (infsupdec (1)), infsupdec ("[0x1.48C05D04E1CFDp-1, 0x1.48C05D04E1CFEp-1]")));
1 test, 1 passed, 0 known failure, 0 skipped
[inst/@infsupdec/log1p.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/log1p.m
***** # from the documentation string
***** assert (isequal (log1p (infsupdec (eps)), infsupdec ("[0x1.FFFFFFFFFFFFFp-53, 0x1p-52]")));
1 test, 1 passed, 0 known failure, 0 skipped
[inst/@infsupdec/setdiff.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/setdiff.m
***** assert (isempty (setdiff (infsupdec (), infsupdec (1, 4))));
***** assert (setdiff (infsupdec (1, 3), infsupdec ()) == infsupdec (1, 3));
***** assert (isempty (setdiff (infsupdec (1, 3), infsupdec (-inf, inf))));
***** assert (isempty (setdiff (infsupdec (1, 3), infsupdec (1, 4))));
***** assert (setdiff (infsupdec (-inf, inf), infsupdec (1, 4)) == infsupdec (-inf, inf));
***** # from the documentation string
***** assert (setdiff (infsupdec (1, 3), infsupdec (2, 4)) == infsupdec (1, 2));
6 tests, 6 passed, 0 known failure, 0 skipped
[inst/@infsupdec/linspace.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/linspace.m
***** assert (isequal (linspace (infsupdec (0), infsupdec (10), 9), infsupdec (linspace (0, 10, 9))));
1 test, 1 passed, 0 known failure, 0 skipped
[inst/@infsupdec/min.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/min.m
***** # from the documentation string
***** assert (isequal (min (infsupdec (2, 3), infsupdec (1, 2)), infsupdec (1, 2)));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.min;
 for testcase = [testcases]'
   assert (isequaln (...
     min (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.min;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (min (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsupdec.min;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (min (in1, in2), out));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsupdec/disjoint.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/disjoint.m
***** assert (disjoint (infsupdec (3, 4), infsupdec (5, 6)));
***** assert (not (disjoint (infsupdec (3, 4), infsupdec (4, 5))));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.disjoint;
 for testcase = [testcases]'
   assert (isequaln (...
     disjoint (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.disjoint;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (disjoint (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsupdec.disjoint;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (disjoint (in1, in2), out));
5 tests, 5 passed, 0 known failure, 0 skipped
[inst/@infsupdec/prod.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/prod.m
***** # from the documentation string
***** assert (prod (infsupdec (1 : 4)) == 24);
***** assert (prod (infsupdec ([])) == 1);
***** assert (isequal (prod (infsupdec (magic (3))), infsupdec ([96, 45, 84])));
***** assert (isequal (prod (infsupdec (magic (3)), 2), infsupdec ([48; 105; 72])));
***** assert (isequal (prod (infsupdec (magic (3)), 3), infsupdec (magic (3))));
***** assert (isequal (prod (prod (reshape (infsup (1:24), 1, 2, 3, 4))), infsup (reshape ([720, 665280, 13366080, 96909120], 1, 1, 1, 4))));
6 tests, 6 passed, 0 known failure, 0 skipped
[inst/@infsupdec/cosh.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/cosh.m
***** # from the documentation string
***** assert (isequal (cosh (infsupdec (1)), infsupdec ("[0x1.8B07551D9F55, 0x1.8B07551D9F551]")));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.cosh;
 for testcase = [testcases]'
   assert (isequaln (...
     cosh (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.cosh;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (cosh (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.cosh;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (cosh (in1), out));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsupdec/asin.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/asin.m
***** # from the documentation string
***** assert (isequal (asin (infsupdec (.5)), infsupdec ("[0x1.0C152382D7365p-1, 0x1.0C152382D7366p-1]")));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.asin;
 for testcase = [testcases]'
   assert (isequaln (...
     asin (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.asin;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (asin (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.asin;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (asin (in1), out));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsupdec/resize.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/resize.m
***** assert (isequal (resize (infsupdec (magic (3)), 4, 2), infsupdec([8, 1; 3, 5; 4, 9; 0, 0])));
***** assert (isequal (resize (infsupdec (ones (2, 2, 2)), 4, 1, 2), infsupdec (resize (ones (2, 2, 2), 4, 1, 2))))
2 tests, 2 passed, 0 known failure, 0 skipped
[inst/@infsupdec/acos.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/acos.m
***** # from the documentation string
***** assert (isequal (acos (infsupdec (.5)), infsupdec ("[0x1.0C152382D7365, 0x1.0C152382D7366]")));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.acos;
 for testcase = [testcases]'
   assert (isequaln (...
     acos (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.acos;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (acos (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.acos;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (acos (in1), out));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsupdec/subset.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/subset.m
***** assert (subset (infsupdec (1, 2), infsupdec (1, 3)));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.subset;
 for testcase = [testcases]'
   assert (isequaln (...
     subset (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.subset;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (subset (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsupdec.subset;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (subset (in1, in2), out));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsupdec/mpower.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/mpower.m
***** # from the documentation string
***** assert (isequal (infsupdec (magic (3)) ^ 2, infsupdec (magic (3) ^ 2)));
1 test, 1 passed, 0 known failure, 0 skipped
[inst/@infsupdec/setxor.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/setxor.m
***** test
 [z, z1, z2] = setxor (infsupdec (), infsupdec ());
 assert (isempty (z));
 assert (isempty (z1));
 assert (isempty (z2));
***** test
 [z, z1, z2] = setxor (infsupdec (-inf, inf), infsupdec ());
 assert (isentire (z));
 assert (isentire (z1));
 assert (isempty (z2));
***** test
 [z, z1, z2] = setxor (infsupdec (-inf, inf), infsupdec (2));
 assert (isentire (z));
 assert (z1 == infsupdec (-inf, 2));
 assert (z2 == infsupdec (2, inf));
***** test
 [z, z1, z2] = setxor (infsupdec (2, 3), infsupdec (2));
 assert (z == infsupdec (2, 3));
 assert (z1 == infsupdec ());
 assert (z2 == infsupdec (2, 3));
***** test
 [z, z1, z2] = setxor (infsupdec (2, 3), infsupdec (2, 2.5));
 assert (z == infsupdec (2.5, 3));
 assert (z1 == infsupdec ());
 assert (z2 == infsupdec (2.5, 3));
***** test
 # from the documentation string
 [z, z1, z2] = setxor (infsupdec (1, 3), infsupdec (2, 4));
 assert (z == infsupdec (1, 4));
 assert (z1 == infsupdec (1, 2));
 assert (z2 == infsupdec (3, 4));
6 tests, 6 passed, 0 known failure, 0 skipped
[inst/@infsupdec/asinh.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/asinh.m
***** # from the documentation string
***** assert (isequal (asinh (infsupdec (1)), infsupdec ("[0x1.C34366179D426p-1, 0x1.C34366179D427p-1]")));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.asinh;
 for testcase = [testcases]'
   assert (isequaln (...
     asinh (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.asinh;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (asinh (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.asinh;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (asinh (in1), out));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsupdec/round.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/round.m
***** # Empty interval
***** assert (isequal (round (infsupdec ()), infsupdec ()));
***** # Singleton intervals
***** assert (isequal (round (infsupdec (0)), infsupdec (0)));
***** assert (isequal (round (infsupdec (0.5)), infsupdec (1, "dac")));
***** assert (isequal (round (infsupdec (0.25)), infsupdec (0)));
***** assert (isequal (round (infsupdec (0.75)), infsupdec (1)));
***** assert (isequal (round (infsupdec (-0.5)), infsupdec (-1, "dac")));
***** # Bounded intervals
***** assert (isequal (round (infsupdec (-0.5, 0)), infsupdec (-1, 0, "def")));
***** assert (isequal (round (infsupdec (0, 0.5)), infsupdec (0, 1, "def")));
***** assert (isequal (round (infsupdec (0.25, 0.5)), infsupdec (0, 1, "def")));
***** assert (isequal (round (infsupdec (-1, 0)), infsupdec (-1, 0, "def")));
***** assert (isequal (round (infsupdec (-1, 1)), infsupdec (-1, 1, "def")));
***** assert (isequal (round (infsupdec (-realmin, realmin)), infsupdec (0)));
***** assert (isequal (round (infsupdec (-realmax, realmax)), infsupdec (-realmax, realmax, "def")));
***** # Unbounded intervals
***** assert (isequal (round (infsupdec (-realmin, inf)), infsupdec (0, inf, "def")));
***** assert (isequal (round (infsupdec (-realmax, inf)), infsupdec (-realmax, inf, "def")));
***** assert (isequal (round (infsupdec (-inf, realmin)), infsupdec (-inf, 0, "def")));
***** assert (isequal (round (infsupdec (-inf, realmax)), infsupdec (-inf, realmax, "def")));
***** assert (isequal (round (infsupdec (-inf, inf)), infsupdec (-inf, inf, "def")));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.roundTiesToAway;
 for testcase = [testcases]'
   assert (isequaln (...
     round (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.roundTiesToAway;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (round (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.roundTiesToAway;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (round (in1), out));
21 tests, 21 passed, 0 known failure, 0 skipped
[inst/@infsupdec/powrev2.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/powrev2.m
***** # from the documentation string
***** assert (isequal (powrev2 (infsupdec (2, 5), infsupdec (3, 6)), infsupdec ("[0x1.5D7E8F22BA886p-1, 0x1.4AE00D1CFDEB5p1]_trv")));
1 test, 1 passed, 0 known failure, 0 skipped
[inst/@infsupdec/exp.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/exp.m
***** # from the documentation string
***** assert (isequal (exp (infsupdec (1)), infsupdec ("e")));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.exp;
 for testcase = [testcases]'
   assert (isequaln (...
     exp (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.exp;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (exp (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.exp;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (exp (in1), out));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsupdec/log2.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/log2.m
***** # from the documentation string
***** assert (isequal (log2 (infsupdec (2)), infsupdec (1)));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.log2;
 for testcase = [testcases]'
   assert (isequaln (...
     log2 (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.log2;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (log2 (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.log2;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (log2 (in1), out));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsupdec/bitunpack.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/bitunpack.m
***** test
  littleendian = bitunpack (uint16 (1))(1);
  b = zeros (1, 136);
  if (littleendian)
    b([52, 63, 117, 127, 133]) = 1;
  else
    b([7, 12, 71, 77, 133]) = 1;
  endif
  assert (bitunpack (infsupdec (3, 4)), logical (b));
1 test, 1 passed, 0 known failure, 0 skipped
[inst/@infsupdec/minus.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/minus.m
***** # from the documentation string
***** assert (isequal (infsupdec (2, 3) - infsupdec (1, 2), infsupdec (0, 2)));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.sub;
 for testcase = [testcases]'
   assert (isequaln (...
     minus (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.sub;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (minus (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsupdec.sub;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (minus (in1, in2), out));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsupdec/expm1.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/expm1.m
***** # from the documentation string
***** assert (isequal (expm1 (infsupdec (eps)), infsupdec ("[0x1p-52, 0x1.0000000000001p-52]")));
1 test, 1 passed, 0 known failure, 0 skipped
[inst/@infsupdec/interior.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/interior.m
***** assert (interior (infsupdec (1, 2), infsupdec (0, 3)));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.interior;
 for testcase = [testcases]'
   assert (isequaln (...
     interior (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.interior;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (interior (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsupdec.interior;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (interior (in1, in2), out));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsupdec/tanh.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/tanh.m
***** test "from the documentation string";
 assert (isequal (tanh (infsupdec (1)), infsupdec ("[0x1.85EFAB514F394p-1, 0x1.85EFAB514F395p-1]")));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.tanh;
 for testcase = [testcases]'
   assert (isequaln (...
     tanh (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.tanh;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (tanh (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.tanh;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (tanh (in1), out));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsupdec/log.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/log.m
***** # from the documentation string
***** assert (isequal (log (infsupdec (2)), infsupdec ("[0x1.62E42FEFA39EFp-1, 0x1.62E42FEFA39Fp-1]")));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.log;
 for testcase = [testcases]'
   assert (isequaln (...
     log (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.log;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (log (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.log;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (log (in1), out));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/midrad.m]
>>>>> /<<PKGBUILDDIR>>/inst/midrad.m
***** assert (isempty (midrad ()));
***** warning id=interval:UndefinedOperation
 assert (isnai (midrad (0, -inf)));
***** warning id=interval:UndefinedOperation
 assert (isnai (midrad (0, -.1)));
***** warning id=interval:UndefinedOperation
 assert (isnai (midrad (0, "-.1")));
***** warning id=interval:UndefinedOperation
 assert (isnai (midrad (0, infsup("-.1"))));
***** assert (isequal (midrad ("pi"), infsupdec ("pi")));
***** warning id=interval:ImplicitPromote
 assert (isequal (midrad (infsup (2), 2), infsupdec (0, 4)));
***** assert (isequal (midrad (2, infsup (2)), infsupdec (0, 4)));
***** warning id=interval:ImplicitPromote
 assert (isequal (midrad (infsup (2), infsup (2)), infsupdec (0, 4)));
***** assert (isequal (midrad (2, infsupdec (2)), infsupdec (0, 4)));
***** assert (isequal (midrad (infsupdec (2), 2), infsupdec (0, 4)));
***** warning id=interval:ImplicitPromote
 assert (isequal (midrad (infsup (2), infsupdec (2)), infsupdec (0, 4)));
***** assert (isequal (midrad (infsupdec (2), infsup (2)), infsupdec (0, 4)));
***** assert (isequal (midrad (infsupdec (2), infsupdec (2)), infsupdec (0, 4)));
***** assert (isequal (midrad (1, magic (3)), infsupdec ([-7, 0, -5; -2, -4, -6; -3, -8, -1], [9, 2, 7; 4, 6, 8; 5, 10, 3])));
***** assert (isequal (midrad (magic (3), 1), infsupdec ([7, 0, 5; 2, 4, 6; 3, 8, 1], [9, 2, 7; 4, 6, 8; 5, 10, 3])));
***** # from the documentation string
***** assert (isequal (midrad (42, 3), infsupdec (39, 45)));
***** assert (isequal (midrad (0, inf), entire ()));
***** assert (isequal (midrad ("1.1", "0.1"), infsupdec (1 - eps, "1.2")));
***** # N-dimensional arrays
***** assert (isequal (midrad (zeros (2, 2, 2), ones (2, 2, 2)), infsupdec (-ones (2, 2, 2), ones (2, 2, 2))));
***** assert (isequal (midrad (zeros (2, 2, 2), 1), infsupdec (-ones (2, 2, 2), ones (2, 2, 2))));
***** assert (isequal (midrad (0, ones (2, 2, 2)), infsupdec (-ones (2, 2, 2), ones (2, 2, 2))));
***** test
 [M, R] = midrad (infsupdec (-ones (2, 2, 2), ones (2, 2, 2)));
 assert (M, zeros (2, 2, 2));
 assert (R, ones (2, 2, 2));
23 tests, 23 passed, 0 known failure, 0 skipped
[inst/verinvnonneg.m]
>>>>> /<<PKGBUILDDIR>>/inst/verinvnonneg.m
***** assert (verinvnonneg (eye (1)), 1)
***** assert (verinvnonneg (eye (2)), 1)
***** assert (verinvnonneg (eye (3)), 1)
***** assert (verinvnonneg (eye (4)), 1)
***** assert (verinvnonneg (eye (5)), 1)
***** assert (verinvnonneg (eye (6)), 1)
***** assert (verinvnonneg (eye (7)), 1)
***** assert (verinvnonneg (eye (8)), 1)
***** assert (verinvnonneg (zeros (1)), 0)
***** assert (verinvnonneg (zeros (2)), 0)
***** assert (verinvnonneg (zeros (3)), 0)
***** assert (verinvnonneg (zeros (4)), 0)
***** assert (verinvnonneg (zeros (5)), 0)
***** assert (verinvnonneg (zeros (6)), 0)
***** assert (verinvnonneg (zeros (7)), 0)
***** assert (verinvnonneg (zeros (8)), 0)
***** assert (verinvnonneg (magic (7)), 0)
***** assert (verinvnonneg (infsup (-inf, inf)), -1)
18 tests, 18 passed, 0 known failure, 0 skipped
[inst/empty.m]
>>>>> /<<PKGBUILDDIR>>/inst/empty.m
***** assert (inf (empty ()), inf);
***** assert (sup (empty ()), -inf);
***** assert (decorationpart (empty ()), {"trv"});
***** assert (inf (empty (5)), inf (5));
***** assert (sup (empty (5)), -inf (5));
***** assert (strcmp (decorationpart (empty (5)), "trv"), true (5));
***** assert (inf (empty (5, 6)), inf (5, 6));
***** assert (sup (empty (5, 6)), -inf (5, 6));
***** assert (strcmp (decorationpart (empty (5, 6)), "trv"), true (5, 6));
***** assert (inf (empty (5, 6, 7)), inf (5, 6, 7));
***** assert (sup (empty (5, 6, 7)), -inf (5, 6, 7));
***** assert (strcmp (decorationpart (empty (5, 6, 7)), "trv"), true (5, 6, 7));
12 tests, 12 passed, 0 known failure, 0 skipped
[inst/vereigvec.m]
>>>>> /<<PKGBUILDDIR>>/inst/vereigvec.m
***** test
 A = [1 0 0; 0 1 1; 0 0 1];
 assert (vereigvec (A, [1; 0; 0]), 1);
 assert (vereigvec (A, [0; 1; 0]), 1);
 assert (vereigvec (A, [0; 0; 1]), 0);
***** test
 A = magic (3);
 [evc, lambda] = vereigvec (A, [1 1 1]);
 assert (evc, 1);
 assert (lambda == 15);
 assert (vereigvec (A, [1; 0; 0]), 0);
 assert (vereigvec (A, [0; 1; 0]), 0);
 assert (vereigvec (A, [0; 0; 1]), 0);
***** test
 A = magic (3) + infsup ("[-5, 5]");
 [evc, lambda, As] = vereigvec (A, [1 0 0]);
 assert (evc, 1);
 assert (lambda == "[3, 13]");
 assert (ismember ([8 1 6; 0 2 4; 0 5 -2], As));
 assert (max (max (wid (As))) < 1e-14);
3 tests, 3 passed, 0 known failure, 0 skipped
[inst/verlinineqnn.m]
>>>>> /<<PKGBUILDDIR>>/inst/verlinineqnn.m
***** test
 A = [-2, -3; -2, -1];
 b = [-1500; -1000];
 [x, y] = verlinineqnn (A, b);
 assert (x, [375; 250], 1e-9);
 assert (all (x >= [375; 250]));
 assert (isnan (y));
***** test
 A = [1, 2; 3, 4];
 b = [-1; 0];
 [x, y] = verlinineqnn (A, b);
 assert (y, [1; 0], 1e-9);
 assert (all (y >= [1; 0]));
 assert (isnan (x));
***** test
 A = [1, 2; 3, 4];
 b = [1; 1];
 [x, y] = verlinineqnn (A, b);
 assert (x, [0; 0]);
 assert (isnan (y));
3 tests, 3 passed, 0 known failure, 0 skipped
[inst/nai.m]
>>>>> /<<PKGBUILDDIR>>/inst/nai.m
***** assert (isnai (nai ()));
***** assert (isnai (nai (2)), true (2));
***** assert (isnai (nai (3, 4)), true (3, 4));
***** assert (decorationpart (nai ()), {"ill"});
***** assert (isnai (nai (2, 2, 2)), true (2, 2, 2))
5 tests, 5 passed, 0 known failure, 0 skipped
Checking C++ files ...
[src/intervaltotext.cc]
>>>>> /<<PKGBUILDDIR>>/src/intervaltotext.cc
***** assert (intervaltotext (infsup (1 + eps), "exact decimal"), "[1.0000000000000002220446049250313080847263336181640625]");
***** assert (intervaltotext (infsup (1 + eps), "exact hexadecimal"), "[0x1.0000000000001p+0]");
***** assert (intervaltotext (infsup (pi), "[.3g]"), "[3.14, 3.15]");
***** assert (intervaltotext (infsup (pi), "[.4g]"), "[3.141, 3.142]");
***** assert (intervaltotext (infsup (1 + eps)), "[1, 1.00001]");
***** assert (intervaltotext (infsup (1)), "[1]");
***** assert (reshape (intervaltotext (infsup (reshape (1:120, 2, 3, 4, 5))), 1, 120), intervaltotext (infsup (1:120)));
***** assert (intervaltotext (infsupdec (1 + eps), "exact decimal"), "[1.0000000000000002220446049250313080847263336181640625]_com");
***** assert (intervaltotext (infsupdec (1 + eps), "exact hexadecimal"), "[0x1.0000000000001p+0]_com");
***** assert (intervaltotext (infsupdec (1 + eps)), "[1, 1.00001]_com");
***** assert (intervaltotext (infsupdec (1)), "[1]_com");
***** assert (reshape (intervaltotext (infsupdec (reshape (1:120, 2, 3, 4, 5))), 1, 120), intervaltotext (infsupdec (1:120)));
***** assert (intervaltotext (infsup (2, 3), "[g]"), "[2, 3]");
***** assert (intervaltotext (infsup (2, 3), "9:[g]"), "[  2,  3]");
***** assert (intervaltotext (infsup (), "[g]"), "[Empty]");
***** assert (intervaltotext (infsup (), "9:[g]"), "[ Empty ]");
***** assert (intervaltotext (infsup (2, 3), "g"), "2 3");
***** assert (intervaltotext (infsupdec (2, 3), "g"), "2 3 _com");
***** assert (intervaltotext (infsup (), "[Cg]"), "[EMPTY]");
***** assert (intervaltotext (infsup (), "[cg]"), "[empty]");
***** assert (intervaltotext (infsup (-inf, inf), "[g]"), "[Entire]");
***** assert (intervaltotext (infsup (-inf, inf), "[<g]"), "[-inf, inf]");
***** assert (intervaltotext (infsup (2, 3), "[3g]"), "[  2,   3]");
***** assert (intervaltotext (infsup (2, 3), "[-3g]"), "[2  , 3  ]");
***** assert (intervaltotext (infsup (2, 3), "[03g]"), "[002, 003]");
***** assert (intervaltotext (infsup (2, 3), "[+g]"), "[+2, +3]");
***** assert (intervaltotext (infsup (2, 3), "[ g]"), "[2, 3]");
***** assert (intervaltotext (infsup (2, 3), "[g]"), "[2, 3]");
***** assert (intervaltotext (infsup (-2, 3), "[+g]"), "[-2, +3]");
***** assert (intervaltotext (infsup (-2, 3), "[ g]"), "[-2, 3]");
***** assert (intervaltotext (infsup (-2, 3), "[g]"), "[-2, +3]");
***** assert (intervaltotext (infsup (2, 3), "[f]"), "[2.000000, 3.000000]");
***** assert (intervaltotext (infsup (2, 3), "[e]"), "[2.000000e+00, 3.000000e+00]");
***** assert (intervaltotext (infsup (2, 3), "[E]"), "[2.000000E+00, 3.000000E+00]");
***** assert (intervaltotext (infsup (-inf, inf), "[<F]"), "[-INF, INF]");
***** assert (intervaltotext (infsup (2, 3), "?g"), "2.5?5");
***** assert (intervaltotext (infsup (2, 3), "9:?g"), "    2.5?5");
***** assert (intervaltotext (infsup (), "?g"), "[Empty]");
***** assert (intervaltotext (infsup (), "9:?g"), "[ Empty ]");
***** assert (intervaltotext (infsup (), "C?g"), "[EMPTY]");
***** assert (intervaltotext (infsup (), "c?g"), "[empty]");
***** assert (intervaltotext (infsup (-inf, inf), "?g"), "0??");
***** assert (intervaltotext (infsup (2, 3), "4?g"), " 2.5?5");
***** assert (intervaltotext (infsup (2, 3), "?3g"), "2.5?005");
***** assert (intervaltotext (infsup (2, 3), "04?g"), "02.5?5");
***** assert (intervaltotext (infsup (2, 3), "+?g"), "+2.5?5");
***** assert (intervaltotext (infsup (2, 3), "?f"), "2.500000?500000");
***** assert (intervaltotext (infsup (2, 3), "?e"), "2.500000?500000e+00");
***** assert (intervaltotext (infsup (2, 3), "?E"), "2.500000?500000E+00");
49 tests, 49 passed, 0 known failure, 0 skipped
[src/mpfr_linspace_d.cc]
>>>>> /<<PKGBUILDDIR>>/src/mpfr_linspace_d.cc
***** assert (mpfr_linspace_d (-inf, 1, 10, 10), 1 : 10);
***** assert (mpfr_linspace_d (inf, 1, 10, 8) - mpfr_linspace_d (-inf, 1, 10, 8), [0 2 2 4 4 4 8 0] .* eps);
2 tests, 2 passed, 0 known failure, 0 skipped
[src/mpfr_vector_sum_d.cc]
>>>>> /<<PKGBUILDDIR>>/src/mpfr_vector_sum_d.cc
***** assert (mpfr_vector_sum_d (0, [eps, realmax, realmax, -realmax, -realmax], 2), eps)
***** assert (mpfr_vector_sum_d (-inf, [eps/2, 1], 2), 1)
***** assert (mpfr_vector_sum_d (+inf, [eps/2, 1], 2), 1 + eps)
***** test
  a = inf (infsup ("0X1.1111111111111P+100"));
  b = inf (infsup ("0X1.1111111111111P+1"));
  [s, e] = mpfr_vector_sum_d (0.5, [a, b], 2);
  assert (s, a);
  assert (e, b);
***** test
  a = inf (infsup ("0X1.1111111111111P+53"));
  b = inf (infsup ("0X1.1111111111111P+1"));
  c = inf (infsup ("0X1.1111111111112P+53"));
  d = inf (infsup ("0X1.111111111111P-3"));
  [s, e] = mpfr_vector_sum_d (0.5, [a, b], 2);
  assert (s, c);
  assert (e, d);
***** test
  a = inf (infsup ("0X1.1111111111111P+2"));
  b = inf (infsup ("0X1.1111111111111P+1"));
  c = inf (infsup ("0X1.999999999999AP+2"));
  d = inf (infsup ("-0X1P-51"));
  [s, e] = mpfr_vector_sum_d (0.5, [a, b], 2);
  assert (s, c);
  assert (e, d);
***** test
  for dim = 1:6
    assert (mpfr_vector_sum_d (0.5, ones (1, 2, 3, 4, 5), dim), sum (ones (1, 2, 3, 4, 5), dim));
  endfor
***** shared testdata
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.double.sum_nearest;
 for testcase = [testcases]'
   assert (isequaln (...
     mpfr_vector_sum_d (0.5, testcase.in{1}, 2), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.double.sum_nearest;
 in1 = vertcat (testcases.in);
 in1 = cell2mat (cellfun ("postpad", in1, {(max (cellfun ("numel", in1)))}, "UniformOutput", false));
 out = vertcat (testcases.out);
 assert (isequaln (mpfr_vector_sum_d (0.5, in1, 2), out));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.double.sum_abs_nearest;
 for testcase = [testcases]'
   assert (isequaln (...
     mpfr_vector_sum_d (0.5, abs (testcase.in{1}), 2), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.double.sum_abs_nearest;
 in1 = vertcat (testcases.in);
 in1 = cell2mat (cellfun ("postpad", in1, {(max (cellfun ("numel", in1)))}, "UniformOutput", false));
 out = vertcat (testcases.out);
 assert (isequaln (mpfr_vector_sum_d (0.5, abs (in1), 2), out));
11 tests, 11 passed, 0 known failure, 0 skipped
[src/mpfr_function_d.cc]
>>>>> /<<PKGBUILDDIR>>/src/mpfr_function_d.cc
***** assert (mpfr_function_d ('plus', 0, 2, 2), 4);
***** assert (mpfr_function_d ('plus', -inf, 1, eps / 2), 1);
***** assert (mpfr_function_d ('plus', +inf, 1, eps / 2), 1 + eps);
***** error mpfr_function_d ('Krauskefarben', 0, 47, 11);
***** # Cross-check unit tests from crlibm against the MPFR library.
***** # We simulate binary64 floating-point arithmetic in MPFR
***** # with mpfr_function_d and results shall be identical.
***** #
***** shared testdata
 testdata = load (fullfile (...
   fileparts (file_in_loadpath ("__check_crlibm__.m")), ...
   "test", ...
   "crlibm.mat"));
***** function verify (fname, rnd, data)
  assert (mpfr_function_d (fname, rnd, data.input), data.output);
***** endfunction
***** test verify ("acos", -inf, testdata.acos_rd);
***** test verify ("acos", +inf, testdata.acos_ru);
***** test verify ("acos",  0.5, testdata.acos_rn);
***** test verify ("acos",  0,   testdata.acos_rz);
***** test verify ("asin", -inf, testdata.asin_rd);
***** test verify ("asin", +inf, testdata.asin_ru);
***** test verify ("asin",  0.5, testdata.asin_rn);
***** test verify ("asin",  0,   testdata.asin_rz);
***** test verify ("atan", -inf, testdata.atan_rd);
***** test verify ("atan", +inf, testdata.atan_ru);
***** test verify ("atan",  0.5, testdata.atan_rn);
***** test verify ("atan",  0,   testdata.atan_rz);
***** test verify ("cos", -inf, testdata.cos_rd);
***** test verify ("cos", +inf, testdata.cos_ru);
***** test verify ("cos",  0.5, testdata.cos_rn);
***** test verify ("cos",  0,   testdata.cos_rz);
***** test verify ("cosh", -inf, testdata.cosh_rd);
***** test verify ("cosh", +inf, testdata.cosh_ru);
***** test verify ("cosh",  0.5, testdata.cosh_rn);
***** test verify ("cosh",  0,   testdata.cosh_rz);
***** test verify ("exp", -inf, testdata.exp_rd);
***** test verify ("exp", +inf, testdata.exp_ru);
***** test verify ("exp",  0.5, testdata.exp_rn);
***** test verify ("exp",  0,   testdata.exp_rz);
***** test verify ("expm1", -inf, testdata.expm1_rd);
***** test verify ("expm1", +inf, testdata.expm1_ru);
***** test verify ("expm1",  0.5, testdata.expm1_rn);
***** test verify ("expm1",  0,   testdata.expm1_rz);
***** test verify ("log", -inf, testdata.log_rd);
***** test verify ("log", +inf, testdata.log_ru);
***** test verify ("log",  0.5, testdata.log_rn);
***** test verify ("log",  0,   testdata.log_rz);
***** test verify ("log10", -inf, testdata.log10_rd);
***** test verify ("log10", +inf, testdata.log10_ru);
***** test verify ("log10",  0.5, testdata.log10_rn);
***** test verify ("log10",  0,   testdata.log10_rz);
***** test verify ("log1p", -inf, testdata.log1p_rd);
***** test verify ("log1p", +inf, testdata.log1p_ru);
***** test verify ("log1p",  0.5, testdata.log1p_rn);
***** test verify ("log1p",  0,   testdata.log1p_rz);
***** test verify ("log2", -inf, testdata.log2_rd);
***** test verify ("log2", +inf, testdata.log2_ru);
***** test verify ("log2",  0.5, testdata.log2_rn);
***** test verify ("log2",  0,   testdata.log2_rz);
***** test verify ("sin", -inf, testdata.sin_rd);
***** test verify ("sin", +inf, testdata.sin_ru);
***** test verify ("sin",  0.5, testdata.sin_rn);
***** test verify ("sin",  0,   testdata.sin_rz);
***** test verify ("sinh", -inf, testdata.sinh_rd);
***** test verify ("sinh", +inf, testdata.sinh_ru);
***** test verify ("sinh",  0.5, testdata.sinh_rn);
***** test verify ("sinh",  0,   testdata.sinh_rz);
***** test verify ("tan", -inf, testdata.tan_rd);
***** test verify ("tan", +inf, testdata.tan_ru);
***** test verify ("tan",  0.5, testdata.tan_rn);
***** test verify ("tan",  0,   testdata.tan_rz);
60 tests, 60 passed, 0 known failure, 0 skipped
[src/mpfr_matrix_sqr_d.cc]
>>>>> /<<PKGBUILDDIR>>/src/mpfr_matrix_sqr_d.cc
***** test
 m = magic (3);
 [l, u] = mpfr_matrix_sqr_d (m, m + 1);
 assert (l, [91, 67, 67; 67, 91, 67; 67, 67, 91]);
 assert (u, [124, 100, 100; 100, 124, 100; 100, 100, 124]);
1 test, 1 passed, 0 known failure, 0 skipped
[src/crlibm_function.cc]
>>>>> /<<PKGBUILDDIR>>/src/crlibm_function.cc
***** test
  for f = {"acos", "asin", "atan", "cos", "cosh", "exp", "expm1", "log", "log10", "log1p", "log2", "sin", "sinh", "tan"}
    for rnd = {+inf, -inf, 0, 0.5}
      assert (crlibm_function (f{:}, rnd{:}, 0.5), mpfr_function_d (f{:}, rnd{:}, 0.5));
    endfor
  endfor
!!!!! test failed
ASSERT errors for:  assert (crlibm_function (f {:}, rnd {:}, 0.5),mpfr_function_d (f {:}, rnd {:}, 0.5))

  Location  |  Observed  |  Expected  |  Reason
     ()        -0.69315     -0.69315     Abs err 1.1102e-16 exceeds tol 0 by 1e-16
1 test, 0 passed, 0 known failure, 0 skipped
[src/mpfr_vector_dot_d.cc]
>>>>> /<<PKGBUILDDIR>>/src/mpfr_vector_dot_d.cc
***** test;
  [l, u] = mpfr_vector_dot_d (-1, -1, 2, 3, 1);
  assert (l, -3);
  assert (u, 6);
***** test;
  x = [realmax, realmax, -realmax, -realmax, 1, eps/2];
  y = ones (size (x));
  [l, u] = mpfr_vector_dot_d (x, y, x, y, 2);
  d = mpfr_vector_dot_d (0.5, x, y, 2);
  assert (l, 1);
  assert (u, 1 + eps);
  assert (ismember (d, infsup (l, u)));
***** test;
  [l, u] = mpfr_vector_dot_d (0, 0, inf, inf, 1);
  d = mpfr_vector_dot_d (0.5, 0, inf, 1);
  assert (l, 0);
  assert (u, inf);
  assert (isequaln (d, NaN));
***** test;
  x = reshape (1:24, 2, 3, 4);
  y = 2.*ones (2, 3, 4);
  [l u] = mpfr_vector_dot_d (x, y, x, y, 3);
  d = mpfr_vector_dot_d (0.5, x, y, 3);
  assert (l, [80, 96, 112; 88, 104, 120]);
  assert (u, [80, 96, 112; 88, 104, 120]);
  assert (d, [80, 96, 112; 88, 104, 120]);
***** shared testdata
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.double.dot_nearest;
 for testcase = [testcases]'
   assert (isequaln (...
     mpfr_vector_dot_d (0.5, testcase.in{1}, testcase.in{2}, 2), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.double.dot_nearest;
 in1 = vertcat (testcases.in)(:, 1);
 in1 = cell2mat (cellfun ("postpad", in1, {(max (cellfun ("numel", in1)))}, "UniformOutput", false));
 in2 = vertcat (testcases.in)(:, 2);
 in2 = cell2mat (cellfun ("postpad", in2, {(max (cellfun ("numel", in2)))}, "UniformOutput", false));
 out = vertcat (testcases.out);
 assert (isequaln (mpfr_vector_dot_d (0.5, in1, in2, 2), out));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.double.sum_sqr_nearest;
 for testcase = [testcases]'
   assert (isequaln (...
     mpfr_vector_dot_d (0.5, testcase.in{1}, testcase.in{1}, 2), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.double.sum_sqr_nearest;
 in1 = vertcat (testcases.in);
 in1 = cell2mat (cellfun ("postpad", in1, {(max (cellfun ("numel", in1)))}, "UniformOutput", false));
 out = vertcat (testcases.out);
 assert (isequaln (mpfr_vector_dot_d (0.5, in1, in1, 2), out));
8 tests, 8 passed, 0 known failure, 0 skipped
[src/__setround__.cc]
>>>>> /<<PKGBUILDDIR>>/src/__setround__.cc
***** xtest <Rounding-mode switches fail on your system; some matrix operations will be slower than expected>
  __setround__ (+inf);
  assert (1 + realmin > 1, true);
  assert (1 - realmin == 1, true);
  __setround__ (0.5);
***** xtest <Rounding-mode switches fail on your system; some matrix operations will be slower than expected>
  __setround__ (-inf);
  assert (1 + realmin == 1, true);
  assert (1 - realmin < 1, true);
  __setround__ (0.5);
***** test 
  __setround__ (0.5);
  assert (1 + realmin == 1, true);
  assert (1 - realmin == 1, true);
***** shared
  __setround__ (0.5);
3 tests, 3 passed, 0 known failure, 0 skipped
[src/mpfr_to_string_d.cc]
>>>>> /<<PKGBUILDDIR>>/src/mpfr_to_string_d.cc
***** test;
  [s, isexact] = mpfr_to_string_d (-inf, "decimal", .1);
  assert (s, {"0.1"});
  assert (isexact, false);
***** assert (mpfr_to_string_d (0, "exact hexadecimal", inf), {"inf"});
***** assert (mpfr_to_string_d (0, "exact hexadecimal", -inf), {"-inf"});
***** assert (mpfr_to_string_d (0, "exact hexadecimal", nan), {"nan"});
***** assert (mpfr_to_string_d (0, "exact hexadecimal", 0), {"0x0.0000000000000p+0"});
***** assert (mpfr_to_string_d (0, "exact hexadecimal", 2), {"0x1.0000000000000p+1"});
***** assert (mpfr_to_string_d (0, "exact hexadecimal", -1), {"-0x1.0000000000000p+0"});
***** assert (mpfr_to_string_d (0, "exact hexadecimal", pow2 (-1022)), {"0x1.0000000000000p-1022"});
***** assert (mpfr_to_string_d (0, "exact hexadecimal", pow2 (-1074)), {"0x0.0000000000001p-1022"});
9 tests, 9 passed, 0 known failure, 0 skipped
[src/mpfr_matrix_mul_d.cc]
>>>>> /<<PKGBUILDDIR>>/src/mpfr_matrix_mul_d.cc
***** test;
  [l, u] = mpfr_matrix_mul_d (magic (3), magic (3)', magic (3) + 1, magic (3)' + 1);
  assert (l, [101, 71, 53; 71, 83, 71; 53, 71, 101]);
  assert (u, [134, 104, 86; 104, 116, 104; 86, 104, 134]);
***** xtest;
  if (((exist ("__octave_config_info__") && ...
                __octave_config_info__.ENABLE_OPENMP) || ...
       (not (exist ("__octave_config_info__")) && ...
                  octave_config_info ("features").OPENMP)) ...
       && nproc ("overridable") > 1)
    ## OpenMP is enabled and may use more than one thread.
    ## We should observe speed-ups by that.
    A = vec (magic (2000));
    tic;
    mpfr_matrix_mul_d (A', A, A', A);
    time_per_element = toc;
    A = [A A];
    tic;
    mpfr_matrix_mul_d (A', A, A', A);
    time_per_element_parallel = toc / numel (ans);

    ## Ideally, the runtime would be cut in half (at least),
    ## however, there is an overhead, so let's be pessimistic and
    ## assume that the parallel execution is at least 20% faster.
    assert (time_per_element > 1.2 * time_per_element_parallel)
  endif
2 tests, 2 passed, 0 known failure, 0 skipped
Run tests in debian/check.m
Checking supplementary TST files ...
>>>>> processing crlibm.tst
***** test verify ("log", -inf, testdata.log_rd);
!!!!! test failed
ASSERT errors for:  assert (crlibm_function (fname, rnd, data.input),data.output)

  Location  |  Observed  |  Expected  |  Reason
    (3)       -744.4401    -744.4401     Abs err 1.1369e-13 exceeds tol 0 by 1e-13
shared variables   scalar structure containing the fields:

    testdata =

      scalar structure containing the fields:

        acos_rd =

          scalar structure containing the fields:

            input: 33x1 matrix
            output: 33x1 matrix

        acos_rn =

          scalar structure containing the fields:

            input: 110x1 matrix
            output: 110x1 matrix

        acos_ru =

          scalar structure containing the fields:

            input: 33x1 matrix
            output: 33x1 matrix

        acos_rz =

          scalar structure containing the fields:

            input: 96x1 matrix
            output: 96x1 matrix

        asin_rd =

          scalar structure containing the fields:

            input: 595x1 matrix
            output: 595x1 matrix

        asin_rn =

          scalar structure containing the fields:

            input: 748x1 matrix
            output: 748x1 matrix

        asin_ru =

          scalar structure containing the fields:

            input: 649x1 matrix
            output: 649x1 matrix

        asin_rz =

          scalar structure containing the fields:

            input: 633x1 matrix
            output: 633x1 matrix

        atan_rd =

          scalar structure containing the fields:

            input: 368x1 matrix
            output: 368x1 matrix

        atan_rn =

          scalar structure containing the fields:

            input: 5623x1 matrix
            output: 5623x1 matrix

        atan_ru =

          scalar structure containing the fields:

            input: 367x1 matrix
            output: 367x1 matrix

        atan_rz =

          scalar structure containing the fields:

            input: 494x1 matrix
            output: 494x1 matrix

        cos_rd =

          scalar structure containing the fields:

            input: 354x1 matrix
            output: 354x1 matrix

        cos_rn =

          scalar structure containing the fields:

            input: 10790x1 matrix
            output: 10790x1 matrix

        cos_ru =

          scalar structure containing the fields:

            input: 353x1 matrix
            output: 353x1 matrix

        cos_rz =

          scalar structure containing the fields:

            input: 444x1 matrix
            output: 444x1 matrix

        cosh_rd =

          scalar structure containing the fields:

            input: 495x1 matrix
            output: 495x1 matrix

        cosh_rn =

          scalar structure containing the fields:

            input: 549x1 matrix
            output: 549x1 matrix

        cosh_ru =

          scalar structure containing the fields:

            input: 495x1 matrix
            output: 495x1 matrix

        cosh_rz =

          scalar structure containing the fields:

            input: 566x1 matrix
            output: 566x1 matrix

        exp_rd =

          scalar structure containing the fields:

            input: 13x1 matrix
            output: 13x1 matrix

        exp_rn =

          scalar structure containing the fields:

            input: 4771x1 matrix
            output: 4771x1 matrix

        exp_ru =

          scalar structure containing the fields:

            input: 638x1 matrix
            output: 638x1 matrix

        exp_rz =

          scalar structure containing the fields:

            input: 718x1 matrix
            output: 718x1 matrix

        expm1_rd =

          scalar structure containing the fields:

            input: 32x1 matrix
            output: 32x1 matrix

        expm1_rn =

          scalar structure containing the fields:

            input: 239x1 matrix
            output: 239x1 matrix

        expm1_ru =

          scalar structure containing the fields:

            input: 34x1 matrix
            output: 34x1 matrix

        expm1_rz =

          scalar structure containing the fields:

            input: 427x1 matrix
            output: 427x1 matrix

        log_rd =

          scalar structure containing the fields:

            input: 28x1 matrix
            output: 28x1 matrix

        log_rn =

          scalar structure containing the fields:

            input: 1117x1 matrix
            output: 1117x1 matrix

        log_ru =

          scalar structure containing the fields:

            input: 28x1 matrix
            output: 28x1 matrix

        log_rz =

          scalar structure containing the fields:

            input: 53x1 matrix
            output: 53x1 matrix

        log10_rd =

          scalar structure containing the fields:

            input: 28x1 matrix
            output: 28x1 matrix

        log10_rn =

          scalar structure containing the fields:

            input: 52x1 matrix
            output: 52x1 matrix

        log10_ru =

          scalar structure containing the fields:

            input: 28x1 matrix
            output: 28x1 matrix

        log10_rz =

          scalar structure containing the fields:

            input: 40x1 matrix
            output: 40x1 matrix

        log1p_rd =

          scalar structure containing the fields:

            input: 8x1 matrix
            output: 8x1 matrix

        log1p_rn =

          scalar structure containing the fields:

            input: 227x1 matrix
            output: 227x1 matrix

        log1p_ru =

          scalar structure containing the fields:

            input: 8x1 matrix
            output: 8x1 matrix

        log1p_rz =

          scalar structure containing the fields:

            input: 343x1 matrix
            output: 343x1 matrix

        log2_rd =

          scalar structure containing the fields:

            input: 107x1 matrix
            output: 107x1 matrix

        log2_rn =

          scalar structure containing the fields:

            input: 104x1 matrix
            output: 104x1 matrix

        log2_ru =

          scalar structure containing the fields:

            input: 107x1 matrix
            output: 107x1 matrix

        log2_rz =

          scalar structure containing the fields:

            input: 113x1 matrix
            output: 113x1 matrix

        sin_rd =

          scalar structure containing the fields:

            input: 150x1 matrix
            output: 150x1 matrix

        sin_rn =

          scalar structure containing the fields:

            input: 10533x1 matrix
            output: 10533x1 matrix

        sin_ru =

          scalar structure containing the fields:

            input: 148x1 matrix
            output: 148x1 matrix

        sin_rz =

          scalar structure containing the fields:

            input: 186x1 matrix
            output: 186x1 matrix

        sinh_rd =

          scalar structure containing the fields:

            input: 356x1 matrix
            output: 356x1 matrix

        sinh_rn =

          scalar structure containing the fields:

            input: 416x1 matrix
            output: 416x1 matrix

        sinh_ru =

          scalar structure containing the fields:

            input: 356x1 matrix
            output: 356x1 matrix

        sinh_rz =

          scalar structure containing the fields:

            input: 415x1 matrix
            output: 415x1 matrix

        tan_rd =

          scalar structure containing the fields:

            input: 349x1 matrix
            output: 349x1 matrix

        tan_rn =

          scalar structure containing the fields:

            input: 5723x1 matrix
            output: 5723x1 matrix

        tan_ru =

          scalar structure containing the fields:

            input: 349x1 matrix
            output: 349x1 matrix

        tan_rz =

          scalar structure containing the fields:

            input: 465x1 matrix
            output: 465x1 matrix


56 tests, 55 passed, 0 known failure, 0 skipped
>>>>> processing meshgrid.tst
32 tests, 32 passed, 0 known failure, 0 skipped
Summary: 2389 tests, 2386 passed, 1 known failures, 0 skipped
Some tests failed.  Giving up...
make: *** [debian/rules:21: binary] Error 1
dpkg-buildpackage: error: debian/rules binary subprocess returned exit status 2
--------------------------------------------------------------------------------
Build finished at 2020-02-25T12:01:06Z

Finished
--------


+------------------------------------------------------------------------------+
| Cleanup                                                                      |
+------------------------------------------------------------------------------+

Purging /<<BUILDDIR>>
Not cleaning session: cloned chroot in use
E: Build failure (dpkg-buildpackage died)

+------------------------------------------------------------------------------+
| Summary                                                                      |
+------------------------------------------------------------------------------+

Build Architecture: amd64
Build Type: binary
Build-Space: 44504
Build-Time: 621
Distribution: unstable
Fail-Stage: build
Host Architecture: amd64
Install-Time: 27
Job: octave-interval_3.2.0-5
Machine Architecture: amd64
Package: octave-interval
Package-Time: 666
Source-Version: 3.2.0-5
Space: 44504
Status: attempted
Version: 3.2.0-5
--------------------------------------------------------------------------------
Finished at 2020-02-25T12:01:06Z
Build needed 00:11:06, 44504k disk space
E: Build failure (dpkg-buildpackage died)
DC-Status: Failed 666.380472987s
DC-Time-Estimation: 666.380472987 versus expected 2260 (r/m: 2.3914559198737044 ; m: 666.380472987)
