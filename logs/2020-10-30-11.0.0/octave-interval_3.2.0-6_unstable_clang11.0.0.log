DC-Build-Header: octave-interval 3.2.0-6 / 2020-10-29 19:05:38 +0000
DC-Task: type:rebuild-binarch-only source:octave-interval version:3.2.0-6 chroot:unstable esttime:666 logfile:/tmp/octave-interval_3.2.0-6_unstable_clang11.log modes:clang11:binarch-only
DC-Sbuild-call: su user42 -c 'sbuild -n --arch-any --apt-update -d unstable -v --no-run-lintian --chroot-setup-commands=/tmp/clang11 octave-interval_3.2.0-6'
sbuild (Debian sbuild) 0.78.1 (09 February 2019) on ip-172-31-4-59.eu-central-1.compute.internal

+==============================================================================+
| octave-interval 3.2.0-6 (amd64)              Thu, 29 Oct 2020 19:05:39 +0000 |
+==============================================================================+

Package: octave-interval
Version: 3.2.0-6
Source Version: 3.2.0-6
Distribution: unstable
Machine Architecture: amd64
Host Architecture: amd64
Build Architecture: amd64
Build Type: binary

I: NOTICE: Log filtering will replace 'var/run/schroot/mount/sid-amd64-sbuild-3c7de257-03f5-47ac-9e90-0b92c197f321' with '<<CHROOT>>'

+------------------------------------------------------------------------------+
| Chroot Setup Commands                                                        |
+------------------------------------------------------------------------------+


/tmp/clang11
------------

+ echo 'Entering customization script...'
Entering customization script...
+ CLANG_VERSION=10
+ echo 'Install of clang-10'
Install of clang-10
+ apt-get update
Get:1 http://127.0.0.1:12990/debian sid InRelease [146 kB]
Get:2 http://127.0.0.1:12990/debian sid/main Sources.diff/Index [734 B]
Ign:2 http://127.0.0.1:12990/debian sid/main Sources.diff/Index
Get:3 http://127.0.0.1:12990/debian sid/main amd64 Packages.diff/Index [734 B]
Ign:3 http://127.0.0.1:12990/debian sid/main amd64 Packages.diff/Index
Get:4 http://127.0.0.1:12990/debian sid/main Translation-en [6391 kB]
Get:5 http://127.0.0.1:12990/debian sid/main Sources [8989 kB]
Get:6 http://127.0.0.1:12990/debian sid/main amd64 Packages [8492 kB]
Fetched 24.0 MB in 3s (6975 kB/s)
Reading package lists...
+ apt-get install --yes --no-install-recommends --force-yes clang-10 libomp-10-dev libobjc-9-dev
Reading package lists...
Building dependency tree...
The following additional packages will be installed:
  lib32gcc-s1 lib32stdc++6 libasan5 libbsd0 libc6-i386 libclang-common-10-dev
  libclang-cpp10 libclang1-10 libedit2 libgc1 libgcc-9-dev libllvm10
  libobjc-10-dev libobjc4 libomp5-10 libz3-4
Suggested packages:
  clang-10-doc libomp-10-doc
Recommended packages:
  llvm-10-dev python3
The following NEW packages will be installed:
  clang-10 lib32gcc-s1 lib32stdc++6 libasan5 libbsd0 libc6-i386
  libclang-common-10-dev libclang-cpp10 libclang1-10 libedit2 libgc1
  libgcc-9-dev libllvm10 libobjc-10-dev libobjc-9-dev libobjc4 libomp-10-dev
  libomp5-10 libz3-4
0 upgraded, 19 newly installed, 0 to remove and 1 not upgraded.
Need to get 52.3 MB of archives.
After this operation, 274 MB of additional disk space will be used.
Get:1 http://127.0.0.1:12990/debian sid/main amd64 libbsd0 amd64 0.10.0-1 [107 kB]
Get:2 http://127.0.0.1:12990/debian sid/main amd64 libedit2 amd64 3.1-20191231-1 [95.4 kB]
Get:3 http://127.0.0.1:12990/debian sid/main amd64 libz3-4 amd64 4.8.9-1 [6783 kB]
Get:4 http://127.0.0.1:12990/debian sid/main amd64 libllvm10 amd64 1:10.0.1-7 [16.6 MB]
Get:5 http://127.0.0.1:12990/debian sid/main amd64 libclang-cpp10 amd64 1:10.0.1-7 [9069 kB]
Get:6 http://127.0.0.1:12990/debian sid/main amd64 libgc1 amd64 1:8.0.4-2.1 [239 kB]
Get:7 http://127.0.0.1:12990/debian sid/main amd64 libobjc4 amd64 10.2.0-15 [41.6 kB]
Get:8 http://127.0.0.1:12990/debian sid/main amd64 libobjc-10-dev amd64 10.2.0-15 [170 kB]
Get:9 http://127.0.0.1:12990/debian sid/main amd64 libc6-i386 amd64 2.31-4 [2815 kB]
Get:10 http://127.0.0.1:12990/debian sid/main amd64 lib32gcc-s1 amd64 10.2.0-15 [49.4 kB]
Get:11 http://127.0.0.1:12990/debian sid/main amd64 lib32stdc++6 amd64 10.2.0-15 [511 kB]
Get:12 http://127.0.0.1:12990/debian sid/main amd64 libclang-common-10-dev amd64 1:10.0.1-7 [5062 kB]
Get:13 http://127.0.0.1:12990/debian sid/main amd64 libclang1-10 amd64 1:10.0.1-7 [7293 kB]
Get:14 http://127.0.0.1:12990/debian sid/main amd64 clang-10 amd64 1:10.0.1-7 [106 kB]
Get:15 http://127.0.0.1:12990/debian sid/main amd64 libasan5 amd64 9.3.0-18 [390 kB]
Get:16 http://127.0.0.1:12990/debian sid/main amd64 libgcc-9-dev amd64 9.3.0-18 [2347 kB]
Get:17 http://127.0.0.1:12990/debian sid/main amd64 libobjc-9-dev amd64 9.3.0-18 [220 kB]
Get:18 http://127.0.0.1:12990/debian sid/main amd64 libomp5-10 amd64 1:10.0.1-7 [339 kB]
Get:19 http://127.0.0.1:12990/debian sid/main amd64 libomp-10-dev amd64 1:10.0.1-7 [86.6 kB]
debconf: delaying package configuration, since apt-utils is not installed
Fetched 52.3 MB in 0s (139 MB/s)
Selecting previously unselected package libbsd0:amd64.
(Reading database ... (Reading database ... 5%(Reading database ... 10%(Reading database ... 15%(Reading database ... 20%(Reading database ... 25%(Reading database ... 30%(Reading database ... 35%(Reading database ... 40%(Reading database ... 45%(Reading database ... 50%(Reading database ... 55%(Reading database ... 60%(Reading database ... 65%(Reading database ... 70%(Reading database ... 75%(Reading database ... 80%(Reading database ... 85%(Reading database ... 90%(Reading database ... 95%(Reading database ... 100%(Reading database ... 12312 files and directories currently installed.)
Preparing to unpack .../00-libbsd0_0.10.0-1_amd64.deb ...
Unpacking libbsd0:amd64 (0.10.0-1) ...
Selecting previously unselected package libedit2:amd64.
Preparing to unpack .../01-libedit2_3.1-20191231-1_amd64.deb ...
Unpacking libedit2:amd64 (3.1-20191231-1) ...
Selecting previously unselected package libz3-4:amd64.
Preparing to unpack .../02-libz3-4_4.8.9-1_amd64.deb ...
Unpacking libz3-4:amd64 (4.8.9-1) ...
Selecting previously unselected package libllvm10:amd64.
Preparing to unpack .../03-libllvm10_1%3a10.0.1-7_amd64.deb ...
Unpacking libllvm10:amd64 (1:10.0.1-7) ...
Selecting previously unselected package libclang-cpp10.
Preparing to unpack .../04-libclang-cpp10_1%3a10.0.1-7_amd64.deb ...
Unpacking libclang-cpp10 (1:10.0.1-7) ...
Selecting previously unselected package libgc1:amd64.
Preparing to unpack .../05-libgc1_1%3a8.0.4-2.1_amd64.deb ...
Unpacking libgc1:amd64 (1:8.0.4-2.1) ...
Selecting previously unselected package libobjc4:amd64.
Preparing to unpack .../06-libobjc4_10.2.0-15_amd64.deb ...
Unpacking libobjc4:amd64 (10.2.0-15) ...
Selecting previously unselected package libobjc-10-dev:amd64.
Preparing to unpack .../07-libobjc-10-dev_10.2.0-15_amd64.deb ...
Unpacking libobjc-10-dev:amd64 (10.2.0-15) ...
Selecting previously unselected package libc6-i386.
Preparing to unpack .../08-libc6-i386_2.31-4_amd64.deb ...
Unpacking libc6-i386 (2.31-4) ...
Selecting previously unselected package lib32gcc-s1.
Preparing to unpack .../09-lib32gcc-s1_10.2.0-15_amd64.deb ...
Unpacking lib32gcc-s1 (10.2.0-15) ...
Selecting previously unselected package lib32stdc++6.
Preparing to unpack .../10-lib32stdc++6_10.2.0-15_amd64.deb ...
Unpacking lib32stdc++6 (10.2.0-15) ...
Selecting previously unselected package libclang-common-10-dev.
Preparing to unpack .../11-libclang-common-10-dev_1%3a10.0.1-7_amd64.deb ...
Unpacking libclang-common-10-dev (1:10.0.1-7) ...
Selecting previously unselected package libclang1-10.
Preparing to unpack .../12-libclang1-10_1%3a10.0.1-7_amd64.deb ...
Unpacking libclang1-10 (1:10.0.1-7) ...
Selecting previously unselected package clang-10.
Preparing to unpack .../13-clang-10_1%3a10.0.1-7_amd64.deb ...
Unpacking clang-10 (1:10.0.1-7) ...
Selecting previously unselected package libasan5:amd64.
Preparing to unpack .../14-libasan5_9.3.0-18_amd64.deb ...
Unpacking libasan5:amd64 (9.3.0-18) ...
Selecting previously unselected package libgcc-9-dev:amd64.
Preparing to unpack .../15-libgcc-9-dev_9.3.0-18_amd64.deb ...
Unpacking libgcc-9-dev:amd64 (9.3.0-18) ...
Selecting previously unselected package libobjc-9-dev:amd64.
Preparing to unpack .../16-libobjc-9-dev_9.3.0-18_amd64.deb ...
Unpacking libobjc-9-dev:amd64 (9.3.0-18) ...
Selecting previously unselected package libomp5-10:amd64.
Preparing to unpack .../17-libomp5-10_1%3a10.0.1-7_amd64.deb ...
Unpacking libomp5-10:amd64 (1:10.0.1-7) ...
Selecting previously unselected package libomp-10-dev.
Preparing to unpack .../18-libomp-10-dev_1%3a10.0.1-7_amd64.deb ...
Unpacking libomp-10-dev (1:10.0.1-7) ...
Setting up libasan5:amd64 (9.3.0-18) ...
Setting up libz3-4:amd64 (4.8.9-1) ...
Setting up libgc1:amd64 (1:8.0.4-2.1) ...
Setting up libomp5-10:amd64 (1:10.0.1-7) ...
Setting up libc6-i386 (2.31-4) ...
Setting up libbsd0:amd64 (0.10.0-1) ...
Setting up libomp-10-dev (1:10.0.1-7) ...
Setting up libedit2:amd64 (3.1-20191231-1) ...
Setting up libobjc4:amd64 (10.2.0-15) ...
Setting up libllvm10:amd64 (1:10.0.1-7) ...
Setting up libgcc-9-dev:amd64 (9.3.0-18) ...
Setting up lib32gcc-s1 (10.2.0-15) ...
Setting up lib32stdc++6 (10.2.0-15) ...
Setting up libclang1-10 (1:10.0.1-7) ...
Setting up libobjc-9-dev:amd64 (9.3.0-18) ...
Setting up libobjc-10-dev:amd64 (10.2.0-15) ...
Setting up libclang-common-10-dev (1:10.0.1-7) ...
Setting up libclang-cpp10 (1:10.0.1-7) ...
Setting up clang-10 (1:10.0.1-7) ...
Processing triggers for libc-bin (2.31-4) ...
W: --force-yes is deprecated, use one of the options starting with --allow instead.
+ echo 'Replace gcc, g++ & cpp by clang'
Replace gcc, g++ & cpp by clang
+ VERSIONS='4.6 4.7 4.8 4.9 5 6 7 8 9 10'
+ cd /usr/bin
+ for VERSION in $VERSIONS
+ rm -f g++-4.6 gcc-4.6 cpp-4.6 gcc
+ ln -s clang++-10 g++-4.6
+ ln -s clang-10 gcc-4.6
+ ln -s clang-10 cpp-4.6
+ ln -s clang-10 gcc
+ echo 'gcc-4.6 hold'
+ dpkg --set-selections
dpkg: warning: package not in status nor available database at line 1: gcc-4.6
dpkg: warning: found unknown packages; this might mean the available database
is outdated, and needs to be updated through a frontend method;
please see the FAQ <https://wiki.debian.org/Teams/Dpkg/FAQ>
+ echo 'g++-4.6 hold'
+ dpkg --set-selections
dpkg: warning: package not in status nor available database at line 1: g++-4.6
dpkg: warning: found unknown packages; this might mean the available database
is outdated, and needs to be updated through a frontend method;
please see the FAQ <https://wiki.debian.org/Teams/Dpkg/FAQ>
+ for VERSION in $VERSIONS
+ rm -f g++-4.7 gcc-4.7 cpp-4.7 gcc
+ ln -s clang++-10 g++-4.7
+ ln -s clang-10 gcc-4.7
+ ln -s clang-10 cpp-4.7
+ ln -s clang-10 gcc
+ echo 'gcc-4.7 hold'
+ dpkg --set-selections
dpkg: warning: package not in status nor available database at line 1: gcc-4.7
dpkg: warning: found unknown packages; this might mean the available database
is outdated, and needs to be updated through a frontend method;
please see the FAQ <https://wiki.debian.org/Teams/Dpkg/FAQ>
+ echo 'g++-4.7 hold'
+ dpkg --set-selections
dpkg: warning: package not in status nor available database at line 1: g++-4.7
dpkg: warning: found unknown packages; this might mean the available database
is outdated, and needs to be updated through a frontend method;
please see the FAQ <https://wiki.debian.org/Teams/Dpkg/FAQ>
+ for VERSION in $VERSIONS
+ rm -f g++-4.8 gcc-4.8 cpp-4.8 gcc
+ ln -s clang++-10 g++-4.8
+ ln -s clang-10 gcc-4.8
+ ln -s clang-10 cpp-4.8
+ ln -s clang-10 gcc
+ echo 'gcc-4.8 hold'
+ dpkg --set-selections
dpkg: warning: package not in status nor available database at line 1: gcc-4.8
dpkg: warning: found unknown packages; this might mean the available database
is outdated, and needs to be updated through a frontend method;
please see the FAQ <https://wiki.debian.org/Teams/Dpkg/FAQ>
+ echo 'g++-4.8 hold'
+ dpkg --set-selections
dpkg: warning: package not in status nor available database at line 1: g++-4.8
dpkg: warning: found unknown packages; this might mean the available database
is outdated, and needs to be updated through a frontend method;
please see the FAQ <https://wiki.debian.org/Teams/Dpkg/FAQ>
+ for VERSION in $VERSIONS
+ rm -f g++-4.9 gcc-4.9 cpp-4.9 gcc
+ ln -s clang++-10 g++-4.9
+ ln -s clang-10 gcc-4.9
+ ln -s clang-10 cpp-4.9
+ ln -s clang-10 gcc
+ echo 'gcc-4.9 hold'
+ dpkg --set-selections
dpkg: warning: package not in status nor available database at line 1: gcc-4.9
dpkg: warning: found unknown packages; this might mean the available database
is outdated, and needs to be updated through a frontend method;
please see the FAQ <https://wiki.debian.org/Teams/Dpkg/FAQ>
+ echo 'g++-4.9 hold'
+ dpkg --set-selections
dpkg: warning: package not in status nor available database at line 1: g++-4.9
dpkg: warning: found unknown packages; this might mean the available database
is outdated, and needs to be updated through a frontend method;
please see the FAQ <https://wiki.debian.org/Teams/Dpkg/FAQ>
+ for VERSION in $VERSIONS
+ rm -f g++-5 gcc-5 cpp-5 gcc
+ ln -s clang++-10 g++-5
+ ln -s clang-10 gcc-5
+ ln -s clang-10 cpp-5
+ ln -s clang-10 gcc
+ echo 'gcc-5 hold'
+ dpkg --set-selections
dpkg: warning: package not in status nor available database at line 1: gcc-5
dpkg: warning: found unknown packages; this might mean the available database
is outdated, and needs to be updated through a frontend method;
please see the FAQ <https://wiki.debian.org/Teams/Dpkg/FAQ>
+ echo 'g++-5 hold'
+ dpkg --set-selections
dpkg: warning: package not in status nor available database at line 1: g++-5
dpkg: warning: found unknown packages; this might mean the available database
is outdated, and needs to be updated through a frontend method;
please see the FAQ <https://wiki.debian.org/Teams/Dpkg/FAQ>
+ for VERSION in $VERSIONS
+ rm -f g++-6 gcc-6 cpp-6 gcc
+ ln -s clang++-10 g++-6
+ ln -s clang-10 gcc-6
+ ln -s clang-10 cpp-6
+ ln -s clang-10 gcc
+ echo 'gcc-6 hold'
+ dpkg --set-selections
dpkg: warning: package not in status nor available database at line 1: gcc-6
dpkg: warning: found unknown packages; this might mean the available database
is outdated, and needs to be updated through a frontend method;
please see the FAQ <https://wiki.debian.org/Teams/Dpkg/FAQ>
+ echo 'g++-6 hold'
+ dpkg --set-selections
dpkg: warning: package not in status nor available database at line 1: g++-6
dpkg: warning: found unknown packages; this might mean the available database
is outdated, and needs to be updated through a frontend method;
please see the FAQ <https://wiki.debian.org/Teams/Dpkg/FAQ>
+ for VERSION in $VERSIONS
+ rm -f g++-7 gcc-7 cpp-7 gcc
+ ln -s clang++-10 g++-7
+ ln -s clang-10 gcc-7
+ ln -s clang-10 cpp-7
+ ln -s clang-10 gcc
+ echo 'gcc-7 hold'
+ dpkg --set-selections
dpkg: warning: package not in status nor available database at line 1: gcc-7
dpkg: warning: found unknown packages; this might mean the available database
is outdated, and needs to be updated through a frontend method;
please see the FAQ <https://wiki.debian.org/Teams/Dpkg/FAQ>
+ echo 'g++-7 hold'
+ dpkg --set-selections
dpkg: warning: package not in status nor available database at line 1: g++-7
dpkg: warning: found unknown packages; this might mean the available database
is outdated, and needs to be updated through a frontend method;
please see the FAQ <https://wiki.debian.org/Teams/Dpkg/FAQ>
+ for VERSION in $VERSIONS
+ rm -f g++-8 gcc-8 cpp-8 gcc
+ ln -s clang++-10 g++-8
+ ln -s clang-10 gcc-8
+ ln -s clang-10 cpp-8
+ ln -s clang-10 gcc
+ echo 'gcc-8 hold'
+ dpkg --set-selections
dpkg: warning: package not in status nor available database at line 1: gcc-8
dpkg: warning: found unknown packages; this might mean the available database
is outdated, and needs to be updated through a frontend method;
please see the FAQ <https://wiki.debian.org/Teams/Dpkg/FAQ>
+ echo 'g++-8 hold'
+ dpkg --set-selections
dpkg: warning: package not in status nor available database at line 1: g++-8
dpkg: warning: found unknown packages; this might mean the available database
is outdated, and needs to be updated through a frontend method;
please see the FAQ <https://wiki.debian.org/Teams/Dpkg/FAQ>
+ for VERSION in $VERSIONS
+ rm -f g++-9 gcc-9 cpp-9 gcc
+ ln -s clang++-10 g++-9
+ ln -s clang-10 gcc-9
+ ln -s clang-10 cpp-9
+ ln -s clang-10 gcc
+ echo 'gcc-9 hold'
+ dpkg --set-selections
dpkg: warning: package not in status nor available database at line 1: gcc-9
dpkg: warning: found unknown packages; this might mean the available database
is outdated, and needs to be updated through a frontend method;
please see the FAQ <https://wiki.debian.org/Teams/Dpkg/FAQ>
+ echo 'g++-9 hold'
+ dpkg --set-selections
dpkg: warning: package not in status nor available database at line 1: g++-9
dpkg: warning: found unknown packages; this might mean the available database
is outdated, and needs to be updated through a frontend method;
please see the FAQ <https://wiki.debian.org/Teams/Dpkg/FAQ>
+ for VERSION in $VERSIONS
+ rm -f g++-10 gcc-10 cpp-10 gcc
+ ln -s clang++-10 g++-10
+ ln -s clang-10 gcc-10
+ ln -s clang-10 cpp-10
+ ln -s clang-10 gcc
+ echo 'gcc-10 hold'
+ dpkg --set-selections
+ echo 'g++-10 hold'
+ dpkg --set-selections
+ cd -
/build/octave-interval-iz86zl
+ echo 'Check if gcc, g++ & cpp are actually clang'
Check if gcc, g++ & cpp are actually clang
+ gcc --version
+ grep clang
+ cpp --version
+ grep clang
+ g++ --version
+ grep clang
+ cd /usr/bin/
+ rm -f clang++ clang
+ ln -s clang-10 clang++
+ ln -s clang-10 clang
+ clang++ --version
Debian clang version 10.0.1-7
Target: x86_64-pc-linux-gnu
Thread model: posix
InstalledDir: /usr/bin
+ clang --version
Debian clang version 10.0.1-7
Target: x86_64-pc-linux-gnu
Thread model: posix
InstalledDir: /usr/bin
+ cd -
/build/octave-interval-iz86zl
+ apt install --yes --no-install-recommends --force-yes qt5-qmake

WARNING: apt does not have a stable CLI interface. Use with caution in scripts.

Reading package lists...
Building dependency tree...
Reading state information...
The following additional packages will be installed:
  qt5-qmake-bin qtchooser
The following NEW packages will be installed:
  qt5-qmake qt5-qmake-bin qtchooser
0 upgraded, 3 newly installed, 0 to remove and 1 not upgraded.
Need to get 1304 kB of archives.
After this operation, 4865 kB of additional disk space will be used.
Get:1 http://127.0.0.1:12990/debian sid/main amd64 qt5-qmake-bin amd64 5.14.2+dfsg-6 [1035 kB]
Get:2 http://127.0.0.1:12990/debian sid/main amd64 qtchooser amd64 66-2 [26.3 kB]
Get:3 http://127.0.0.1:12990/debian sid/main amd64 qt5-qmake amd64 5.14.2+dfsg-6 [242 kB]
debconf: delaying package configuration, since apt-utils is not installed
Fetched 1304 kB in 0s (20.2 MB/s)
Selecting previously unselected package qt5-qmake-bin.
(Reading database ... (Reading database ... 5%(Reading database ... 10%(Reading database ... 15%(Reading database ... 20%(Reading database ... 25%(Reading database ... 30%(Reading database ... 35%(Reading database ... 40%(Reading database ... 45%(Reading database ... 50%(Reading database ... 55%(Reading database ... 60%(Reading database ... 65%(Reading database ... 70%(Reading database ... 75%(Reading database ... 80%(Reading database ... 85%(Reading database ... 90%(Reading database ... 95%(Reading database ... 100%(Reading database ... 13315 files and directories currently installed.)
Preparing to unpack .../qt5-qmake-bin_5.14.2+dfsg-6_amd64.deb ...
Unpacking qt5-qmake-bin (5.14.2+dfsg-6) ...
Selecting previously unselected package qtchooser.
Preparing to unpack .../qtchooser_66-2_amd64.deb ...
Unpacking qtchooser (66-2) ...
Selecting previously unselected package qt5-qmake:amd64.
Preparing to unpack .../qt5-qmake_5.14.2+dfsg-6_amd64.deb ...
Unpacking qt5-qmake:amd64 (5.14.2+dfsg-6) ...
Setting up qt5-qmake-bin (5.14.2+dfsg-6) ...
Setting up qtchooser (66-2) ...
Setting up qt5-qmake:amd64 (5.14.2+dfsg-6) ...
W: --force-yes is deprecated, use one of the options starting with --allow instead.
+ cp /usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-clang/qmake.conf /usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-clang/qplatformdefs.h /usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++/
+ ls -al /usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++/
total 16
drwxr-xr-x  2 root root 4096 Oct 29 19:05 .
drwxr-xr-x 76 root root 4096 Oct 29 19:05 ..
-rw-r--r--  1 root root  276 Oct 29 19:05 qmake.conf
-rw-r--r--  1 root root 3218 Oct 29 19:05 qplatformdefs.h
+ cat /usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++/qmake.conf
#
# qmake configuration for linux-clang
#

MAKEFILE_GENERATOR = UNIX
CONFIG += incremental

QMAKE_INCREMENTAL_STYLE = sublib

include(../common/linux.conf)
include(../common/gcc-base-unix.conf)
include(../common/clang.conf)

QMAKE_LFLAGS += -ccc-gcc-name g++

load(qt_config)
+ export QMAKESPEC=/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-clang/
+ QMAKESPEC=/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-clang/
+ sed -i -e 's|compare_problem(2,|compare_problem(0,|g' /usr/bin/dpkg-gensymbols
+ sed -i -e 's|compare_problem(1,|compare_problem(0,|g' /usr/bin/dpkg-gensymbols
+ grep 'compare_problem(' /usr/bin/dpkg-gensymbols
        compare_problem(4, g_('new libraries appeared in the symbols file: %s'), "@libs");
        compare_problem(3, g_('some libraries disappeared in the symbols file: %s'), "@libs");
        compare_problem(0, g_('some new symbols appeared in the symbols file: %s'),
        compare_problem(0, g_('some symbols or patterns disappeared in the symbols file: %s'),

I: Finished running '/tmp/clang11'.

Finished processing commands.
--------------------------------------------------------------------------------
I: NOTICE: Log filtering will replace 'build/octave-interval-iz86zl/resolver-Pc0wE9' with '<<RESOLVERDIR>>'

+------------------------------------------------------------------------------+
| Update chroot                                                                |
+------------------------------------------------------------------------------+

Hit:1 http://127.0.0.1:12990/debian sid InRelease
Reading package lists...
Reading package lists...
Building dependency tree...
Reading state information...
Calculating upgrade...
The following packages will be upgraded:
  libdebconfclient0
1 upgraded, 0 newly installed, 0 to remove and 0 not upgraded.
Need to get 49.6 kB of archives.
After this operation, 0 B of additional disk space will be used.
Get:1 http://127.0.0.1:12990/debian sid/main amd64 libdebconfclient0 amd64 0.255 [49.6 kB]
debconf: delaying package configuration, since apt-utils is not installed
Fetched 49.6 kB in 0s (3605 kB/s)
(Reading database ... (Reading database ... 5%(Reading database ... 10%(Reading database ... 15%(Reading database ... 20%(Reading database ... 25%(Reading database ... 30%(Reading database ... 35%(Reading database ... 40%(Reading database ... 45%(Reading database ... 50%(Reading database ... 55%(Reading database ... 60%(Reading database ... 65%(Reading database ... 70%(Reading database ... 75%(Reading database ... 80%(Reading database ... 85%(Reading database ... 90%(Reading database ... 95%(Reading database ... 100%(Reading database ... 14056 files and directories currently installed.)
Preparing to unpack .../libdebconfclient0_0.255_amd64.deb ...
Unpacking libdebconfclient0:amd64 (0.255) over (0.254) ...
Setting up libdebconfclient0:amd64 (0.255) ...
Processing triggers for libc-bin (2.31-4) ...

+------------------------------------------------------------------------------+
| Fetch source files                                                           |
+------------------------------------------------------------------------------+


Check APT
---------

Checking available source versions...

Download source files with APT
------------------------------

Reading package lists...
NOTICE: 'octave-interval' packaging is maintained in the 'Git' version control system at:
https://salsa.debian.org/pkg-octave-team/octave-interval.git
Please use:
git clone https://salsa.debian.org/pkg-octave-team/octave-interval.git
to retrieve the latest (possibly unreleased) updates to the package.
Need to get 2683 kB of source archives.
Get:1 http://127.0.0.1:12990/debian sid/main octave-interval 3.2.0-6 (dsc) [2218 B]
Get:2 http://127.0.0.1:12990/debian sid/main octave-interval 3.2.0-6 (tar) [2672 kB]
Get:3 http://127.0.0.1:12990/debian sid/main octave-interval 3.2.0-6 (diff) [7828 B]
Fetched 2683 kB in 0s (15.4 MB/s)
Download complete and in download only mode
I: NOTICE: Log filtering will replace 'build/octave-interval-iz86zl/octave-interval-3.2.0' with '<<PKGBUILDDIR>>'
I: NOTICE: Log filtering will replace 'build/octave-interval-iz86zl' with '<<BUILDDIR>>'

+------------------------------------------------------------------------------+
| Install package build dependencies                                           |
+------------------------------------------------------------------------------+


Setup apt archive
-----------------

Merged Build-Depends: debhelper-compat (= 13), dh-octave (>= 0.7.1), ghostscript, libmpfr-dev (>= 3.1.0), build-essential, fakeroot, texinfo, imagemagick, gnuplot-nox
Filtered Build-Depends: debhelper-compat (= 13), dh-octave (>= 0.7.1), ghostscript, libmpfr-dev (>= 3.1.0), build-essential, fakeroot, texinfo, imagemagick, gnuplot-nox
dpkg-deb: building package 'sbuild-build-depends-main-dummy' in '/<<RESOLVERDIR>>/apt_archive/sbuild-build-depends-main-dummy.deb'.
Ign:1 copy:/<<RESOLVERDIR>>/apt_archive ./ InRelease
Get:2 copy:/<<RESOLVERDIR>>/apt_archive ./ Release [957 B]
Ign:3 copy:/<<RESOLVERDIR>>/apt_archive ./ Release.gpg
Get:4 copy:/<<RESOLVERDIR>>/apt_archive ./ Sources [439 B]
Get:5 copy:/<<RESOLVERDIR>>/apt_archive ./ Packages [510 B]
Fetched 1906 B in 0s (0 B/s)
Reading package lists...
Reading package lists...

Install main build dependencies (apt-based resolver)
----------------------------------------------------

Installing build dependencies
Reading package lists...
Building dependency tree...
Reading state information...
The following additional packages will be installed:
  aglfn autoconf automake autopoint autotools-dev bsdextrautils
  ca-certificates cme debhelper dh-autoreconf dh-octave dh-octave-autopkgtest
  dh-strip-nondeterminism diffstat dwz file fontconfig fontconfig-config
  fonts-dejavu-core fonts-freefont-otf fonts-urw-base35 gettext gettext-base
  gfortran gfortran-10 ghostscript gnuplot-data gnuplot-nox gpg gpgconf
  groff-base hdf5-helpers hicolor-icon-theme imagemagick imagemagick-6-common
  imagemagick-6.q16 intltool-debian libaec-dev libaec0 libalgorithm-c3-perl
  libaliased-perl libamd2 libaom0 libapp-cmd-perl libapt-pkg-perl
  libarchive-zip-perl libarpack2 libarray-intspan-perl libasound2
  libasound2-data libassuan0 libavahi-client3 libavahi-common-data
  libavahi-common3 libb-hooks-endofscope-perl libb-hooks-op-check-perl
  libblas-dev libblas3 libboolean-perl libbrotli1 libcairo2 libcamd2
  libcapture-tiny-perl libcarp-assert-more-perl libcarp-assert-perl
  libccolamd2 libcholmod3 libclass-c3-perl libclass-data-inheritable-perl
  libclass-load-perl libclass-method-modifiers-perl libclass-xsaccessor-perl
  libclone-choose-perl libclone-perl libcolamd2
  libconfig-model-backend-yaml-perl libconfig-model-dpkg-perl
  libconfig-model-perl libconfig-tiny-perl libconvert-binhex-perl
  libcpanel-json-xs-perl libcroco3 libcups2 libcurl3-gnutls libcxsparse3
  libdata-dpath-perl libdata-messagepack-perl libdata-optlist-perl
  libdata-section-perl libdata-validate-domain-perl libdatrie1 libdav1d4
  libdbus-1-3 libde265-0 libdebhelper-perl libdevel-callchecker-perl
  libdevel-size-perl libdevel-stacktrace-perl libdouble-conversion3
  libdrm-amdgpu1 libdrm-common libdrm-intel1 libdrm-nouveau2 libdrm-radeon1
  libdrm2 libdynaloader-functions-perl libegl-dev libegl-mesa0 libegl1 libelf1
  libemail-address-xs-perl libencode-locale-perl liberror-perl libevdev2
  libexception-class-perl libexpat1 libexporter-lite-perl
  libexporter-tiny-perl libfftw3-bin libfftw3-dev libfftw3-double3
  libfftw3-long3 libfftw3-quad3 libfftw3-single3 libfile-basedir-perl
  libfile-find-rule-perl libfile-homedir-perl libfile-listing-perl
  libfile-stripnondeterminism-perl libfile-which-perl libflac8 libfltk-gl1.3
  libfltk1.3 libfont-ttf-perl libfontconfig1 libfreetype6 libfribidi0 libgbm1
  libgd3 libgetopt-long-descriptive-perl libgfortran-10-dev libgfortran5
  libgl-dev libgl1 libgl1-mesa-dev libgl1-mesa-dri libgl2ps1.4 libglapi-mesa
  libgles-dev libgles1 libgles2 libglib2.0-0 libglpk40 libglu1-mesa
  libglvnd-dev libglvnd0 libglx-dev libglx-mesa0 libglx0 libgmp-dev
  libgmpxx4ldbl libgraphicsmagick++-q16-12 libgraphicsmagick-q16-3
  libgraphite2-3 libgs9 libgs9-common libgudev-1.0-0 libharfbuzz0b
  libhash-fieldhash-perl libhash-merge-perl libhdf5-103-1 libhdf5-cpp-103-1
  libhdf5-dev libhdf5-fortran-102 libhdf5-hl-100 libhdf5-hl-cpp-100
  libhdf5-hl-fortran-100 libheif1 libhtml-html5-entities-perl
  libhtml-parser-perl libhtml-tagset-perl libhtml-tree-perl
  libhttp-cookies-perl libhttp-date-perl libhttp-message-perl
  libhttp-negotiate-perl libice6 libicu67 libidn11 libijs-0.35
  libimport-into-perl libinput-bin libinput10 libio-html-perl
  libio-socket-ssl-perl libio-string-perl libio-stringy-perl
  libio-tiecombine-perl libipc-run3-perl libipc-system-simple-perl
  libiterator-perl libiterator-util-perl libjack-jackd2-0 libjbig0
  libjbig2dec0 libjpeg-dev libjpeg62-turbo libjpeg62-turbo-dev
  libjson-maybexs-perl libjson-perl liblapack-dev liblapack3 liblcms2-2
  libldap-2.4-2 liblist-compare-perl liblist-moreutils-perl
  liblist-someutils-perl liblist-utilsby-perl libllvm11
  liblog-any-adapter-screen-perl liblog-any-perl liblog-log4perl-perl
  liblqr-1-0 libltdl7 liblua5.4-0 liblwp-mediatypes-perl
  liblwp-protocol-https-perl liblzo2-2 libmagic-mgc libmagic1
  libmagickcore-6.q16-6 libmagickwand-6.q16-6 libmailtools-perl libmarkdown2
  libmd4c0 libmetis5 libmime-tools-perl libmodule-implementation-perl
  libmodule-pluggable-perl libmodule-runtime-perl libmoo-perl
  libmoox-aliases-perl libmoox-struct-perl libmouse-perl
  libmousex-nativetraits-perl libmousex-strictconstructor-perl libmpfr-dev
  libmro-compat-perl libmtdev1 libnamespace-autoclean-perl
  libnamespace-clean-perl libncurses-dev libncurses6 libncursesw6
  libnet-domain-tld-perl libnet-http-perl libnet-smtp-ssl-perl
  libnet-ssleay-perl libnghttp2-14 libnuma1 libnumber-compare-perl
  libnumber-range-perl libobject-id-perl liboctave-dev liboctave7 libogg0
  libopengl-dev libopengl0 libopenjp2-7 libpackage-stash-perl libpango-1.0-0
  libpangocairo-1.0-0 libpangoft2-1.0-0 libpaper1 libparams-classify-perl
  libparams-util-perl libparams-validate-perl libparse-debcontrol-perl
  libparse-recdescent-perl libpath-iterator-rule-perl libpath-tiny-perl
  libpciaccess0 libpcre2-16-0 libperlio-gzip-perl libpipeline1 libpixman-1-0
  libpng16-16 libpod-constants-perl libpod-pom-perl libportaudio2
  libproc-processtable-perl libpsl5 libpthread-stubs0-dev libqhull8.0
  libqrupdate1 libqscintilla2-qt5-15 libqscintilla2-qt5-l10n libqt5core5a
  libqt5dbus5 libqt5gui5 libqt5help5 libqt5network5 libqt5printsupport5
  libqt5sql5 libqt5widgets5 libqt5xml5 libre-engine-re2-perl libre2-8
  libreadline-dev libreadline8 libregexp-common-perl
  libregexp-pattern-license-perl libregexp-pattern-perl librole-tiny-perl
  librtmp1 libsamplerate0 libsasl2-2 libsasl2-modules-db libsensors-config
  libsensors5 libsereal-decoder-perl libsereal-encoder-perl libsigsegv2 libsm6
  libsndfile1 libsoftware-license-perl libsoftware-licensemoreutils-perl
  libsort-key-perl libsort-versions-perl libsqlite3-0 libssh2-1
  libstrictures-perl libstring-copyright-perl libstring-escape-perl
  libstring-rewriteprefix-perl libsub-exporter-perl
  libsub-exporter-progressive-perl libsub-identify-perl libsub-install-perl
  libsub-name-perl libsub-override-perl libsub-quote-perl libsub-uplevel-perl
  libsuitesparseconfig5 libsz2 libtest-exception-perl libtext-autoformat-perl
  libtext-glob-perl libtext-levenshtein-damerau-perl
  libtext-levenshteinxs-perl libtext-markdown-discount-perl
  libtext-reform-perl libtext-template-perl libtext-unidecode-perl
  libtext-xslate-perl libthai-data libthai0 libtiff5 libtime-duration-perl
  libtime-moment-perl libtimedate-perl libtool libtry-tiny-perl
  libtype-tiny-perl libuchardet0 libumfpack5 libunicode-utf8-perl liburi-perl
  libvariable-magic-perl libvorbis0a libvorbisenc2 libvulkan1 libwacom-common
  libwacom2 libwayland-client0 libwayland-server0 libwebp6 libwebpdemux2
  libwebpmux3 libwmf0.2-7 libwww-perl libwww-robotrules-perl libx11-6
  libx11-data libx11-dev libx11-xcb1 libx265-192 libxau-dev libxau6
  libxcb-dri2-0 libxcb-dri3-0 libxcb-glx0 libxcb-icccm4 libxcb-image0
  libxcb-keysyms1 libxcb-present0 libxcb-randr0 libxcb-render-util0
  libxcb-render0 libxcb-shape0 libxcb-shm0 libxcb-sync1 libxcb-util0
  libxcb-xfixes0 libxcb-xinerama0 libxcb-xinput0 libxcb-xkb1 libxcb1
  libxcb1-dev libxcursor1 libxdamage1 libxdmcp-dev libxdmcp6 libxext6
  libxfixes3 libxft2 libxinerama1 libxkbcommon-x11-0 libxkbcommon0
  libxml-libxml-perl libxml-namespacesupport-perl libxml-sax-base-perl
  libxml-sax-perl libxml2 libxpm4 libxrender1 libxshmfence1 libxxf86vm1
  libyaml-0-2 libyaml-libyaml-perl libyaml-perl libyaml-tiny-perl licensecheck
  lintian lzip lzop m4 man-db netbase octave octave-common openssl patchutils
  perl-openssl-defaults po-debconf poppler-data readline-common sensible-utils
  shared-mime-info t1utils tex-common texinfo ucf unzip x11-common
  x11proto-core-dev x11proto-dev xkb-data xorg-sgml-doctools xtrans-dev
  zlib1g-dev
Suggested packages:
  autoconf-archive gnu-standards autoconf-doc libconfig-model-cursesui-perl
  libconfig-model-itself-perl dh-make fonts-texgyre gettext-doc
  libasprintf-dev libgettextpo-dev gfortran-multilib gfortran-doc
  gfortran-10-multilib gfortran-10-doc libcoarrays-dev ghostscript-x
  gnuplot-doc groff imagemagick-doc autotrace cups-bsd | lpr | lprng curl
  enscript ffmpeg gimp grads graphviz hp2xx html2ps libwmf-bin mplayer povray
  radiance sane-utils texlive-base-bin transfig ufraw-batch xdg-utils
  libasound2-plugins alsa-utils liblapack-doc libconfig-model-openssh-perl
  libterm-readline-perl-perl | libterm-readline-gnu-perl cups-common
  libfftw3-doc libxml-parser-perl libgd-tools libiodbc2-dev
  default-libmysqlclient-dev gmp-doc libgmp10-doc graphicsmagick-dbg
  libhdf5-doc libdata-dump-perl jackd2 liblcms2-utils libdbd-csv-perl
  liblog-dispatch-filerotate-perl librrds-perl libxml-dom-perl
  libcrypt-ssleay-perl libmagickcore-6.q16-6-extra libmpfr-doc ncurses-doc
  libscalar-number-perl pciutils libqscintilla2-doc qt5-image-formats-plugins
  qtwayland5 readline-doc lm-sensors libbareword-filehandles-perl
  libindirect-perl libmultidimensional-perl libtool-doc gcj-jdk
  libdevel-lexalias-perl libwmf0.2-7-gtk libauthen-ntlm-perl libx11-doc
  libxcb-doc libyaml-shell-perl bash-completion binutils-multiarch m4-doc
  apparmor less www-browser libmail-box-perl poppler-utils
  fonts-japanese-mincho | fonts-ipafont-mincho fonts-japanese-gothic
  | fonts-ipafont-gothic fonts-arphic-ukai fonts-arphic-uming fonts-nanum
  texlive-base texlive-latex-base texlive-plain-generic
  texlive-fonts-recommended zip
Recommended packages:
  libconfig-model-approx-perl libconfig-model-lcdproc-perl
  libconfig-model-openssh-perl libconfig-model-systemd-perl
  libconfig-model-tkui-perl curl | wget | lynx fonts-liberation groff gnupg
  libmagickcore-6.q16-6-extra netpbm alsa-ucm-conf alsa-topology-conf
  libclass-c3-xs-perl bash-completion fuse libfuse-perl dbus
  libarchive-cpio-perl libglib2.0-data xdg-user-dirs gsfonts
  fonts-droid-fallback libhtml-format-perl libjson-xs-perl libldap-common
  liblist-someutils-xs-perl libipc-shareable-perl liblog-dispatch-perl libgpm2
  libauthen-sasl-perl libossp-uuid-perl libpackage-stash-xs-perl
  libpaper-utils libtie-ixhash-perl publicsuffix qttranslations5-l10n
  libqt5svg5 qt5-gtk-platformtheme libqt5sql5-sqlite | libqt5sql5-mysql
  | libqt5sql5-odbc | libqt5sql5-psql | libqt5sql5-tds | libqt5sql5-ibase
  libsasl2-modules libltdl-dev libref-util-perl libtype-tiny-xs-perl
  mesa-vulkan-drivers | vulkan-icd libwacom-bin libdata-dump-perl
  libhtml-form-perl libhttp-daemon-perl libxml-sax-expat-perl libopenblas0
  | libatlas3-base pstoedit epstool default-jre-headless octave-doc
  libmail-sendmail-perl
The following NEW packages will be installed:
  aglfn autoconf automake autopoint autotools-dev bsdextrautils
  ca-certificates cme debhelper dh-autoreconf dh-octave dh-octave-autopkgtest
  dh-strip-nondeterminism diffstat dwz file fontconfig fontconfig-config
  fonts-dejavu-core fonts-freefont-otf fonts-urw-base35 gettext gettext-base
  gfortran gfortran-10 ghostscript gnuplot-data gnuplot-nox gpg gpgconf
  groff-base hdf5-helpers hicolor-icon-theme imagemagick imagemagick-6-common
  imagemagick-6.q16 intltool-debian libaec-dev libaec0 libalgorithm-c3-perl
  libaliased-perl libamd2 libaom0 libapp-cmd-perl libapt-pkg-perl
  libarchive-zip-perl libarpack2 libarray-intspan-perl libasound2
  libasound2-data libassuan0 libavahi-client3 libavahi-common-data
  libavahi-common3 libb-hooks-endofscope-perl libb-hooks-op-check-perl
  libblas-dev libblas3 libboolean-perl libbrotli1 libcairo2 libcamd2
  libcapture-tiny-perl libcarp-assert-more-perl libcarp-assert-perl
  libccolamd2 libcholmod3 libclass-c3-perl libclass-data-inheritable-perl
  libclass-load-perl libclass-method-modifiers-perl libclass-xsaccessor-perl
  libclone-choose-perl libclone-perl libcolamd2
  libconfig-model-backend-yaml-perl libconfig-model-dpkg-perl
  libconfig-model-perl libconfig-tiny-perl libconvert-binhex-perl
  libcpanel-json-xs-perl libcroco3 libcups2 libcurl3-gnutls libcxsparse3
  libdata-dpath-perl libdata-messagepack-perl libdata-optlist-perl
  libdata-section-perl libdata-validate-domain-perl libdatrie1 libdav1d4
  libdbus-1-3 libde265-0 libdebhelper-perl libdevel-callchecker-perl
  libdevel-size-perl libdevel-stacktrace-perl libdouble-conversion3
  libdrm-amdgpu1 libdrm-common libdrm-intel1 libdrm-nouveau2 libdrm-radeon1
  libdrm2 libdynaloader-functions-perl libegl-dev libegl-mesa0 libegl1 libelf1
  libemail-address-xs-perl libencode-locale-perl liberror-perl libevdev2
  libexception-class-perl libexpat1 libexporter-lite-perl
  libexporter-tiny-perl libfftw3-bin libfftw3-dev libfftw3-double3
  libfftw3-long3 libfftw3-quad3 libfftw3-single3 libfile-basedir-perl
  libfile-find-rule-perl libfile-homedir-perl libfile-listing-perl
  libfile-stripnondeterminism-perl libfile-which-perl libflac8 libfltk-gl1.3
  libfltk1.3 libfont-ttf-perl libfontconfig1 libfreetype6 libfribidi0 libgbm1
  libgd3 libgetopt-long-descriptive-perl libgfortran-10-dev libgfortran5
  libgl-dev libgl1 libgl1-mesa-dev libgl1-mesa-dri libgl2ps1.4 libglapi-mesa
  libgles-dev libgles1 libgles2 libglib2.0-0 libglpk40 libglu1-mesa
  libglvnd-dev libglvnd0 libglx-dev libglx-mesa0 libglx0 libgmp-dev
  libgmpxx4ldbl libgraphicsmagick++-q16-12 libgraphicsmagick-q16-3
  libgraphite2-3 libgs9 libgs9-common libgudev-1.0-0 libharfbuzz0b
  libhash-fieldhash-perl libhash-merge-perl libhdf5-103-1 libhdf5-cpp-103-1
  libhdf5-dev libhdf5-fortran-102 libhdf5-hl-100 libhdf5-hl-cpp-100
  libhdf5-hl-fortran-100 libheif1 libhtml-html5-entities-perl
  libhtml-parser-perl libhtml-tagset-perl libhtml-tree-perl
  libhttp-cookies-perl libhttp-date-perl libhttp-message-perl
  libhttp-negotiate-perl libice6 libicu67 libidn11 libijs-0.35
  libimport-into-perl libinput-bin libinput10 libio-html-perl
  libio-socket-ssl-perl libio-string-perl libio-stringy-perl
  libio-tiecombine-perl libipc-run3-perl libipc-system-simple-perl
  libiterator-perl libiterator-util-perl libjack-jackd2-0 libjbig0
  libjbig2dec0 libjpeg-dev libjpeg62-turbo libjpeg62-turbo-dev
  libjson-maybexs-perl libjson-perl liblapack-dev liblapack3 liblcms2-2
  libldap-2.4-2 liblist-compare-perl liblist-moreutils-perl
  liblist-someutils-perl liblist-utilsby-perl libllvm11
  liblog-any-adapter-screen-perl liblog-any-perl liblog-log4perl-perl
  liblqr-1-0 libltdl7 liblua5.4-0 liblwp-mediatypes-perl
  liblwp-protocol-https-perl liblzo2-2 libmagic-mgc libmagic1
  libmagickcore-6.q16-6 libmagickwand-6.q16-6 libmailtools-perl libmarkdown2
  libmd4c0 libmetis5 libmime-tools-perl libmodule-implementation-perl
  libmodule-pluggable-perl libmodule-runtime-perl libmoo-perl
  libmoox-aliases-perl libmoox-struct-perl libmouse-perl
  libmousex-nativetraits-perl libmousex-strictconstructor-perl libmpfr-dev
  libmro-compat-perl libmtdev1 libnamespace-autoclean-perl
  libnamespace-clean-perl libncurses-dev libncurses6 libncursesw6
  libnet-domain-tld-perl libnet-http-perl libnet-smtp-ssl-perl
  libnet-ssleay-perl libnghttp2-14 libnuma1 libnumber-compare-perl
  libnumber-range-perl libobject-id-perl liboctave-dev liboctave7 libogg0
  libopengl-dev libopengl0 libopenjp2-7 libpackage-stash-perl libpango-1.0-0
  libpangocairo-1.0-0 libpangoft2-1.0-0 libpaper1 libparams-classify-perl
  libparams-util-perl libparams-validate-perl libparse-debcontrol-perl
  libparse-recdescent-perl libpath-iterator-rule-perl libpath-tiny-perl
  libpciaccess0 libpcre2-16-0 libperlio-gzip-perl libpipeline1 libpixman-1-0
  libpng16-16 libpod-constants-perl libpod-pom-perl libportaudio2
  libproc-processtable-perl libpsl5 libpthread-stubs0-dev libqhull8.0
  libqrupdate1 libqscintilla2-qt5-15 libqscintilla2-qt5-l10n libqt5core5a
  libqt5dbus5 libqt5gui5 libqt5help5 libqt5network5 libqt5printsupport5
  libqt5sql5 libqt5widgets5 libqt5xml5 libre-engine-re2-perl libre2-8
  libreadline-dev libreadline8 libregexp-common-perl
  libregexp-pattern-license-perl libregexp-pattern-perl librole-tiny-perl
  librtmp1 libsamplerate0 libsasl2-2 libsasl2-modules-db libsensors-config
  libsensors5 libsereal-decoder-perl libsereal-encoder-perl libsigsegv2 libsm6
  libsndfile1 libsoftware-license-perl libsoftware-licensemoreutils-perl
  libsort-key-perl libsort-versions-perl libsqlite3-0 libssh2-1
  libstrictures-perl libstring-copyright-perl libstring-escape-perl
  libstring-rewriteprefix-perl libsub-exporter-perl
  libsub-exporter-progressive-perl libsub-identify-perl libsub-install-perl
  libsub-name-perl libsub-override-perl libsub-quote-perl libsub-uplevel-perl
  libsuitesparseconfig5 libsz2 libtest-exception-perl libtext-autoformat-perl
  libtext-glob-perl libtext-levenshtein-damerau-perl
  libtext-levenshteinxs-perl libtext-markdown-discount-perl
  libtext-reform-perl libtext-template-perl libtext-unidecode-perl
  libtext-xslate-perl libthai-data libthai0 libtiff5 libtime-duration-perl
  libtime-moment-perl libtimedate-perl libtool libtry-tiny-perl
  libtype-tiny-perl libuchardet0 libumfpack5 libunicode-utf8-perl liburi-perl
  libvariable-magic-perl libvorbis0a libvorbisenc2 libvulkan1 libwacom-common
  libwacom2 libwayland-client0 libwayland-server0 libwebp6 libwebpdemux2
  libwebpmux3 libwmf0.2-7 libwww-perl libwww-robotrules-perl libx11-6
  libx11-data libx11-dev libx11-xcb1 libx265-192 libxau-dev libxau6
  libxcb-dri2-0 libxcb-dri3-0 libxcb-glx0 libxcb-icccm4 libxcb-image0
  libxcb-keysyms1 libxcb-present0 libxcb-randr0 libxcb-render-util0
  libxcb-render0 libxcb-shape0 libxcb-shm0 libxcb-sync1 libxcb-util0
  libxcb-xfixes0 libxcb-xinerama0 libxcb-xinput0 libxcb-xkb1 libxcb1
  libxcb1-dev libxcursor1 libxdamage1 libxdmcp-dev libxdmcp6 libxext6
  libxfixes3 libxft2 libxinerama1 libxkbcommon-x11-0 libxkbcommon0
  libxml-libxml-perl libxml-namespacesupport-perl libxml-sax-base-perl
  libxml-sax-perl libxml2 libxpm4 libxrender1 libxshmfence1 libxxf86vm1
  libyaml-0-2 libyaml-libyaml-perl libyaml-perl libyaml-tiny-perl licensecheck
  lintian lzip lzop m4 man-db netbase octave octave-common openssl patchutils
  perl-openssl-defaults po-debconf poppler-data readline-common
  sbuild-build-depends-main-dummy sensible-utils shared-mime-info t1utils
  tex-common texinfo ucf unzip x11-common x11proto-core-dev x11proto-dev
  xkb-data xorg-sgml-doctools xtrans-dev zlib1g-dev
0 upgraded, 462 newly installed, 0 to remove and 0 not upgraded.
Need to get 164 MB of archives.
After this operation, 634 MB of additional disk space will be used.
Get:1 copy:/<<RESOLVERDIR>>/apt_archive ./ sbuild-build-depends-main-dummy 0.invalid.0 [940 B]
Get:2 http://127.0.0.1:12990/debian sid/main amd64 bsdextrautils amd64 2.36-3+b1 [140 kB]
Get:3 http://127.0.0.1:12990/debian sid/main amd64 libuchardet0 amd64 0.0.7-1 [67.8 kB]
Get:4 http://127.0.0.1:12990/debian sid/main amd64 groff-base amd64 1.22.4-5 [920 kB]
Get:5 http://127.0.0.1:12990/debian sid/main amd64 libpipeline1 amd64 1.5.3-1 [34.3 kB]
Get:6 http://127.0.0.1:12990/debian sid/main amd64 man-db amd64 2.9.3-2 [1314 kB]
Get:7 http://127.0.0.1:12990/debian sid/main amd64 libfftw3-double3 amd64 3.3.8-2 [733 kB]
Get:8 http://127.0.0.1:12990/debian sid/main amd64 libexpat1 amd64 2.2.10-1 [96.9 kB]
Get:9 http://127.0.0.1:12990/debian sid/main amd64 libbrotli1 amd64 1.0.9-2+b1 [282 kB]
Get:10 http://127.0.0.1:12990/debian sid/main amd64 libpng16-16 amd64 1.6.37-3 [294 kB]
Get:11 http://127.0.0.1:12990/debian sid/main amd64 libfreetype6 amd64 2.10.2+dfsg-4 [410 kB]
Get:12 http://127.0.0.1:12990/debian sid/main amd64 sensible-utils all 0.0.12+nmu1 [16.0 kB]
Get:13 http://127.0.0.1:12990/debian sid/main amd64 ucf all 3.0043 [74.0 kB]
Get:14 http://127.0.0.1:12990/debian sid/main amd64 fonts-dejavu-core all 2.37-2 [1069 kB]
Get:15 http://127.0.0.1:12990/debian sid/main amd64 fonts-freefont-otf all 20120503-10 [3171 kB]
Get:16 http://127.0.0.1:12990/debian sid/main amd64 fonts-urw-base35 all 20200910-1 [6367 kB]
Get:17 http://127.0.0.1:12990/debian sid/main amd64 fontconfig-config all 2.13.1-4.2 [281 kB]
Get:18 http://127.0.0.1:12990/debian sid/main amd64 libfontconfig1 amd64 2.13.1-4.2 [347 kB]
Get:19 http://127.0.0.1:12990/debian sid/main amd64 libaom0 amd64 1.0.0.errata1-3 [1158 kB]
Get:20 http://127.0.0.1:12990/debian sid/main amd64 libdav1d4 amd64 0.7.1-3 [333 kB]
Get:21 http://127.0.0.1:12990/debian sid/main amd64 libde265-0 amd64 1.0.7-1 [242 kB]
Get:22 http://127.0.0.1:12990/debian sid/main amd64 libnuma1 amd64 2.0.12-1+b1 [26.3 kB]
Get:23 http://127.0.0.1:12990/debian sid/main amd64 libx265-192 amd64 3.4-2 [1095 kB]
Get:24 http://127.0.0.1:12990/debian sid/main amd64 libheif1 amd64 1.9.1-1 [186 kB]
Get:25 http://127.0.0.1:12990/debian sid/main amd64 libjbig0 amd64 2.1-3.1+b2 [31.0 kB]
Get:26 http://127.0.0.1:12990/debian sid/main amd64 libjpeg62-turbo amd64 1:2.0.5-1.1 [149 kB]
Get:27 http://127.0.0.1:12990/debian sid/main amd64 liblcms2-2 amd64 2.9-4+b1 [146 kB]
Get:28 http://127.0.0.1:12990/debian sid/main amd64 libglib2.0-0 amd64 2.66.1-2 [1362 kB]
Get:29 http://127.0.0.1:12990/debian sid/main amd64 liblqr-1-0 amd64 0.4.2-2.1 [29.1 kB]
Get:30 http://127.0.0.1:12990/debian sid/main amd64 libltdl7 amd64 2.4.6-14 [390 kB]
Get:31 http://127.0.0.1:12990/debian sid/main amd64 libopenjp2-7 amd64 2.3.1-1 [159 kB]
Get:32 http://127.0.0.1:12990/debian sid/main amd64 libwebp6 amd64 0.6.1-2+b1 [261 kB]
Get:33 http://127.0.0.1:12990/debian sid/main amd64 libtiff5 amd64 4.1.0+git191117-2 [271 kB]
Get:34 http://127.0.0.1:12990/debian sid/main amd64 libwebpdemux2 amd64 0.6.1-2+b1 [87.7 kB]
Get:35 http://127.0.0.1:12990/debian sid/main amd64 libwebpmux3 amd64 0.6.1-2+b1 [97.9 kB]
Get:36 http://127.0.0.1:12990/debian sid/main amd64 libxau6 amd64 1:1.0.8-1+b2 [19.9 kB]
Get:37 http://127.0.0.1:12990/debian sid/main amd64 libxdmcp6 amd64 1:1.1.2-3 [26.3 kB]
Get:38 http://127.0.0.1:12990/debian sid/main amd64 libxcb1 amd64 1.14-2 [139 kB]
Get:39 http://127.0.0.1:12990/debian sid/main amd64 libx11-data all 2:1.6.12-1 [311 kB]
Get:40 http://127.0.0.1:12990/debian sid/main amd64 libx11-6 amd64 2:1.6.12-1 [770 kB]
Get:41 http://127.0.0.1:12990/debian sid/main amd64 libxext6 amd64 2:1.3.3-1+b2 [52.5 kB]
Get:42 http://127.0.0.1:12990/debian sid/main amd64 libicu67 amd64 67.1-4 [8624 kB]
Get:43 http://127.0.0.1:12990/debian sid/main amd64 libxml2 amd64 2.9.10+dfsg-6.1 [692 kB]
Get:44 http://127.0.0.1:12990/debian sid/main amd64 imagemagick-6-common all 8:6.9.11.24+dfsg-1 [208 kB]
Get:45 http://127.0.0.1:12990/debian sid/main amd64 libmagickcore-6.q16-6 amd64 8:6.9.11.24+dfsg-1+b1 [1804 kB]
Get:46 http://127.0.0.1:12990/debian sid/main amd64 libmagickwand-6.q16-6 amd64 8:6.9.11.24+dfsg-1+b1 [448 kB]
Get:47 http://127.0.0.1:12990/debian sid/main amd64 poppler-data all 0.4.9-2 [1473 kB]
Get:48 http://127.0.0.1:12990/debian sid/main amd64 tex-common all 6.15 [53.5 kB]
Get:49 http://127.0.0.1:12990/debian sid/main amd64 readline-common all 8.0-4 [72.5 kB]
Get:50 http://127.0.0.1:12990/debian sid/main amd64 libreadline8 amd64 8.0-4 [160 kB]
Get:51 http://127.0.0.1:12990/debian sid/main amd64 netbase all 6.2 [19.9 kB]
Get:52 http://127.0.0.1:12990/debian sid/main amd64 libmagic-mgc amd64 1:5.38-5 [262 kB]
Get:53 http://127.0.0.1:12990/debian sid/main amd64 libmagic1 amd64 1:5.38-5 [120 kB]
Get:54 http://127.0.0.1:12990/debian sid/main amd64 file amd64 1:5.38-5 [67.9 kB]
Get:55 http://127.0.0.1:12990/debian sid/main amd64 gettext-base amd64 0.19.8.1-10 [123 kB]
Get:56 http://127.0.0.1:12990/debian sid/main amd64 aglfn all 1.7+git20191031.4036a9c-2 [30.5 kB]
Get:57 http://127.0.0.1:12990/debian sid/main amd64 libsigsegv2 amd64 2.12-2 [32.8 kB]
Get:58 http://127.0.0.1:12990/debian sid/main amd64 m4 amd64 1.4.18-4 [203 kB]
Get:59 http://127.0.0.1:12990/debian sid/main amd64 autoconf all 2.69-11.1 [341 kB]
Get:60 http://127.0.0.1:12990/debian sid/main amd64 autotools-dev all 20180224.1 [77.0 kB]
Get:61 http://127.0.0.1:12990/debian sid/main amd64 automake all 1:1.16.2-4 [801 kB]
Get:62 http://127.0.0.1:12990/debian sid/main amd64 autopoint all 0.19.8.1-10 [435 kB]
Get:63 http://127.0.0.1:12990/debian sid/main amd64 openssl amd64 1.1.1h-1 [848 kB]
Get:64 http://127.0.0.1:12990/debian sid/main amd64 ca-certificates all 20200601 [158 kB]
Get:65 http://127.0.0.1:12990/debian sid/main amd64 libcapture-tiny-perl all 0.48-1 [26.0 kB]
Get:66 http://127.0.0.1:12990/debian sid/main amd64 libparams-util-perl amd64 1.101-1 [25.3 kB]
Get:67 http://127.0.0.1:12990/debian sid/main amd64 libsub-install-perl all 0.928-1 [11.4 kB]
Get:68 http://127.0.0.1:12990/debian sid/main amd64 libdata-optlist-perl all 0.110-1 [10.6 kB]
Get:69 http://127.0.0.1:12990/debian sid/main amd64 libb-hooks-op-check-perl amd64 0.22-1+b2 [11.3 kB]
Get:70 http://127.0.0.1:12990/debian sid/main amd64 libdynaloader-functions-perl all 0.003-1 [12.6 kB]
Get:71 http://127.0.0.1:12990/debian sid/main amd64 libdevel-callchecker-perl amd64 0.008-1+b1 [15.9 kB]
Get:72 http://127.0.0.1:12990/debian sid/main amd64 libparams-classify-perl amd64 0.015-1+b2 [25.6 kB]
Get:73 http://127.0.0.1:12990/debian sid/main amd64 libmodule-runtime-perl all 0.016-1 [19.4 kB]
Get:74 http://127.0.0.1:12990/debian sid/main amd64 libtry-tiny-perl all 0.30-1 [23.3 kB]
Get:75 http://127.0.0.1:12990/debian sid/main amd64 libmodule-implementation-perl all 0.09-1 [12.9 kB]
Get:76 http://127.0.0.1:12990/debian sid/main amd64 libpackage-stash-perl all 0.38-1 [21.7 kB]
Get:77 http://127.0.0.1:12990/debian sid/main amd64 libclass-load-perl all 0.25-1 [16.1 kB]
Get:78 http://127.0.0.1:12990/debian sid/main amd64 libio-stringy-perl all 2.111-3 [56.5 kB]
Get:79 http://127.0.0.1:12990/debian sid/main amd64 libparams-validate-perl amd64 1.30-1 [67.5 kB]
Get:80 http://127.0.0.1:12990/debian sid/main amd64 libsub-exporter-perl all 0.987-1 [47.2 kB]
Get:81 http://127.0.0.1:12990/debian sid/main amd64 libgetopt-long-descriptive-perl all 0.105-1 [28.4 kB]
Get:82 http://127.0.0.1:12990/debian sid/main amd64 libio-tiecombine-perl all 1.005-1 [13.0 kB]
Get:83 http://127.0.0.1:12990/debian sid/main amd64 libmodule-pluggable-perl all 5.2-1 [25.7 kB]
Get:84 http://127.0.0.1:12990/debian sid/main amd64 libstring-rewriteprefix-perl all 0.008-1 [6980 B]
Get:85 http://127.0.0.1:12990/debian sid/main amd64 libapp-cmd-perl all 0.331-1 [63.9 kB]
Get:86 http://127.0.0.1:12990/debian sid/main amd64 libboolean-perl all 0.46-1 [11.1 kB]
Get:87 http://127.0.0.1:12990/debian sid/main amd64 libcarp-assert-perl all 0.21-1 [18.2 kB]
Get:88 http://127.0.0.1:12990/debian sid/main amd64 libsub-uplevel-perl all 0.2800-1 [16.3 kB]
Get:89 http://127.0.0.1:12990/debian sid/main amd64 libtest-exception-perl all 0.43-1 [18.7 kB]
Get:90 http://127.0.0.1:12990/debian sid/main amd64 libcarp-assert-more-perl all 1.24-1 [16.8 kB]
Get:91 http://127.0.0.1:12990/debian sid/main amd64 libfile-which-perl all 1.23-1 [16.6 kB]
Get:92 http://127.0.0.1:12990/debian sid/main amd64 libfile-homedir-perl all 1.006-1 [43.8 kB]
Get:93 http://127.0.0.1:12990/debian sid/main amd64 libclone-choose-perl all 0.010-1 [8424 B]
Get:94 http://127.0.0.1:12990/debian sid/main amd64 libhash-merge-perl all 0.302-1 [14.7 kB]
Get:95 http://127.0.0.1:12990/debian sid/main amd64 libjson-perl all 4.02000-2 [88.8 kB]
Get:96 http://127.0.0.1:12990/debian sid/main amd64 libexporter-tiny-perl all 1.002002-1 [37.8 kB]
Get:97 http://127.0.0.1:12990/debian sid/main amd64 liblist-moreutils-perl amd64 0.416-1+b5 [63.6 kB]
Get:98 http://127.0.0.1:12990/debian sid/main amd64 liblog-log4perl-perl all 1.53-1 [378 kB]
Get:99 http://127.0.0.1:12990/debian sid/main amd64 libmouse-perl amd64 2.5.10-1 [173 kB]
Get:100 http://127.0.0.1:12990/debian sid/main amd64 libmousex-nativetraits-perl all 1.09-2 [67.4 kB]
Get:101 http://127.0.0.1:12990/debian sid/main amd64 libmousex-strictconstructor-perl all 0.02-2 [4996 B]
Get:102 http://127.0.0.1:12990/debian sid/main amd64 libparse-recdescent-perl all 1.967015+dfsg-2 [159 kB]
Get:103 http://127.0.0.1:12990/debian sid/main amd64 libpath-tiny-perl all 0.114-1 [53.6 kB]
Get:104 http://127.0.0.1:12990/debian sid/main amd64 libpod-pom-perl all 2.01-3 [67.0 kB]
Get:105 http://127.0.0.1:12990/debian sid/main amd64 libregexp-common-perl all 2017060201-1 [177 kB]
Get:106 http://127.0.0.1:12990/debian sid/main amd64 libconfig-model-perl all 2.140-1 [463 kB]
Get:107 http://127.0.0.1:12990/debian sid/main amd64 libyaml-perl all 1.30-1 [67.7 kB]
Get:108 http://127.0.0.1:12990/debian sid/main amd64 cme all 1.032-1 [82.7 kB]
Get:109 http://127.0.0.1:12990/debian sid/main amd64 libtool all 2.4.6-14 [513 kB]
Get:110 http://127.0.0.1:12990/debian sid/main amd64 dh-autoreconf all 19 [16.9 kB]
Get:111 http://127.0.0.1:12990/debian sid/main amd64 libdebhelper-perl all 13.2.1 [188 kB]
Get:112 http://127.0.0.1:12990/debian sid/main amd64 libarchive-zip-perl all 1.68-1 [104 kB]
Get:113 http://127.0.0.1:12990/debian sid/main amd64 libsub-override-perl all 0.09-2 [10.2 kB]
Get:114 http://127.0.0.1:12990/debian sid/main amd64 libfile-stripnondeterminism-perl all 1.9.0-1 [25.5 kB]
Get:115 http://127.0.0.1:12990/debian sid/main amd64 dh-strip-nondeterminism all 1.9.0-1 [15.2 kB]
Get:116 http://127.0.0.1:12990/debian sid/main amd64 libelf1 amd64 0.181-1 [164 kB]
Get:117 http://127.0.0.1:12990/debian sid/main amd64 dwz amd64 0.13-5 [151 kB]
Get:118 http://127.0.0.1:12990/debian sid/main amd64 libcroco3 amd64 0.6.13-1 [146 kB]
Get:119 http://127.0.0.1:12990/debian sid/main amd64 gettext amd64 0.19.8.1-10 [1303 kB]
Get:120 http://127.0.0.1:12990/debian sid/main amd64 intltool-debian all 0.35.0+20060710.5 [26.8 kB]
Get:121 http://127.0.0.1:12990/debian sid/main amd64 po-debconf all 1.0.21 [248 kB]
Get:122 http://127.0.0.1:12990/debian sid/main amd64 debhelper all 13.2.1 [1007 kB]
Get:123 http://127.0.0.1:12990/debian sid/main amd64 libblas3 amd64 3.9.0-3 [153 kB]
Get:124 http://127.0.0.1:12990/debian sid/main amd64 libgfortran5 amd64 10.2.0-15 [728 kB]
Get:125 http://127.0.0.1:12990/debian sid/main amd64 liblapack3 amd64 3.9.0-3 [2166 kB]
Get:126 http://127.0.0.1:12990/debian sid/main amd64 libarpack2 amd64 3.7.0-3 [103 kB]
Get:127 http://127.0.0.1:12990/debian sid/main amd64 libsuitesparseconfig5 amd64 1:5.8.1+dfsg-2 [23.0 kB]
Get:128 http://127.0.0.1:12990/debian sid/main amd64 libamd2 amd64 1:5.8.1+dfsg-2 [35.5 kB]
Get:129 http://127.0.0.1:12990/debian sid/main amd64 libcamd2 amd64 1:5.8.1+dfsg-2 [36.9 kB]
Get:130 http://127.0.0.1:12990/debian sid/main amd64 libccolamd2 amd64 1:5.8.1+dfsg-2 [38.8 kB]
Get:131 http://127.0.0.1:12990/debian sid/main amd64 libcolamd2 amd64 1:5.8.1+dfsg-2 [32.1 kB]
Get:132 http://127.0.0.1:12990/debian sid/main amd64 libmetis5 amd64 5.1.0.dfsg-7 [171 kB]
Get:133 http://127.0.0.1:12990/debian sid/main amd64 libcholmod3 amd64 1:5.8.1+dfsg-2 [339 kB]
Get:134 http://127.0.0.1:12990/debian sid/main amd64 libsasl2-modules-db amd64 2.1.27+dfsg-2 [69.0 kB]
Get:135 http://127.0.0.1:12990/debian sid/main amd64 libsasl2-2 amd64 2.1.27+dfsg-2 [106 kB]
Get:136 http://127.0.0.1:12990/debian sid/main amd64 libldap-2.4-2 amd64 2.4.54+dfsg-1 [231 kB]
Get:137 http://127.0.0.1:12990/debian sid/main amd64 libnghttp2-14 amd64 1.41.0-3 [74.0 kB]
Get:138 http://127.0.0.1:12990/debian sid/main amd64 libpsl5 amd64 0.21.0-1.1 [55.3 kB]
Get:139 http://127.0.0.1:12990/debian sid/main amd64 librtmp1 amd64 2.4+20151223.gitfa8646d.1-2+b2 [60.8 kB]
Get:140 http://127.0.0.1:12990/debian sid/main amd64 libssh2-1 amd64 1.8.0-2.1 [140 kB]
Get:141 http://127.0.0.1:12990/debian sid/main amd64 libcurl3-gnutls amd64 7.72.0-1 [333 kB]
Get:142 http://127.0.0.1:12990/debian sid/main amd64 libcxsparse3 amd64 1:5.8.1+dfsg-2 [80.0 kB]
Get:143 http://127.0.0.1:12990/debian sid/main amd64 libfftw3-single3 amd64 3.3.8-2 [762 kB]
Get:144 http://127.0.0.1:12990/debian sid/main amd64 libglvnd0 amd64 1.3.2-1 [53.6 kB]
Get:145 http://127.0.0.1:12990/debian sid/main amd64 libdrm-common all 2.4.102-1 [14.5 kB]
Get:146 http://127.0.0.1:12990/debian sid/main amd64 libdrm2 amd64 2.4.102-1 [41.5 kB]
Get:147 http://127.0.0.1:12990/debian sid/main amd64 libglapi-mesa amd64 20.2.1-1 [71.0 kB]
Get:148 http://127.0.0.1:12990/debian sid/main amd64 libx11-xcb1 amd64 2:1.6.12-1 [203 kB]
Get:149 http://127.0.0.1:12990/debian sid/main amd64 libxcb-dri2-0 amd64 1.14-2 [103 kB]
Get:150 http://127.0.0.1:12990/debian sid/main amd64 libxcb-dri3-0 amd64 1.14-2 [102 kB]
Get:151 http://127.0.0.1:12990/debian sid/main amd64 libxcb-glx0 amd64 1.14-2 [118 kB]
Get:152 http://127.0.0.1:12990/debian sid/main amd64 libxcb-present0 amd64 1.14-2 [101 kB]
Get:153 http://127.0.0.1:12990/debian sid/main amd64 libxcb-sync1 amd64 1.14-2 [105 kB]
Get:154 http://127.0.0.1:12990/debian sid/main amd64 libxcb-xfixes0 amd64 1.14-2 [105 kB]
Get:155 http://127.0.0.1:12990/debian sid/main amd64 libxdamage1 amd64 1:1.1.5-2 [15.7 kB]
Get:156 http://127.0.0.1:12990/debian sid/main amd64 libxfixes3 amd64 1:5.0.3-2 [22.1 kB]
Get:157 http://127.0.0.1:12990/debian sid/main amd64 libxshmfence1 amd64 1.3-1 [8820 B]
Get:158 http://127.0.0.1:12990/debian sid/main amd64 libxxf86vm1 amd64 1:1.1.4-1+b2 [20.8 kB]
Get:159 http://127.0.0.1:12990/debian sid/main amd64 libdrm-amdgpu1 amd64 2.4.102-1 [28.2 kB]
Get:160 http://127.0.0.1:12990/debian sid/main amd64 libpciaccess0 amd64 0.16-1 [53.6 kB]
Get:161 http://127.0.0.1:12990/debian sid/main amd64 libdrm-intel1 amd64 2.4.102-1 [70.4 kB]
Get:162 http://127.0.0.1:12990/debian sid/main amd64 libdrm-nouveau2 amd64 2.4.102-1 [26.5 kB]
Get:163 http://127.0.0.1:12990/debian sid/main amd64 libdrm-radeon1 amd64 2.4.102-1 [29.7 kB]
Get:164 http://127.0.0.1:12990/debian sid/main amd64 libllvm11 amd64 1:11.0.0-3 [17.9 MB]
Get:165 http://127.0.0.1:12990/debian sid/main amd64 libsensors-config all 1:3.6.0-2 [32.0 kB]
Get:166 http://127.0.0.1:12990/debian sid/main amd64 libsensors5 amd64 1:3.6.0-2 [53.1 kB]
Get:167 http://127.0.0.1:12990/debian sid/main amd64 libvulkan1 amd64 1.2.154.1-1 [102 kB]
Get:168 http://127.0.0.1:12990/debian sid/main amd64 libgl1-mesa-dri amd64 20.2.1-1 [9609 kB]
Get:169 http://127.0.0.1:12990/debian sid/main amd64 libglx-mesa0 amd64 20.2.1-1 [186 kB]
Get:170 http://127.0.0.1:12990/debian sid/main amd64 libglx0 amd64 1.3.2-1 [35.7 kB]
Get:171 http://127.0.0.1:12990/debian sid/main amd64 libgl1 amd64 1.3.2-1 [89.5 kB]
Get:172 http://127.0.0.1:12990/debian sid/main amd64 libgl2ps1.4 amd64 1.4.2+dfsg1-1 [39.4 kB]
Get:173 http://127.0.0.1:12990/debian sid/main amd64 libglu1-mesa amd64 9.0.1-1 [168 kB]
Get:174 http://127.0.0.1:12990/debian sid/main amd64 libwmf0.2-7 amd64 0.2.8.4-17 [165 kB]
Get:175 http://127.0.0.1:12990/debian sid/main amd64 libgraphicsmagick-q16-3 amd64 1.4+really1.3.35+hg16348-1 [1169 kB]
Get:176 http://127.0.0.1:12990/debian sid/main amd64 libgraphicsmagick++-q16-12 amd64 1.4+really1.3.35+hg16348-1 [140 kB]
Get:177 http://127.0.0.1:12990/debian sid/main amd64 libaec0 amd64 1.0.4-1 [20.3 kB]
Get:178 http://127.0.0.1:12990/debian sid/main amd64 libsz2 amd64 1.0.4-1 [6760 B]
Get:179 http://127.0.0.1:12990/debian sid/main amd64 libhdf5-103-1 amd64 1.10.6+repack-2 [1185 kB]
Get:180 http://127.0.0.1:12990/debian sid/main amd64 libqrupdate1 amd64 1.1.2-4 [37.8 kB]
Get:181 http://127.0.0.1:12990/debian sid/main amd64 libumfpack5 amd64 1:5.8.1+dfsg-2 [246 kB]
Get:182 http://127.0.0.1:12990/debian sid/main amd64 liboctave7 amd64 5.2.0-3+b1 [7906 kB]
Get:183 http://127.0.0.1:12990/debian sid/main amd64 libxrender1 amd64 1:0.9.10-1 [33.0 kB]
Get:184 http://127.0.0.1:12990/debian sid/main amd64 libxcursor1 amd64 1:1.2.0-2 [37.3 kB]
Get:185 http://127.0.0.1:12990/debian sid/main amd64 libxft2 amd64 2.3.2-2 [57.2 kB]
Get:186 http://127.0.0.1:12990/debian sid/main amd64 libxinerama1 amd64 2:1.1.4-2 [17.7 kB]
Get:187 http://127.0.0.1:12990/debian sid/main amd64 libfltk1.3 amd64 1.3.5-1 [562 kB]
Get:188 http://127.0.0.1:12990/debian sid/main amd64 libfltk-gl1.3 amd64 1.3.5-1 [75.7 kB]
Get:189 http://127.0.0.1:12990/debian sid/main amd64 libglpk40 amd64 4.65-2 [418 kB]
Get:190 http://127.0.0.1:12990/debian sid/main amd64 libasound2-data all 1.2.3.2-1 [38.1 kB]
Get:191 http://127.0.0.1:12990/debian sid/main amd64 libasound2 amd64 1.2.3.2-1 [355 kB]
Get:192 http://127.0.0.1:12990/debian sid/main amd64 libsamplerate0 amd64 0.1.9-2 [949 kB]
Get:193 http://127.0.0.1:12990/debian sid/main amd64 libjack-jackd2-0 amd64 1.9.16~dfsg-1 [289 kB]
Get:194 http://127.0.0.1:12990/debian sid/main amd64 libportaudio2 amd64 19.6.0-1.1 [66.7 kB]
Get:195 http://127.0.0.1:12990/debian sid/main amd64 libqhull8.0 amd64 2020.1-2 [244 kB]
Get:196 http://127.0.0.1:12990/debian sid/main amd64 libqscintilla2-qt5-l10n all 2.11.5+dfsg-3 [107 kB]
Get:197 http://127.0.0.1:12990/debian sid/main amd64 shared-mime-info amd64 2.0-1 [701 kB]
Get:198 http://127.0.0.1:12990/debian sid/main amd64 libdouble-conversion3 amd64 3.1.5-6 [40.9 kB]
Get:199 http://127.0.0.1:12990/debian sid/main amd64 libpcre2-16-0 amd64 10.34-7 [219 kB]
Get:200 http://127.0.0.1:12990/debian sid/main amd64 libqt5core5a amd64 5.14.2+dfsg-6 [1784 kB]
Get:201 http://127.0.0.1:12990/debian sid/main amd64 fontconfig amd64 2.13.1-4.2 [417 kB]
Get:202 http://127.0.0.1:12990/debian sid/main amd64 libwayland-server0 amd64 1.18.0-2~exp1.1 [34.4 kB]
Get:203 http://127.0.0.1:12990/debian sid/main amd64 libgbm1 amd64 20.2.1-1 [74.7 kB]
Get:204 http://127.0.0.1:12990/debian sid/main amd64 libwayland-client0 amd64 1.18.0-2~exp1.1 [26.9 kB]
Get:205 http://127.0.0.1:12990/debian sid/main amd64 libegl-mesa0 amd64 20.2.1-1 [142 kB]
Get:206 http://127.0.0.1:12990/debian sid/main amd64 libegl1 amd64 1.3.2-1 [34.8 kB]
Get:207 http://127.0.0.1:12990/debian sid/main amd64 libgraphite2-3 amd64 1.3.14-1 [81.2 kB]
Get:208 http://127.0.0.1:12990/debian sid/main amd64 libharfbuzz0b amd64 2.6.7-1 [1467 kB]
Get:209 http://127.0.0.1:12990/debian sid/main amd64 x11-common all 1:7.7+21 [252 kB]
Get:210 http://127.0.0.1:12990/debian sid/main amd64 libice6 amd64 2:1.0.10-1 [58.5 kB]
Get:211 http://127.0.0.1:12990/debian sid/main amd64 libevdev2 amd64 1.9.1+dfsg-1 [33.8 kB]
Get:212 http://127.0.0.1:12990/debian sid/main amd64 libmtdev1 amd64 1.1.6-1 [23.0 kB]
Get:213 http://127.0.0.1:12990/debian sid/main amd64 libgudev-1.0-0 amd64 234-1 [14.7 kB]
Get:214 http://127.0.0.1:12990/debian sid/main amd64 libwacom-common all 1.5-1 [47.8 kB]
Get:215 http://127.0.0.1:12990/debian sid/main amd64 libwacom2 amd64 1.5-1 [21.5 kB]
Get:216 http://127.0.0.1:12990/debian sid/main amd64 libinput-bin amd64 1.16.2-1 [22.9 kB]
Get:217 http://127.0.0.1:12990/debian sid/main amd64 libinput10 amd64 1.16.2-1 [117 kB]
Get:218 http://127.0.0.1:12990/debian sid/main amd64 libmd4c0 amd64 0.4.6-1 [43.2 kB]
Get:219 http://127.0.0.1:12990/debian sid/main amd64 libdbus-1-3 amd64 1.12.20-1 [217 kB]
Get:220 http://127.0.0.1:12990/debian sid/main amd64 libqt5dbus5 amd64 5.14.2+dfsg-6 [224 kB]
Get:221 http://127.0.0.1:12990/debian sid/main amd64 libqt5network5 amd64 5.14.2+dfsg-6 [651 kB]
Get:222 http://127.0.0.1:12990/debian sid/main amd64 libsm6 amd64 2:1.2.3-1 [35.1 kB]
Get:223 http://127.0.0.1:12990/debian sid/main amd64 libxcb-icccm4 amd64 0.4.1-1.1 [27.4 kB]
Get:224 http://127.0.0.1:12990/debian sid/main amd64 libxcb-shm0 amd64 1.14-2 [101 kB]
Get:225 http://127.0.0.1:12990/debian sid/main amd64 libxcb-util0 amd64 0.3.8-3+b2 [23.0 kB]
Get:226 http://127.0.0.1:12990/debian sid/main amd64 libxcb-image0 amd64 0.4.0-1+b2 [24.4 kB]
Get:227 http://127.0.0.1:12990/debian sid/main amd64 libxcb-keysyms1 amd64 0.4.0-1+b2 [16.4 kB]
Get:228 http://127.0.0.1:12990/debian sid/main amd64 libxcb-randr0 amd64 1.14-2 [112 kB]
Get:229 http://127.0.0.1:12990/debian sid/main amd64 libxcb-render0 amd64 1.14-2 [111 kB]
Get:230 http://127.0.0.1:12990/debian sid/main amd64 libxcb-render-util0 amd64 0.3.9-1+b1 [18.3 kB]
Get:231 http://127.0.0.1:12990/debian sid/main amd64 libxcb-shape0 amd64 1.14-2 [102 kB]
Get:232 http://127.0.0.1:12990/debian sid/main amd64 libxcb-xinerama0 amd64 1.14-2 [101 kB]
Get:233 http://127.0.0.1:12990/debian sid/main amd64 libxcb-xinput0 amd64 1.14-2 [125 kB]
Get:234 http://127.0.0.1:12990/debian sid/main amd64 libxcb-xkb1 amd64 1.14-2 [126 kB]
Get:235 http://127.0.0.1:12990/debian sid/main amd64 xkb-data all 2.29-2 [655 kB]
Get:236 http://127.0.0.1:12990/debian sid/main amd64 libxkbcommon0 amd64 1.0.1-1 [124 kB]
Get:237 http://127.0.0.1:12990/debian sid/main amd64 libxkbcommon-x11-0 amd64 1.0.1-1 [39.4 kB]
Get:238 http://127.0.0.1:12990/debian sid/main amd64 libqt5gui5 amd64 5.14.2+dfsg-6 [3148 kB]
Get:239 http://127.0.0.1:12990/debian sid/main amd64 libavahi-common-data amd64 0.8-3 [126 kB]
Get:240 http://127.0.0.1:12990/debian sid/main amd64 libavahi-common3 amd64 0.8-3 [58.3 kB]
Get:241 http://127.0.0.1:12990/debian sid/main amd64 libavahi-client3 amd64 0.8-3 [61.7 kB]
Get:242 http://127.0.0.1:12990/debian sid/main amd64 libcups2 amd64 2.3.3-3 [348 kB]
Get:243 http://127.0.0.1:12990/debian sid/main amd64 libqt5widgets5 amd64 5.14.2+dfsg-6 [2336 kB]
Get:244 http://127.0.0.1:12990/debian sid/main amd64 libqt5printsupport5 amd64 5.14.2+dfsg-6 [218 kB]
Get:245 http://127.0.0.1:12990/debian sid/main amd64 libqscintilla2-qt5-15 amd64 2.11.5+dfsg-3+b1 [1169 kB]
Get:246 http://127.0.0.1:12990/debian sid/main amd64 libqt5sql5 amd64 5.14.2+dfsg-6 [139 kB]
Get:247 http://127.0.0.1:12990/debian sid/main amd64 libqt5help5 amd64 5.14.2-3 [121 kB]
Get:248 http://127.0.0.1:12990/debian sid/main amd64 libqt5xml5 amd64 5.14.2+dfsg-6 [137 kB]
Get:249 http://127.0.0.1:12990/debian sid/main amd64 libogg0 amd64 1.3.2-1+b1 [21.3 kB]
Get:250 http://127.0.0.1:12990/debian sid/main amd64 libflac8 amd64 1.3.3-1 [112 kB]
Get:251 http://127.0.0.1:12990/debian sid/main amd64 libvorbis0a amd64 1.3.7-1 [93.0 kB]
Get:252 http://127.0.0.1:12990/debian sid/main amd64 libvorbisenc2 amd64 1.3.7-1 [80.6 kB]
Get:253 http://127.0.0.1:12990/debian sid/main amd64 libsndfile1 amd64 1.0.28-8 [253 kB]
Get:254 http://127.0.0.1:12990/debian sid/main amd64 libtext-unidecode-perl all 1.30-1 [103 kB]
Get:255 http://127.0.0.1:12990/debian sid/main amd64 libxml-namespacesupport-perl all 1.12-1 [14.8 kB]
Get:256 http://127.0.0.1:12990/debian sid/main amd64 libxml-sax-base-perl all 1.09-1 [20.4 kB]
Get:257 http://127.0.0.1:12990/debian sid/main amd64 libxml-sax-perl all 1.02+dfsg-1 [59.0 kB]
Get:258 http://127.0.0.1:12990/debian sid/main amd64 libxml-libxml-perl amd64 2.0134+dfsg-2 [343 kB]
Get:259 http://127.0.0.1:12990/debian sid/main amd64 texinfo amd64 6.7.0.dfsg.2-5 [1761 kB]
Get:260 http://127.0.0.1:12990/debian sid/main amd64 octave-common all 5.2.0-3 [5545 kB]
Get:261 http://127.0.0.1:12990/debian sid/main amd64 octave amd64 5.2.0-3+b1 [2326 kB]
Get:262 http://127.0.0.1:12990/debian sid/main amd64 libncurses6 amd64 6.2+20200918-1 [102 kB]
Get:263 http://127.0.0.1:12990/debian sid/main amd64 libncursesw6 amd64 6.2+20200918-1 [132 kB]
Get:264 http://127.0.0.1:12990/debian sid/main amd64 libncurses-dev amd64 6.2+20200918-1 [344 kB]
Get:265 http://127.0.0.1:12990/debian sid/main amd64 libreadline-dev amd64 8.0-4 [141 kB]
Get:266 http://127.0.0.1:12990/debian sid/main amd64 libhdf5-fortran-102 amd64 1.10.6+repack-2 [104 kB]
Get:267 http://127.0.0.1:12990/debian sid/main amd64 libhdf5-hl-100 amd64 1.10.6+repack-2 [81.6 kB]
Get:268 http://127.0.0.1:12990/debian sid/main amd64 libhdf5-hl-fortran-100 amd64 1.10.6+repack-2 [55.6 kB]
Get:269 http://127.0.0.1:12990/debian sid/main amd64 libhdf5-cpp-103-1 amd64 1.10.6+repack-2 [146 kB]
Get:270 http://127.0.0.1:12990/debian sid/main amd64 libhdf5-hl-cpp-100 amd64 1.10.6+repack-2 [37.2 kB]
Get:271 http://127.0.0.1:12990/debian sid/main amd64 zlib1g-dev amd64 1:1.2.11.dfsg-2 [190 kB]
Get:272 http://127.0.0.1:12990/debian sid/main amd64 libjpeg62-turbo-dev amd64 1:2.0.5-1.1 [276 kB]
Get:273 http://127.0.0.1:12990/debian sid/main amd64 libjpeg-dev all 1:2.0.5-1.1 [66.0 kB]
Get:274 http://127.0.0.1:12990/debian sid/main amd64 libaec-dev amd64 1.0.4-1 [18.7 kB]
Get:275 http://127.0.0.1:12990/debian sid/main amd64 hdf5-helpers amd64 1.10.6+repack-2 [39.9 kB]
Get:276 http://127.0.0.1:12990/debian sid/main amd64 libhdf5-dev amd64 1.10.6+repack-2 [2449 kB]
Get:277 http://127.0.0.1:12990/debian sid/main amd64 xorg-sgml-doctools all 1:1.11-1 [21.9 kB]
Get:278 http://127.0.0.1:12990/debian sid/main amd64 x11proto-dev all 2020.1-1 [594 kB]
Get:279 http://127.0.0.1:12990/debian sid/main amd64 x11proto-core-dev all 2020.1-1 [3404 B]
Get:280 http://127.0.0.1:12990/debian sid/main amd64 libxau-dev amd64 1:1.0.8-1+b2 [23.1 kB]
Get:281 http://127.0.0.1:12990/debian sid/main amd64 libxdmcp-dev amd64 1:1.1.2-3 [42.2 kB]
Get:282 http://127.0.0.1:12990/debian sid/main amd64 xtrans-dev all 1.4.0-1 [98.7 kB]
Get:283 http://127.0.0.1:12990/debian sid/main amd64 libpthread-stubs0-dev amd64 0.4-1 [5344 B]
Get:284 http://127.0.0.1:12990/debian sid/main amd64 libxcb1-dev amd64 1.14-2 [176 kB]
Get:285 http://127.0.0.1:12990/debian sid/main amd64 libx11-dev amd64 2:1.6.12-1 [842 kB]
Get:286 http://127.0.0.1:12990/debian sid/main amd64 libglx-dev amd64 1.3.2-1 [16.3 kB]
Get:287 http://127.0.0.1:12990/debian sid/main amd64 libgl-dev amd64 1.3.2-1 [100 kB]
Get:288 http://127.0.0.1:12990/debian sid/main amd64 libegl-dev amd64 1.3.2-1 [19.6 kB]
Get:289 http://127.0.0.1:12990/debian sid/main amd64 libgles1 amd64 1.3.2-1 [12.6 kB]
Get:290 http://127.0.0.1:12990/debian sid/main amd64 libgles2 amd64 1.3.2-1 [17.7 kB]
Get:291 http://127.0.0.1:12990/debian sid/main amd64 libgles-dev amd64 1.3.2-1 [50.3 kB]
Get:292 http://127.0.0.1:12990/debian sid/main amd64 libopengl0 amd64 1.3.2-1 [31.5 kB]
Get:293 http://127.0.0.1:12990/debian sid/main amd64 libopengl-dev amd64 1.3.2-1 [5876 B]
Get:294 http://127.0.0.1:12990/debian sid/main amd64 libglvnd-dev amd64 1.3.2-1 [13.9 kB]
Get:295 http://127.0.0.1:12990/debian sid/main amd64 libgl1-mesa-dev amd64 20.2.1-1 [50.4 kB]
Get:296 http://127.0.0.1:12990/debian sid/main amd64 libblas-dev amd64 3.9.0-3 [161 kB]
Get:297 http://127.0.0.1:12990/debian sid/main amd64 liblapack-dev amd64 3.9.0-3 [4247 kB]
Get:298 http://127.0.0.1:12990/debian sid/main amd64 libfftw3-long3 amd64 3.3.8-2 [319 kB]
Get:299 http://127.0.0.1:12990/debian sid/main amd64 libfftw3-quad3 amd64 3.3.8-2 [558 kB]
Get:300 http://127.0.0.1:12990/debian sid/main amd64 libfftw3-bin amd64 3.3.8-2 [50.7 kB]
Get:301 http://127.0.0.1:12990/debian sid/main amd64 libfftw3-dev amd64 3.3.8-2 [2106 kB]
Get:302 http://127.0.0.1:12990/debian sid/main amd64 libgfortran-10-dev amd64 10.2.0-15 [770 kB]
Get:303 http://127.0.0.1:12990/debian sid/main amd64 gfortran-10 amd64 10.2.0-15 [8441 kB]
Get:304 http://127.0.0.1:12990/debian sid/main amd64 gfortran amd64 4:10.2.0-1 [1432 B]
Get:305 http://127.0.0.1:12990/debian sid/main amd64 liboctave-dev amd64 5.2.0-3+b1 [833 kB]
Get:306 http://127.0.0.1:12990/debian sid/main amd64 libapt-pkg-perl amd64 0.1.36+b3 [71.0 kB]
Get:307 http://127.0.0.1:12990/debian sid/main amd64 libarray-intspan-perl all 2.004-1 [25.5 kB]
Get:308 http://127.0.0.1:12990/debian sid/main amd64 libyaml-0-2 amd64 0.2.2-1 [49.6 kB]
Get:309 http://127.0.0.1:12990/debian sid/main amd64 libyaml-libyaml-perl amd64 0.82+repack-1 [35.6 kB]
Get:310 http://127.0.0.1:12990/debian sid/main amd64 libconfig-model-backend-yaml-perl all 2.133-2 [10.8 kB]
Get:311 http://127.0.0.1:12990/debian sid/main amd64 libexporter-lite-perl all 0.08-1 [11.1 kB]
Get:312 http://127.0.0.1:12990/debian sid/main amd64 libalgorithm-c3-perl all 0.10-1 [12.0 kB]
Get:313 http://127.0.0.1:12990/debian sid/main amd64 libclass-c3-perl all 0.34-1 [22.4 kB]
Get:314 http://127.0.0.1:12990/debian sid/main amd64 libmro-compat-perl all 0.13-1 [12.2 kB]
Get:315 http://127.0.0.1:12990/debian sid/main amd64 libdata-section-perl all 0.200007-1 [13.4 kB]
Get:316 http://127.0.0.1:12990/debian sid/main amd64 libtext-template-perl all 1.59-1 [54.3 kB]
Get:317 http://127.0.0.1:12990/debian sid/main amd64 libsoftware-license-perl all 0.103014-2 [113 kB]
Get:318 http://127.0.0.1:12990/debian sid/main amd64 libyaml-tiny-perl all 1.73-1 [32.3 kB]
Get:319 http://127.0.0.1:12990/debian sid/main amd64 libsoftware-licensemoreutils-perl all 1.004-1 [20.2 kB]
Get:320 http://127.0.0.1:12990/debian sid/main amd64 libsort-versions-perl all 1.62-1 [11.0 kB]
Get:321 http://127.0.0.1:12990/debian sid/main amd64 libtext-reform-perl all 1.20-3 [37.3 kB]
Get:322 http://127.0.0.1:12990/debian sid/main amd64 libtext-autoformat-perl all 1.750000-1 [35.1 kB]
Get:323 http://127.0.0.1:12990/debian sid/main amd64 libtext-levenshtein-damerau-perl all 0.41-1 [13.2 kB]
Get:324 http://127.0.0.1:12990/debian sid/main amd64 liburi-perl all 5.05-1 [90.3 kB]
Get:325 http://127.0.0.1:12990/debian sid/main amd64 libencode-locale-perl all 1.05-1 [13.7 kB]
Get:326 http://127.0.0.1:12990/debian sid/main amd64 libtimedate-perl all 2.3300-1 [39.2 kB]
Get:327 http://127.0.0.1:12990/debian sid/main amd64 libhttp-date-perl all 6.05-1 [10.4 kB]
Get:328 http://127.0.0.1:12990/debian sid/main amd64 libfile-listing-perl all 6.11-1 [11.2 kB]
Get:329 http://127.0.0.1:12990/debian sid/main amd64 libhtml-tagset-perl all 3.20-4 [13.0 kB]
Get:330 http://127.0.0.1:12990/debian sid/main amd64 libhtml-parser-perl amd64 3.75-1 [105 kB]
Get:331 http://127.0.0.1:12990/debian sid/main amd64 libhtml-tree-perl all 5.07-2 [213 kB]
Get:332 http://127.0.0.1:12990/debian sid/main amd64 libio-html-perl all 1.001-1 [17.6 kB]
Get:333 http://127.0.0.1:12990/debian sid/main amd64 liblwp-mediatypes-perl all 6.04-1 [19.9 kB]
Get:334 http://127.0.0.1:12990/debian sid/main amd64 libhttp-message-perl all 6.26-1 [79.4 kB]
Get:335 http://127.0.0.1:12990/debian sid/main amd64 libhttp-cookies-perl all 6.08-1 [19.3 kB]
Get:336 http://127.0.0.1:12990/debian sid/main amd64 libhttp-negotiate-perl all 6.01-1 [12.8 kB]
Get:337 http://127.0.0.1:12990/debian sid/main amd64 perl-openssl-defaults amd64 5 [7360 B]
Get:338 http://127.0.0.1:12990/debian sid/main amd64 libnet-ssleay-perl amd64 1.88-3 [320 kB]
Get:339 http://127.0.0.1:12990/debian sid/main amd64 libio-socket-ssl-perl all 2.068-1 [215 kB]
Get:340 http://127.0.0.1:12990/debian sid/main amd64 libnet-http-perl all 6.19-1 [24.8 kB]
Get:341 http://127.0.0.1:12990/debian sid/main amd64 liblwp-protocol-https-perl all 6.09-1 [12.0 kB]
Get:342 http://127.0.0.1:12990/debian sid/main amd64 libwww-robotrules-perl all 6.02-1 [12.9 kB]
Get:343 http://127.0.0.1:12990/debian sid/main amd64 libwww-perl all 6.49-1 [192 kB]
Get:344 http://127.0.0.1:12990/debian sid/main amd64 liblist-someutils-perl all 0.58-1 [36.5 kB]
Get:345 http://127.0.0.1:12990/debian sid/main amd64 liblog-any-perl all 1.708-1 [73.4 kB]
Get:346 http://127.0.0.1:12990/debian sid/main amd64 liblog-any-adapter-screen-perl all 0.140-1 [13.1 kB]
Get:347 http://127.0.0.1:12990/debian sid/main amd64 libclass-method-modifiers-perl all 2.13-1 [19.2 kB]
Get:348 http://127.0.0.1:12990/debian sid/main amd64 libimport-into-perl all 1.002005-1 [11.6 kB]
Get:349 http://127.0.0.1:12990/debian sid/main amd64 librole-tiny-perl all 2.001004-1 [20.8 kB]
Get:350 http://127.0.0.1:12990/debian sid/main amd64 libstrictures-perl all 2.000006-1 [18.6 kB]
Get:351 http://127.0.0.1:12990/debian sid/main amd64 libsub-quote-perl all 2.006006-1 [21.0 kB]
Get:352 http://127.0.0.1:12990/debian sid/main amd64 libmoo-perl all 2.004000-1 [59.4 kB]
Get:353 http://127.0.0.1:12990/debian sid/main amd64 libsub-exporter-progressive-perl all 0.001013-1 [7588 B]
Get:354 http://127.0.0.1:12990/debian sid/main amd64 libvariable-magic-perl amd64 0.62-1+b2 [46.0 kB]
Get:355 http://127.0.0.1:12990/debian sid/main amd64 libb-hooks-endofscope-perl all 0.24-1 [18.6 kB]
Get:356 http://127.0.0.1:12990/debian sid/main amd64 libsub-identify-perl amd64 0.14-1+b2 [12.0 kB]
Get:357 http://127.0.0.1:12990/debian sid/main amd64 libsub-name-perl amd64 0.26-1 [13.5 kB]
Get:358 http://127.0.0.1:12990/debian sid/main amd64 libnamespace-clean-perl all 0.27-1 [17.3 kB]
Get:359 http://127.0.0.1:12990/debian sid/main amd64 libnamespace-autoclean-perl all 0.29-1 [15.0 kB]
Get:360 http://127.0.0.1:12990/debian sid/main amd64 libhash-fieldhash-perl amd64 0.15-1+b2 [18.0 kB]
Get:361 http://127.0.0.1:12990/debian sid/main amd64 libobject-id-perl all 0.1.2-2 [16.5 kB]
Get:362 http://127.0.0.1:12990/debian sid/main amd64 libtype-tiny-perl all 1.010006-1 [339 kB]
Get:363 http://127.0.0.1:12990/debian sid/main amd64 libmoox-struct-perl all 0.020-1 [25.4 kB]
Get:364 http://127.0.0.1:12990/debian sid/main amd64 libnumber-compare-perl all 0.03-1 [7642 B]
Get:365 http://127.0.0.1:12990/debian sid/main amd64 libtext-glob-perl all 0.11-1 [8888 B]
Get:366 http://127.0.0.1:12990/debian sid/main amd64 libpath-iterator-rule-perl all 1.014-1 [54.0 kB]
Get:367 http://127.0.0.1:12990/debian sid/main amd64 libpod-constants-perl all 0.19-2 [17.3 kB]
Get:368 http://127.0.0.1:12990/debian sid/main amd64 libre2-8 amd64 20201001+dfsg-1 [171 kB]
Get:369 http://127.0.0.1:12990/debian sid/main amd64 libre-engine-re2-perl amd64 0.13-5+b3 [17.3 kB]
Get:370 http://127.0.0.1:12990/debian sid/main amd64 libregexp-pattern-license-perl all 3.4.0-1 [56.4 kB]
Get:371 http://127.0.0.1:12990/debian sid/main amd64 libregexp-pattern-perl all 0.2.14-1 [18.8 kB]
Get:372 http://127.0.0.1:12990/debian sid/main amd64 libsort-key-perl amd64 1.33-2+b2 [37.1 kB]
Get:373 http://127.0.0.1:12990/debian sid/main amd64 libnumber-range-perl all 0.12-1 [9274 B]
Get:374 http://127.0.0.1:12990/debian sid/main amd64 libstring-copyright-perl all 0.003006-1 [11.6 kB]
Get:375 http://127.0.0.1:12990/debian sid/main amd64 libstring-escape-perl all 2010.002-2 [19.1 kB]
Get:376 http://127.0.0.1:12990/debian sid/main amd64 licensecheck all 3.0.47-1 [49.7 kB]
Get:377 http://127.0.0.1:12990/debian sid/main amd64 diffstat amd64 1.63-1 [35.6 kB]
Get:378 http://127.0.0.1:12990/debian sid/main amd64 libassuan0 amd64 2.5.3-7.1 [50.5 kB]
Get:379 http://127.0.0.1:12990/debian sid/main amd64 gpgconf amd64 2.2.20-1 [532 kB]
Get:380 http://127.0.0.1:12990/debian sid/main amd64 libsqlite3-0 amd64 3.33.0-1 [790 kB]
Get:381 http://127.0.0.1:12990/debian sid/main amd64 gpg amd64 2.2.20-1 [894 kB]
Get:382 http://127.0.0.1:12990/debian sid/main amd64 libclass-xsaccessor-perl amd64 1.19-3+b5 [38.4 kB]
Get:383 http://127.0.0.1:12990/debian sid/main amd64 libclone-perl amd64 0.45-1 [15.1 kB]
Get:384 http://127.0.0.1:12990/debian sid/main amd64 libconfig-tiny-perl all 2.24-1 [16.2 kB]
Get:385 http://127.0.0.1:12990/debian sid/main amd64 libcpanel-json-xs-perl amd64 4.24-1 [128 kB]
Get:386 http://127.0.0.1:12990/debian sid/main amd64 libaliased-perl all 0.34-1 [13.8 kB]
Get:387 http://127.0.0.1:12990/debian sid/main amd64 libclass-data-inheritable-perl all 0.08-3 [8588 B]
Get:388 http://127.0.0.1:12990/debian sid/main amd64 libdevel-stacktrace-perl all 2.0400-1 [28.6 kB]
Get:389 http://127.0.0.1:12990/debian sid/main amd64 libexception-class-perl all 1.44-1 [32.3 kB]
Get:390 http://127.0.0.1:12990/debian sid/main amd64 libiterator-perl all 0.03+ds1-1 [18.9 kB]
Get:391 http://127.0.0.1:12990/debian sid/main amd64 libiterator-util-perl all 0.02+ds1-1 [14.2 kB]
Get:392 http://127.0.0.1:12990/debian sid/main amd64 libdata-dpath-perl all 0.58-1 [43.5 kB]
Get:393 http://127.0.0.1:12990/debian sid/main amd64 libnet-domain-tld-perl all 1.75-1 [33.3 kB]
Get:394 http://127.0.0.1:12990/debian sid/main amd64 libdata-validate-domain-perl all 0.10-1 [12.3 kB]
Get:395 http://127.0.0.1:12990/debian sid/main amd64 libdevel-size-perl amd64 0.83-1+b1 [26.0 kB]
Get:396 http://127.0.0.1:12990/debian sid/main amd64 libemail-address-xs-perl amd64 1.04-1+b2 [28.1 kB]
Get:397 http://127.0.0.1:12990/debian sid/main amd64 libipc-system-simple-perl all 1.30-1 [28.2 kB]
Get:398 http://127.0.0.1:12990/debian sid/main amd64 libfile-basedir-perl all 0.08-1 [17.7 kB]
Get:399 http://127.0.0.1:12990/debian sid/main amd64 libfile-find-rule-perl all 0.34-1 [30.6 kB]
Get:400 http://127.0.0.1:12990/debian sid/main amd64 libio-string-perl all 1.08-3 [12.3 kB]
Get:401 http://127.0.0.1:12990/debian sid/main amd64 libfont-ttf-perl all 1.06-1 [317 kB]
Get:402 http://127.0.0.1:12990/debian sid/main amd64 libhtml-html5-entities-perl all 0.004-1 [21.8 kB]
Get:403 http://127.0.0.1:12990/debian sid/main amd64 libipc-run3-perl all 0.048-2 [34.2 kB]
Get:404 http://127.0.0.1:12990/debian sid/main amd64 libjson-maybexs-perl all 1.004002-1 [13.1 kB]
Get:405 http://127.0.0.1:12990/debian sid/main amd64 liblist-compare-perl all 0.55-1 [66.9 kB]
Get:406 http://127.0.0.1:12990/debian sid/main amd64 liblist-utilsby-perl all 0.11-1 [15.4 kB]
Get:407 http://127.0.0.1:12990/debian sid/main amd64 libmoox-aliases-perl all 0.001006-1 [10.2 kB]
Get:408 http://127.0.0.1:12990/debian sid/main amd64 libperlio-gzip-perl amd64 0.19-1+b6 [17.4 kB]
Get:409 http://127.0.0.1:12990/debian sid/main amd64 libproc-processtable-perl amd64 0.59-2 [45.7 kB]
Get:410 http://127.0.0.1:12990/debian sid/main amd64 libsereal-decoder-perl amd64 4.018+ds-1 [98.9 kB]
Get:411 http://127.0.0.1:12990/debian sid/main amd64 libsereal-encoder-perl amd64 4.018+ds-1 [103 kB]
Get:412 http://127.0.0.1:12990/debian sid/main amd64 libtext-levenshteinxs-perl amd64 0.03-4+b7 [8696 B]
Get:413 http://127.0.0.1:12990/debian sid/main amd64 libmarkdown2 amd64 2.2.6-1 [36.8 kB]
Get:414 http://127.0.0.1:12990/debian sid/main amd64 libtext-markdown-discount-perl amd64 0.12-1 [12.7 kB]
Get:415 http://127.0.0.1:12990/debian sid/main amd64 libdata-messagepack-perl amd64 1.00-4 [38.3 kB]
Get:416 http://127.0.0.1:12990/debian sid/main amd64 libtext-xslate-perl amd64 3.5.8-1 [198 kB]
Get:417 http://127.0.0.1:12990/debian sid/main amd64 libtime-duration-perl all 1.21-1 [13.7 kB]
Get:418 http://127.0.0.1:12990/debian sid/main amd64 libtime-moment-perl amd64 0.44-1+b2 [75.1 kB]
Get:419 http://127.0.0.1:12990/debian sid/main amd64 libunicode-utf8-perl amd64 0.62-1+b1 [20.2 kB]
Get:420 http://127.0.0.1:12990/debian sid/main amd64 lzip amd64 1.21-8 [84.3 kB]
Get:421 http://127.0.0.1:12990/debian sid/main amd64 liblzo2-2 amd64 2.10-2 [56.9 kB]
Get:422 http://127.0.0.1:12990/debian sid/main amd64 lzop amd64 1.04-1 [83.4 kB]
Get:423 http://127.0.0.1:12990/debian sid/main amd64 patchutils amd64 0.4.2-1 [77.5 kB]
Get:424 http://127.0.0.1:12990/debian sid/main amd64 t1utils amd64 1.41-4 [62.1 kB]
Get:425 http://127.0.0.1:12990/debian sid/main amd64 unzip amd64 6.0-25 [172 kB]
Get:426 http://127.0.0.1:12990/debian sid/main amd64 lintian all 2.99.0 [1266 kB]
Get:427 http://127.0.0.1:12990/debian sid/main amd64 libconfig-model-dpkg-perl all 2.139 [208 kB]
Get:428 http://127.0.0.1:12990/debian sid/main amd64 liberror-perl all 0.17029-1 [31.0 kB]
Get:429 http://127.0.0.1:12990/debian sid/main amd64 libparse-debcontrol-perl all 2.005-4 [25.7 kB]
Get:430 http://127.0.0.1:12990/debian sid/main amd64 libconvert-binhex-perl all 1.125-1 [30.5 kB]
Get:431 http://127.0.0.1:12990/debian sid/main amd64 libnet-smtp-ssl-perl all 1.04-1 [6184 B]
Get:432 http://127.0.0.1:12990/debian sid/main amd64 libmailtools-perl all 2.21-1 [95.5 kB]
Get:433 http://127.0.0.1:12990/debian sid/main amd64 libmime-tools-perl all 5.509-1 [212 kB]
Get:434 http://127.0.0.1:12990/debian sid/main amd64 gnuplot-data all 5.4.0+dfsg1-1 [87.3 kB]
Get:435 http://127.0.0.1:12990/debian sid/main amd64 libpixman-1-0 amd64 0.36.0-1 [537 kB]
Get:436 http://127.0.0.1:12990/debian sid/main amd64 libcairo2 amd64 1.16.0-4 [689 kB]
Get:437 http://127.0.0.1:12990/debian sid/main amd64 libxpm4 amd64 1:3.5.12-1 [49.1 kB]
Get:438 http://127.0.0.1:12990/debian sid/main amd64 libgd3 amd64 2.3.0-2 [137 kB]
Get:439 http://127.0.0.1:12990/debian sid/main amd64 liblua5.4-0 amd64 5.4.0-2 [130 kB]
Get:440 http://127.0.0.1:12990/debian sid/main amd64 libfribidi0 amd64 1.0.8-2 [64.8 kB]
Get:441 http://127.0.0.1:12990/debian sid/main amd64 libthai-data all 0.1.28-3 [170 kB]
Get:442 http://127.0.0.1:12990/debian sid/main amd64 libdatrie1 amd64 0.2.12-3 [39.5 kB]
Get:443 http://127.0.0.1:12990/debian sid/main amd64 libthai0 amd64 0.1.28-3 [54.2 kB]
Get:444 http://127.0.0.1:12990/debian sid/main amd64 libpango-1.0-0 amd64 1.46.2-1 [191 kB]
Get:445 http://127.0.0.1:12990/debian sid/main amd64 libpangoft2-1.0-0 amd64 1.46.2-1 [61.2 kB]
Get:446 http://127.0.0.1:12990/debian sid/main amd64 libpangocairo-1.0-0 amd64 1.46.2-1 [50.0 kB]
Get:447 http://127.0.0.1:12990/debian sid/main amd64 gnuplot-nox amd64 5.4.0+dfsg1-1 [853 kB]
Get:448 http://127.0.0.1:12990/debian sid/main amd64 dh-octave-autopkgtest all 1.0.1 [9212 B]
Get:449 http://127.0.0.1:12990/debian sid/main amd64 dh-octave all 1.0.1 [21.7 kB]
Get:450 http://127.0.0.1:12990/debian sid/main amd64 libgs9-common all 9.53.3~dfsg-5 [733 kB]
Get:451 http://127.0.0.1:12990/debian sid/main amd64 libidn11 amd64 1.33-2.4 [116 kB]
Get:452 http://127.0.0.1:12990/debian sid/main amd64 libijs-0.35 amd64 0.35-15 [16.4 kB]
Get:453 http://127.0.0.1:12990/debian sid/main amd64 libjbig2dec0 amd64 0.19-1 [66.9 kB]
Get:454 http://127.0.0.1:12990/debian sid/main amd64 libpaper1 amd64 1.1.28+b1 [21.6 kB]
Get:455 http://127.0.0.1:12990/debian sid/main amd64 libgs9 amd64 9.53.3~dfsg-5 [2228 kB]
Get:456 http://127.0.0.1:12990/debian sid/main amd64 ghostscript amd64 9.53.3~dfsg-5 [97.2 kB]
Get:457 http://127.0.0.1:12990/debian sid/main amd64 hicolor-icon-theme all 0.17-2 [11.4 kB]
Get:458 http://127.0.0.1:12990/debian sid/main amd64 imagemagick-6.q16 amd64 8:6.9.11.24+dfsg-1+b1 [380 kB]
Get:459 http://127.0.0.1:12990/debian sid/main amd64 imagemagick amd64 8:6.9.11.24+dfsg-1+b1 [163 kB]
Get:460 http://127.0.0.1:12990/debian sid/main amd64 libgmpxx4ldbl amd64 2:6.2.0+dfsg-6 [23.1 kB]
Get:461 http://127.0.0.1:12990/debian sid/main amd64 libgmp-dev amd64 2:6.2.0+dfsg-6 [643 kB]
Get:462 http://127.0.0.1:12990/debian sid/main amd64 libmpfr-dev amd64 4.1.0-3 [252 kB]
debconf: delaying package configuration, since apt-utils is not installed
Fetched 164 MB in 2s (89.3 MB/s)
Selecting previously unselected package bsdextrautils.
(Reading database ... 14056 files and directories currently installed.)
Preparing to unpack .../000-bsdextrautils_2.36-3+b1_amd64.deb ...
Unpacking bsdextrautils (2.36-3+b1) ...
Selecting previously unselected package libuchardet0:amd64.
Preparing to unpack .../001-libuchardet0_0.0.7-1_amd64.deb ...
Unpacking libuchardet0:amd64 (0.0.7-1) ...
Selecting previously unselected package groff-base.
Preparing to unpack .../002-groff-base_1.22.4-5_amd64.deb ...
Unpacking groff-base (1.22.4-5) ...
Selecting previously unselected package libpipeline1:amd64.
Preparing to unpack .../003-libpipeline1_1.5.3-1_amd64.deb ...
Unpacking libpipeline1:amd64 (1.5.3-1) ...
Selecting previously unselected package man-db.
Preparing to unpack .../004-man-db_2.9.3-2_amd64.deb ...
Unpacking man-db (2.9.3-2) ...
Selecting previously unselected package libfftw3-double3:amd64.
Preparing to unpack .../005-libfftw3-double3_3.3.8-2_amd64.deb ...
Unpacking libfftw3-double3:amd64 (3.3.8-2) ...
Selecting previously unselected package libexpat1:amd64.
Preparing to unpack .../006-libexpat1_2.2.10-1_amd64.deb ...
Unpacking libexpat1:amd64 (2.2.10-1) ...
Selecting previously unselected package libbrotli1:amd64.
Preparing to unpack .../007-libbrotli1_1.0.9-2+b1_amd64.deb ...
Unpacking libbrotli1:amd64 (1.0.9-2+b1) ...
Selecting previously unselected package libpng16-16:amd64.
Preparing to unpack .../008-libpng16-16_1.6.37-3_amd64.deb ...
Unpacking libpng16-16:amd64 (1.6.37-3) ...
Selecting previously unselected package libfreetype6:amd64.
Preparing to unpack .../009-libfreetype6_2.10.2+dfsg-4_amd64.deb ...
Unpacking libfreetype6:amd64 (2.10.2+dfsg-4) ...
Selecting previously unselected package sensible-utils.
Preparing to unpack .../010-sensible-utils_0.0.12+nmu1_all.deb ...
Unpacking sensible-utils (0.0.12+nmu1) ...
Selecting previously unselected package ucf.
Preparing to unpack .../011-ucf_3.0043_all.deb ...
Moving old data out of the way
Unpacking ucf (3.0043) ...
Selecting previously unselected package fonts-dejavu-core.
Preparing to unpack .../012-fonts-dejavu-core_2.37-2_all.deb ...
Unpacking fonts-dejavu-core (2.37-2) ...
Selecting previously unselected package fonts-freefont-otf.
Preparing to unpack .../013-fonts-freefont-otf_20120503-10_all.deb ...
Unpacking fonts-freefont-otf (20120503-10) ...
Selecting previously unselected package fonts-urw-base35.
Preparing to unpack .../014-fonts-urw-base35_20200910-1_all.deb ...
Unpacking fonts-urw-base35 (20200910-1) ...
Selecting previously unselected package fontconfig-config.
Preparing to unpack .../015-fontconfig-config_2.13.1-4.2_all.deb ...
Unpacking fontconfig-config (2.13.1-4.2) ...
Selecting previously unselected package libfontconfig1:amd64.
Preparing to unpack .../016-libfontconfig1_2.13.1-4.2_amd64.deb ...
Unpacking libfontconfig1:amd64 (2.13.1-4.2) ...
Selecting previously unselected package libaom0:amd64.
Preparing to unpack .../017-libaom0_1.0.0.errata1-3_amd64.deb ...
Unpacking libaom0:amd64 (1.0.0.errata1-3) ...
Selecting previously unselected package libdav1d4:amd64.
Preparing to unpack .../018-libdav1d4_0.7.1-3_amd64.deb ...
Unpacking libdav1d4:amd64 (0.7.1-3) ...
Selecting previously unselected package libde265-0:amd64.
Preparing to unpack .../019-libde265-0_1.0.7-1_amd64.deb ...
Unpacking libde265-0:amd64 (1.0.7-1) ...
Selecting previously unselected package libnuma1:amd64.
Preparing to unpack .../020-libnuma1_2.0.12-1+b1_amd64.deb ...
Unpacking libnuma1:amd64 (2.0.12-1+b1) ...
Selecting previously unselected package libx265-192:amd64.
Preparing to unpack .../021-libx265-192_3.4-2_amd64.deb ...
Unpacking libx265-192:amd64 (3.4-2) ...
Selecting previously unselected package libheif1:amd64.
Preparing to unpack .../022-libheif1_1.9.1-1_amd64.deb ...
Unpacking libheif1:amd64 (1.9.1-1) ...
Selecting previously unselected package libjbig0:amd64.
Preparing to unpack .../023-libjbig0_2.1-3.1+b2_amd64.deb ...
Unpacking libjbig0:amd64 (2.1-3.1+b2) ...
Selecting previously unselected package libjpeg62-turbo:amd64.
Preparing to unpack .../024-libjpeg62-turbo_1%3a2.0.5-1.1_amd64.deb ...
Unpacking libjpeg62-turbo:amd64 (1:2.0.5-1.1) ...
Selecting previously unselected package liblcms2-2:amd64.
Preparing to unpack .../025-liblcms2-2_2.9-4+b1_amd64.deb ...
Unpacking liblcms2-2:amd64 (2.9-4+b1) ...
Selecting previously unselected package libglib2.0-0:amd64.
Preparing to unpack .../026-libglib2.0-0_2.66.1-2_amd64.deb ...
Unpacking libglib2.0-0:amd64 (2.66.1-2) ...
Selecting previously unselected package liblqr-1-0:amd64.
Preparing to unpack .../027-liblqr-1-0_0.4.2-2.1_amd64.deb ...
Unpacking liblqr-1-0:amd64 (0.4.2-2.1) ...
Selecting previously unselected package libltdl7:amd64.
Preparing to unpack .../028-libltdl7_2.4.6-14_amd64.deb ...
Unpacking libltdl7:amd64 (2.4.6-14) ...
Selecting previously unselected package libopenjp2-7:amd64.
Preparing to unpack .../029-libopenjp2-7_2.3.1-1_amd64.deb ...
Unpacking libopenjp2-7:amd64 (2.3.1-1) ...
Selecting previously unselected package libwebp6:amd64.
Preparing to unpack .../030-libwebp6_0.6.1-2+b1_amd64.deb ...
Unpacking libwebp6:amd64 (0.6.1-2+b1) ...
Selecting previously unselected package libtiff5:amd64.
Preparing to unpack .../031-libtiff5_4.1.0+git191117-2_amd64.deb ...
Unpacking libtiff5:amd64 (4.1.0+git191117-2) ...
Selecting previously unselected package libwebpdemux2:amd64.
Preparing to unpack .../032-libwebpdemux2_0.6.1-2+b1_amd64.deb ...
Unpacking libwebpdemux2:amd64 (0.6.1-2+b1) ...
Selecting previously unselected package libwebpmux3:amd64.
Preparing to unpack .../033-libwebpmux3_0.6.1-2+b1_amd64.deb ...
Unpacking libwebpmux3:amd64 (0.6.1-2+b1) ...
Selecting previously unselected package libxau6:amd64.
Preparing to unpack .../034-libxau6_1%3a1.0.8-1+b2_amd64.deb ...
Unpacking libxau6:amd64 (1:1.0.8-1+b2) ...
Selecting previously unselected package libxdmcp6:amd64.
Preparing to unpack .../035-libxdmcp6_1%3a1.1.2-3_amd64.deb ...
Unpacking libxdmcp6:amd64 (1:1.1.2-3) ...
Selecting previously unselected package libxcb1:amd64.
Preparing to unpack .../036-libxcb1_1.14-2_amd64.deb ...
Unpacking libxcb1:amd64 (1.14-2) ...
Selecting previously unselected package libx11-data.
Preparing to unpack .../037-libx11-data_2%3a1.6.12-1_all.deb ...
Unpacking libx11-data (2:1.6.12-1) ...
Selecting previously unselected package libx11-6:amd64.
Preparing to unpack .../038-libx11-6_2%3a1.6.12-1_amd64.deb ...
Unpacking libx11-6:amd64 (2:1.6.12-1) ...
Selecting previously unselected package libxext6:amd64.
Preparing to unpack .../039-libxext6_2%3a1.3.3-1+b2_amd64.deb ...
Unpacking libxext6:amd64 (2:1.3.3-1+b2) ...
Selecting previously unselected package libicu67:amd64.
Preparing to unpack .../040-libicu67_67.1-4_amd64.deb ...
Unpacking libicu67:amd64 (67.1-4) ...
Selecting previously unselected package libxml2:amd64.
Preparing to unpack .../041-libxml2_2.9.10+dfsg-6.1_amd64.deb ...
Unpacking libxml2:amd64 (2.9.10+dfsg-6.1) ...
Selecting previously unselected package imagemagick-6-common.
Preparing to unpack .../042-imagemagick-6-common_8%3a6.9.11.24+dfsg-1_all.deb ...
Unpacking imagemagick-6-common (8:6.9.11.24+dfsg-1) ...
Selecting previously unselected package libmagickcore-6.q16-6:amd64.
Preparing to unpack .../043-libmagickcore-6.q16-6_8%3a6.9.11.24+dfsg-1+b1_amd64.deb ...
Unpacking libmagickcore-6.q16-6:amd64 (8:6.9.11.24+dfsg-1+b1) ...
Selecting previously unselected package libmagickwand-6.q16-6:amd64.
Preparing to unpack .../044-libmagickwand-6.q16-6_8%3a6.9.11.24+dfsg-1+b1_amd64.deb ...
Unpacking libmagickwand-6.q16-6:amd64 (8:6.9.11.24+dfsg-1+b1) ...
Selecting previously unselected package poppler-data.
Preparing to unpack .../045-poppler-data_0.4.9-2_all.deb ...
Unpacking poppler-data (0.4.9-2) ...
Selecting previously unselected package tex-common.
Preparing to unpack .../046-tex-common_6.15_all.deb ...
Unpacking tex-common (6.15) ...
Selecting previously unselected package readline-common.
Preparing to unpack .../047-readline-common_8.0-4_all.deb ...
Unpacking readline-common (8.0-4) ...
Selecting previously unselected package libreadline8:amd64.
Preparing to unpack .../048-libreadline8_8.0-4_amd64.deb ...
Unpacking libreadline8:amd64 (8.0-4) ...
Selecting previously unselected package netbase.
Preparing to unpack .../049-netbase_6.2_all.deb ...
Unpacking netbase (6.2) ...
Selecting previously unselected package libmagic-mgc.
Preparing to unpack .../050-libmagic-mgc_1%3a5.38-5_amd64.deb ...
Unpacking libmagic-mgc (1:5.38-5) ...
Selecting previously unselected package libmagic1:amd64.
Preparing to unpack .../051-libmagic1_1%3a5.38-5_amd64.deb ...
Unpacking libmagic1:amd64 (1:5.38-5) ...
Selecting previously unselected package file.
Preparing to unpack .../052-file_1%3a5.38-5_amd64.deb ...
Unpacking file (1:5.38-5) ...
Selecting previously unselected package gettext-base.
Preparing to unpack .../053-gettext-base_0.19.8.1-10_amd64.deb ...
Unpacking gettext-base (0.19.8.1-10) ...
Selecting previously unselected package aglfn.
Preparing to unpack .../054-aglfn_1.7+git20191031.4036a9c-2_all.deb ...
Unpacking aglfn (1.7+git20191031.4036a9c-2) ...
Selecting previously unselected package libsigsegv2:amd64.
Preparing to unpack .../055-libsigsegv2_2.12-2_amd64.deb ...
Unpacking libsigsegv2:amd64 (2.12-2) ...
Selecting previously unselected package m4.
Preparing to unpack .../056-m4_1.4.18-4_amd64.deb ...
Unpacking m4 (1.4.18-4) ...
Selecting previously unselected package autoconf.
Preparing to unpack .../057-autoconf_2.69-11.1_all.deb ...
Unpacking autoconf (2.69-11.1) ...
Selecting previously unselected package autotools-dev.
Preparing to unpack .../058-autotools-dev_20180224.1_all.deb ...
Unpacking autotools-dev (20180224.1) ...
Selecting previously unselected package automake.
Preparing to unpack .../059-automake_1%3a1.16.2-4_all.deb ...
Unpacking automake (1:1.16.2-4) ...
Selecting previously unselected package autopoint.
Preparing to unpack .../060-autopoint_0.19.8.1-10_all.deb ...
Unpacking autopoint (0.19.8.1-10) ...
Selecting previously unselected package openssl.
Preparing to unpack .../061-openssl_1.1.1h-1_amd64.deb ...
Unpacking openssl (1.1.1h-1) ...
Selecting previously unselected package ca-certificates.
Preparing to unpack .../062-ca-certificates_20200601_all.deb ...
Unpacking ca-certificates (20200601) ...
Selecting previously unselected package libcapture-tiny-perl.
Preparing to unpack .../063-libcapture-tiny-perl_0.48-1_all.deb ...
Unpacking libcapture-tiny-perl (0.48-1) ...
Selecting previously unselected package libparams-util-perl.
Preparing to unpack .../064-libparams-util-perl_1.101-1_amd64.deb ...
Unpacking libparams-util-perl (1.101-1) ...
Selecting previously unselected package libsub-install-perl.
Preparing to unpack .../065-libsub-install-perl_0.928-1_all.deb ...
Unpacking libsub-install-perl (0.928-1) ...
Selecting previously unselected package libdata-optlist-perl.
Preparing to unpack .../066-libdata-optlist-perl_0.110-1_all.deb ...
Unpacking libdata-optlist-perl (0.110-1) ...
Selecting previously unselected package libb-hooks-op-check-perl.
Preparing to unpack .../067-libb-hooks-op-check-perl_0.22-1+b2_amd64.deb ...
Unpacking libb-hooks-op-check-perl (0.22-1+b2) ...
Selecting previously unselected package libdynaloader-functions-perl.
Preparing to unpack .../068-libdynaloader-functions-perl_0.003-1_all.deb ...
Unpacking libdynaloader-functions-perl (0.003-1) ...
Selecting previously unselected package libdevel-callchecker-perl.
Preparing to unpack .../069-libdevel-callchecker-perl_0.008-1+b1_amd64.deb ...
Unpacking libdevel-callchecker-perl (0.008-1+b1) ...
Selecting previously unselected package libparams-classify-perl.
Preparing to unpack .../070-libparams-classify-perl_0.015-1+b2_amd64.deb ...
Unpacking libparams-classify-perl (0.015-1+b2) ...
Selecting previously unselected package libmodule-runtime-perl.
Preparing to unpack .../071-libmodule-runtime-perl_0.016-1_all.deb ...
Unpacking libmodule-runtime-perl (0.016-1) ...
Selecting previously unselected package libtry-tiny-perl.
Preparing to unpack .../072-libtry-tiny-perl_0.30-1_all.deb ...
Unpacking libtry-tiny-perl (0.30-1) ...
Selecting previously unselected package libmodule-implementation-perl.
Preparing to unpack .../073-libmodule-implementation-perl_0.09-1_all.deb ...
Unpacking libmodule-implementation-perl (0.09-1) ...
Selecting previously unselected package libpackage-stash-perl.
Preparing to unpack .../074-libpackage-stash-perl_0.38-1_all.deb ...
Unpacking libpackage-stash-perl (0.38-1) ...
Selecting previously unselected package libclass-load-perl.
Preparing to unpack .../075-libclass-load-perl_0.25-1_all.deb ...
Unpacking libclass-load-perl (0.25-1) ...
Selecting previously unselected package libio-stringy-perl.
Preparing to unpack .../076-libio-stringy-perl_2.111-3_all.deb ...
Unpacking libio-stringy-perl (2.111-3) ...
Selecting previously unselected package libparams-validate-perl:amd64.
Preparing to unpack .../077-libparams-validate-perl_1.30-1_amd64.deb ...
Unpacking libparams-validate-perl:amd64 (1.30-1) ...
Selecting previously unselected package libsub-exporter-perl.
Preparing to unpack .../078-libsub-exporter-perl_0.987-1_all.deb ...
Unpacking libsub-exporter-perl (0.987-1) ...
Selecting previously unselected package libgetopt-long-descriptive-perl.
Preparing to unpack .../079-libgetopt-long-descriptive-perl_0.105-1_all.deb ...
Unpacking libgetopt-long-descriptive-perl (0.105-1) ...
Selecting previously unselected package libio-tiecombine-perl.
Preparing to unpack .../080-libio-tiecombine-perl_1.005-1_all.deb ...
Unpacking libio-tiecombine-perl (1.005-1) ...
Selecting previously unselected package libmodule-pluggable-perl.
Preparing to unpack .../081-libmodule-pluggable-perl_5.2-1_all.deb ...
Unpacking libmodule-pluggable-perl (5.2-1) ...
Selecting previously unselected package libstring-rewriteprefix-perl.
Preparing to unpack .../082-libstring-rewriteprefix-perl_0.008-1_all.deb ...
Unpacking libstring-rewriteprefix-perl (0.008-1) ...
Selecting previously unselected package libapp-cmd-perl.
Preparing to unpack .../083-libapp-cmd-perl_0.331-1_all.deb ...
Unpacking libapp-cmd-perl (0.331-1) ...
Selecting previously unselected package libboolean-perl.
Preparing to unpack .../084-libboolean-perl_0.46-1_all.deb ...
Unpacking libboolean-perl (0.46-1) ...
Selecting previously unselected package libcarp-assert-perl.
Preparing to unpack .../085-libcarp-assert-perl_0.21-1_all.deb ...
Unpacking libcarp-assert-perl (0.21-1) ...
Selecting previously unselected package libsub-uplevel-perl.
Preparing to unpack .../086-libsub-uplevel-perl_0.2800-1_all.deb ...
Unpacking libsub-uplevel-perl (0.2800-1) ...
Selecting previously unselected package libtest-exception-perl.
Preparing to unpack .../087-libtest-exception-perl_0.43-1_all.deb ...
Unpacking libtest-exception-perl (0.43-1) ...
Selecting previously unselected package libcarp-assert-more-perl.
Preparing to unpack .../088-libcarp-assert-more-perl_1.24-1_all.deb ...
Unpacking libcarp-assert-more-perl (1.24-1) ...
Selecting previously unselected package libfile-which-perl.
Preparing to unpack .../089-libfile-which-perl_1.23-1_all.deb ...
Unpacking libfile-which-perl (1.23-1) ...
Selecting previously unselected package libfile-homedir-perl.
Preparing to unpack .../090-libfile-homedir-perl_1.006-1_all.deb ...
Unpacking libfile-homedir-perl (1.006-1) ...
Selecting previously unselected package libclone-choose-perl.
Preparing to unpack .../091-libclone-choose-perl_0.010-1_all.deb ...
Unpacking libclone-choose-perl (0.010-1) ...
Selecting previously unselected package libhash-merge-perl.
Preparing to unpack .../092-libhash-merge-perl_0.302-1_all.deb ...
Unpacking libhash-merge-perl (0.302-1) ...
Selecting previously unselected package libjson-perl.
Preparing to unpack .../093-libjson-perl_4.02000-2_all.deb ...
Unpacking libjson-perl (4.02000-2) ...
Selecting previously unselected package libexporter-tiny-perl.
Preparing to unpack .../094-libexporter-tiny-perl_1.002002-1_all.deb ...
Unpacking libexporter-tiny-perl (1.002002-1) ...
Selecting previously unselected package liblist-moreutils-perl.
Preparing to unpack .../095-liblist-moreutils-perl_0.416-1+b5_amd64.deb ...
Unpacking liblist-moreutils-perl (0.416-1+b5) ...
Selecting previously unselected package liblog-log4perl-perl.
Preparing to unpack .../096-liblog-log4perl-perl_1.53-1_all.deb ...
Unpacking liblog-log4perl-perl (1.53-1) ...
Selecting previously unselected package libmouse-perl.
Preparing to unpack .../097-libmouse-perl_2.5.10-1_amd64.deb ...
Unpacking libmouse-perl (2.5.10-1) ...
Selecting previously unselected package libmousex-nativetraits-perl.
Preparing to unpack .../098-libmousex-nativetraits-perl_1.09-2_all.deb ...
Unpacking libmousex-nativetraits-perl (1.09-2) ...
Selecting previously unselected package libmousex-strictconstructor-perl.
Preparing to unpack .../099-libmousex-strictconstructor-perl_0.02-2_all.deb ...
Unpacking libmousex-strictconstructor-perl (0.02-2) ...
Selecting previously unselected package libparse-recdescent-perl.
Preparing to unpack .../100-libparse-recdescent-perl_1.967015+dfsg-2_all.deb ...
Unpacking libparse-recdescent-perl (1.967015+dfsg-2) ...
Selecting previously unselected package libpath-tiny-perl.
Preparing to unpack .../101-libpath-tiny-perl_0.114-1_all.deb ...
Unpacking libpath-tiny-perl (0.114-1) ...
Selecting previously unselected package libpod-pom-perl.
Preparing to unpack .../102-libpod-pom-perl_2.01-3_all.deb ...
Unpacking libpod-pom-perl (2.01-3) ...
Selecting previously unselected package libregexp-common-perl.
Preparing to unpack .../103-libregexp-common-perl_2017060201-1_all.deb ...
Unpacking libregexp-common-perl (2017060201-1) ...
Selecting previously unselected package libconfig-model-perl.
Preparing to unpack .../104-libconfig-model-perl_2.140-1_all.deb ...
Unpacking libconfig-model-perl (2.140-1) ...
Selecting previously unselected package libyaml-perl.
Preparing to unpack .../105-libyaml-perl_1.30-1_all.deb ...
Unpacking libyaml-perl (1.30-1) ...
Selecting previously unselected package cme.
Preparing to unpack .../106-cme_1.032-1_all.deb ...
Unpacking cme (1.032-1) ...
Selecting previously unselected package libtool.
Preparing to unpack .../107-libtool_2.4.6-14_all.deb ...
Unpacking libtool (2.4.6-14) ...
Selecting previously unselected package dh-autoreconf.
Preparing to unpack .../108-dh-autoreconf_19_all.deb ...
Unpacking dh-autoreconf (19) ...
Selecting previously unselected package libdebhelper-perl.
Preparing to unpack .../109-libdebhelper-perl_13.2.1_all.deb ...
Unpacking libdebhelper-perl (13.2.1) ...
Selecting previously unselected package libarchive-zip-perl.
Preparing to unpack .../110-libarchive-zip-perl_1.68-1_all.deb ...
Unpacking libarchive-zip-perl (1.68-1) ...
Selecting previously unselected package libsub-override-perl.
Preparing to unpack .../111-libsub-override-perl_0.09-2_all.deb ...
Unpacking libsub-override-perl (0.09-2) ...
Selecting previously unselected package libfile-stripnondeterminism-perl.
Preparing to unpack .../112-libfile-stripnondeterminism-perl_1.9.0-1_all.deb ...
Unpacking libfile-stripnondeterminism-perl (1.9.0-1) ...
Selecting previously unselected package dh-strip-nondeterminism.
Preparing to unpack .../113-dh-strip-nondeterminism_1.9.0-1_all.deb ...
Unpacking dh-strip-nondeterminism (1.9.0-1) ...
Selecting previously unselected package libelf1:amd64.
Preparing to unpack .../114-libelf1_0.181-1_amd64.deb ...
Unpacking libelf1:amd64 (0.181-1) ...
Selecting previously unselected package dwz.
Preparing to unpack .../115-dwz_0.13-5_amd64.deb ...
Unpacking dwz (0.13-5) ...
Selecting previously unselected package libcroco3:amd64.
Preparing to unpack .../116-libcroco3_0.6.13-1_amd64.deb ...
Unpacking libcroco3:amd64 (0.6.13-1) ...
Selecting previously unselected package gettext.
Preparing to unpack .../117-gettext_0.19.8.1-10_amd64.deb ...
Unpacking gettext (0.19.8.1-10) ...
Selecting previously unselected package intltool-debian.
Preparing to unpack .../118-intltool-debian_0.35.0+20060710.5_all.deb ...
Unpacking intltool-debian (0.35.0+20060710.5) ...
Selecting previously unselected package po-debconf.
Preparing to unpack .../119-po-debconf_1.0.21_all.deb ...
Unpacking po-debconf (1.0.21) ...
Selecting previously unselected package debhelper.
Preparing to unpack .../120-debhelper_13.2.1_all.deb ...
Unpacking debhelper (13.2.1) ...
Selecting previously unselected package libblas3:amd64.
Preparing to unpack .../121-libblas3_3.9.0-3_amd64.deb ...
Unpacking libblas3:amd64 (3.9.0-3) ...
Selecting previously unselected package libgfortran5:amd64.
Preparing to unpack .../122-libgfortran5_10.2.0-15_amd64.deb ...
Unpacking libgfortran5:amd64 (10.2.0-15) ...
Selecting previously unselected package liblapack3:amd64.
Preparing to unpack .../123-liblapack3_3.9.0-3_amd64.deb ...
Unpacking liblapack3:amd64 (3.9.0-3) ...
Selecting previously unselected package libarpack2:amd64.
Preparing to unpack .../124-libarpack2_3.7.0-3_amd64.deb ...
Unpacking libarpack2:amd64 (3.7.0-3) ...
Selecting previously unselected package libsuitesparseconfig5:amd64.
Preparing to unpack .../125-libsuitesparseconfig5_1%3a5.8.1+dfsg-2_amd64.deb ...
Unpacking libsuitesparseconfig5:amd64 (1:5.8.1+dfsg-2) ...
Selecting previously unselected package libamd2:amd64.
Preparing to unpack .../126-libamd2_1%3a5.8.1+dfsg-2_amd64.deb ...
Unpacking libamd2:amd64 (1:5.8.1+dfsg-2) ...
Selecting previously unselected package libcamd2:amd64.
Preparing to unpack .../127-libcamd2_1%3a5.8.1+dfsg-2_amd64.deb ...
Unpacking libcamd2:amd64 (1:5.8.1+dfsg-2) ...
Selecting previously unselected package libccolamd2:amd64.
Preparing to unpack .../128-libccolamd2_1%3a5.8.1+dfsg-2_amd64.deb ...
Unpacking libccolamd2:amd64 (1:5.8.1+dfsg-2) ...
Selecting previously unselected package libcolamd2:amd64.
Preparing to unpack .../129-libcolamd2_1%3a5.8.1+dfsg-2_amd64.deb ...
Unpacking libcolamd2:amd64 (1:5.8.1+dfsg-2) ...
Selecting previously unselected package libmetis5:amd64.
Preparing to unpack .../130-libmetis5_5.1.0.dfsg-7_amd64.deb ...
Unpacking libmetis5:amd64 (5.1.0.dfsg-7) ...
Selecting previously unselected package libcholmod3:amd64.
Preparing to unpack .../131-libcholmod3_1%3a5.8.1+dfsg-2_amd64.deb ...
Unpacking libcholmod3:amd64 (1:5.8.1+dfsg-2) ...
Selecting previously unselected package libsasl2-modules-db:amd64.
Preparing to unpack .../132-libsasl2-modules-db_2.1.27+dfsg-2_amd64.deb ...
Unpacking libsasl2-modules-db:amd64 (2.1.27+dfsg-2) ...
Selecting previously unselected package libsasl2-2:amd64.
Preparing to unpack .../133-libsasl2-2_2.1.27+dfsg-2_amd64.deb ...
Unpacking libsasl2-2:amd64 (2.1.27+dfsg-2) ...
Selecting previously unselected package libldap-2.4-2:amd64.
Preparing to unpack .../134-libldap-2.4-2_2.4.54+dfsg-1_amd64.deb ...
Unpacking libldap-2.4-2:amd64 (2.4.54+dfsg-1) ...
Selecting previously unselected package libnghttp2-14:amd64.
Preparing to unpack .../135-libnghttp2-14_1.41.0-3_amd64.deb ...
Unpacking libnghttp2-14:amd64 (1.41.0-3) ...
Selecting previously unselected package libpsl5:amd64.
Preparing to unpack .../136-libpsl5_0.21.0-1.1_amd64.deb ...
Unpacking libpsl5:amd64 (0.21.0-1.1) ...
Selecting previously unselected package librtmp1:amd64.
Preparing to unpack .../137-librtmp1_2.4+20151223.gitfa8646d.1-2+b2_amd64.deb ...
Unpacking librtmp1:amd64 (2.4+20151223.gitfa8646d.1-2+b2) ...
Selecting previously unselected package libssh2-1:amd64.
Preparing to unpack .../138-libssh2-1_1.8.0-2.1_amd64.deb ...
Unpacking libssh2-1:amd64 (1.8.0-2.1) ...
Selecting previously unselected package libcurl3-gnutls:amd64.
Preparing to unpack .../139-libcurl3-gnutls_7.72.0-1_amd64.deb ...
Unpacking libcurl3-gnutls:amd64 (7.72.0-1) ...
Selecting previously unselected package libcxsparse3:amd64.
Preparing to unpack .../140-libcxsparse3_1%3a5.8.1+dfsg-2_amd64.deb ...
Unpacking libcxsparse3:amd64 (1:5.8.1+dfsg-2) ...
Selecting previously unselected package libfftw3-single3:amd64.
Preparing to unpack .../141-libfftw3-single3_3.3.8-2_amd64.deb ...
Unpacking libfftw3-single3:amd64 (3.3.8-2) ...
Selecting previously unselected package libglvnd0:amd64.
Preparing to unpack .../142-libglvnd0_1.3.2-1_amd64.deb ...
Unpacking libglvnd0:amd64 (1.3.2-1) ...
Selecting previously unselected package libdrm-common.
Preparing to unpack .../143-libdrm-common_2.4.102-1_all.deb ...
Unpacking libdrm-common (2.4.102-1) ...
Selecting previously unselected package libdrm2:amd64.
Preparing to unpack .../144-libdrm2_2.4.102-1_amd64.deb ...
Unpacking libdrm2:amd64 (2.4.102-1) ...
Selecting previously unselected package libglapi-mesa:amd64.
Preparing to unpack .../145-libglapi-mesa_20.2.1-1_amd64.deb ...
Unpacking libglapi-mesa:amd64 (20.2.1-1) ...
Selecting previously unselected package libx11-xcb1:amd64.
Preparing to unpack .../146-libx11-xcb1_2%3a1.6.12-1_amd64.deb ...
Unpacking libx11-xcb1:amd64 (2:1.6.12-1) ...
Selecting previously unselected package libxcb-dri2-0:amd64.
Preparing to unpack .../147-libxcb-dri2-0_1.14-2_amd64.deb ...
Unpacking libxcb-dri2-0:amd64 (1.14-2) ...
Selecting previously unselected package libxcb-dri3-0:amd64.
Preparing to unpack .../148-libxcb-dri3-0_1.14-2_amd64.deb ...
Unpacking libxcb-dri3-0:amd64 (1.14-2) ...
Selecting previously unselected package libxcb-glx0:amd64.
Preparing to unpack .../149-libxcb-glx0_1.14-2_amd64.deb ...
Unpacking libxcb-glx0:amd64 (1.14-2) ...
Selecting previously unselected package libxcb-present0:amd64.
Preparing to unpack .../150-libxcb-present0_1.14-2_amd64.deb ...
Unpacking libxcb-present0:amd64 (1.14-2) ...
Selecting previously unselected package libxcb-sync1:amd64.
Preparing to unpack .../151-libxcb-sync1_1.14-2_amd64.deb ...
Unpacking libxcb-sync1:amd64 (1.14-2) ...
Selecting previously unselected package libxcb-xfixes0:amd64.
Preparing to unpack .../152-libxcb-xfixes0_1.14-2_amd64.deb ...
Unpacking libxcb-xfixes0:amd64 (1.14-2) ...
Selecting previously unselected package libxdamage1:amd64.
Preparing to unpack .../153-libxdamage1_1%3a1.1.5-2_amd64.deb ...
Unpacking libxdamage1:amd64 (1:1.1.5-2) ...
Selecting previously unselected package libxfixes3:amd64.
Preparing to unpack .../154-libxfixes3_1%3a5.0.3-2_amd64.deb ...
Unpacking libxfixes3:amd64 (1:5.0.3-2) ...
Selecting previously unselected package libxshmfence1:amd64.
Preparing to unpack .../155-libxshmfence1_1.3-1_amd64.deb ...
Unpacking libxshmfence1:amd64 (1.3-1) ...
Selecting previously unselected package libxxf86vm1:amd64.
Preparing to unpack .../156-libxxf86vm1_1%3a1.1.4-1+b2_amd64.deb ...
Unpacking libxxf86vm1:amd64 (1:1.1.4-1+b2) ...
Selecting previously unselected package libdrm-amdgpu1:amd64.
Preparing to unpack .../157-libdrm-amdgpu1_2.4.102-1_amd64.deb ...
Unpacking libdrm-amdgpu1:amd64 (2.4.102-1) ...
Selecting previously unselected package libpciaccess0:amd64.
Preparing to unpack .../158-libpciaccess0_0.16-1_amd64.deb ...
Unpacking libpciaccess0:amd64 (0.16-1) ...
Selecting previously unselected package libdrm-intel1:amd64.
Preparing to unpack .../159-libdrm-intel1_2.4.102-1_amd64.deb ...
Unpacking libdrm-intel1:amd64 (2.4.102-1) ...
Selecting previously unselected package libdrm-nouveau2:amd64.
Preparing to unpack .../160-libdrm-nouveau2_2.4.102-1_amd64.deb ...
Unpacking libdrm-nouveau2:amd64 (2.4.102-1) ...
Selecting previously unselected package libdrm-radeon1:amd64.
Preparing to unpack .../161-libdrm-radeon1_2.4.102-1_amd64.deb ...
Unpacking libdrm-radeon1:amd64 (2.4.102-1) ...
Selecting previously unselected package libllvm11:amd64.
Preparing to unpack .../162-libllvm11_1%3a11.0.0-3_amd64.deb ...
Unpacking libllvm11:amd64 (1:11.0.0-3) ...
Selecting previously unselected package libsensors-config.
Preparing to unpack .../163-libsensors-config_1%3a3.6.0-2_all.deb ...
Unpacking libsensors-config (1:3.6.0-2) ...
Selecting previously unselected package libsensors5:amd64.
Preparing to unpack .../164-libsensors5_1%3a3.6.0-2_amd64.deb ...
Unpacking libsensors5:amd64 (1:3.6.0-2) ...
Selecting previously unselected package libvulkan1:amd64.
Preparing to unpack .../165-libvulkan1_1.2.154.1-1_amd64.deb ...
Unpacking libvulkan1:amd64 (1.2.154.1-1) ...
Selecting previously unselected package libgl1-mesa-dri:amd64.
Preparing to unpack .../166-libgl1-mesa-dri_20.2.1-1_amd64.deb ...
Unpacking libgl1-mesa-dri:amd64 (20.2.1-1) ...
Selecting previously unselected package libglx-mesa0:amd64.
Preparing to unpack .../167-libglx-mesa0_20.2.1-1_amd64.deb ...
Unpacking libglx-mesa0:amd64 (20.2.1-1) ...
Selecting previously unselected package libglx0:amd64.
Preparing to unpack .../168-libglx0_1.3.2-1_amd64.deb ...
Unpacking libglx0:amd64 (1.3.2-1) ...
Selecting previously unselected package libgl1:amd64.
Preparing to unpack .../169-libgl1_1.3.2-1_amd64.deb ...
Unpacking libgl1:amd64 (1.3.2-1) ...
Selecting previously unselected package libgl2ps1.4.
Preparing to unpack .../170-libgl2ps1.4_1.4.2+dfsg1-1_amd64.deb ...
Unpacking libgl2ps1.4 (1.4.2+dfsg1-1) ...
Selecting previously unselected package libglu1-mesa:amd64.
Preparing to unpack .../171-libglu1-mesa_9.0.1-1_amd64.deb ...
Unpacking libglu1-mesa:amd64 (9.0.1-1) ...
Selecting previously unselected package libwmf0.2-7:amd64.
Preparing to unpack .../172-libwmf0.2-7_0.2.8.4-17_amd64.deb ...
Unpacking libwmf0.2-7:amd64 (0.2.8.4-17) ...
Selecting previously unselected package libgraphicsmagick-q16-3.
Preparing to unpack .../173-libgraphicsmagick-q16-3_1.4+really1.3.35+hg16348-1_amd64.deb ...
Unpacking libgraphicsmagick-q16-3 (1.4+really1.3.35+hg16348-1) ...
Selecting previously unselected package libgraphicsmagick++-q16-12.
Preparing to unpack .../174-libgraphicsmagick++-q16-12_1.4+really1.3.35+hg16348-1_amd64.deb ...
Unpacking libgraphicsmagick++-q16-12 (1.4+really1.3.35+hg16348-1) ...
Selecting previously unselected package libaec0:amd64.
Preparing to unpack .../175-libaec0_1.0.4-1_amd64.deb ...
Unpacking libaec0:amd64 (1.0.4-1) ...
Selecting previously unselected package libsz2:amd64.
Preparing to unpack .../176-libsz2_1.0.4-1_amd64.deb ...
Unpacking libsz2:amd64 (1.0.4-1) ...
Selecting previously unselected package libhdf5-103-1:amd64.
Preparing to unpack .../177-libhdf5-103-1_1.10.6+repack-2_amd64.deb ...
Unpacking libhdf5-103-1:amd64 (1.10.6+repack-2) ...
Selecting previously unselected package libqrupdate1:amd64.
Preparing to unpack .../178-libqrupdate1_1.1.2-4_amd64.deb ...
Unpacking libqrupdate1:amd64 (1.1.2-4) ...
Selecting previously unselected package libumfpack5:amd64.
Preparing to unpack .../179-libumfpack5_1%3a5.8.1+dfsg-2_amd64.deb ...
Unpacking libumfpack5:amd64 (1:5.8.1+dfsg-2) ...
Selecting previously unselected package liboctave7:amd64.
Preparing to unpack .../180-liboctave7_5.2.0-3+b1_amd64.deb ...
Unpacking liboctave7:amd64 (5.2.0-3+b1) ...
Selecting previously unselected package libxrender1:amd64.
Preparing to unpack .../181-libxrender1_1%3a0.9.10-1_amd64.deb ...
Unpacking libxrender1:amd64 (1:0.9.10-1) ...
Selecting previously unselected package libxcursor1:amd64.
Preparing to unpack .../182-libxcursor1_1%3a1.2.0-2_amd64.deb ...
Unpacking libxcursor1:amd64 (1:1.2.0-2) ...
Selecting previously unselected package libxft2:amd64.
Preparing to unpack .../183-libxft2_2.3.2-2_amd64.deb ...
Unpacking libxft2:amd64 (2.3.2-2) ...
Selecting previously unselected package libxinerama1:amd64.
Preparing to unpack .../184-libxinerama1_2%3a1.1.4-2_amd64.deb ...
Unpacking libxinerama1:amd64 (2:1.1.4-2) ...
Selecting previously unselected package libfltk1.3:amd64.
Preparing to unpack .../185-libfltk1.3_1.3.5-1_amd64.deb ...
Unpacking libfltk1.3:amd64 (1.3.5-1) ...
Selecting previously unselected package libfltk-gl1.3:amd64.
Preparing to unpack .../186-libfltk-gl1.3_1.3.5-1_amd64.deb ...
Unpacking libfltk-gl1.3:amd64 (1.3.5-1) ...
Selecting previously unselected package libglpk40:amd64.
Preparing to unpack .../187-libglpk40_4.65-2_amd64.deb ...
Unpacking libglpk40:amd64 (4.65-2) ...
Selecting previously unselected package libasound2-data.
Preparing to unpack .../188-libasound2-data_1.2.3.2-1_all.deb ...
Unpacking libasound2-data (1.2.3.2-1) ...
Selecting previously unselected package libasound2:amd64.
Preparing to unpack .../189-libasound2_1.2.3.2-1_amd64.deb ...
Unpacking libasound2:amd64 (1.2.3.2-1) ...
Selecting previously unselected package libsamplerate0:amd64.
Preparing to unpack .../190-libsamplerate0_0.1.9-2_amd64.deb ...
Unpacking libsamplerate0:amd64 (0.1.9-2) ...
Selecting previously unselected package libjack-jackd2-0:amd64.
Preparing to unpack .../191-libjack-jackd2-0_1.9.16~dfsg-1_amd64.deb ...
Unpacking libjack-jackd2-0:amd64 (1.9.16~dfsg-1) ...
Selecting previously unselected package libportaudio2:amd64.
Preparing to unpack .../192-libportaudio2_19.6.0-1.1_amd64.deb ...
Unpacking libportaudio2:amd64 (19.6.0-1.1) ...
Selecting previously unselected package libqhull8.0:amd64.
Preparing to unpack .../193-libqhull8.0_2020.1-2_amd64.deb ...
Unpacking libqhull8.0:amd64 (2020.1-2) ...
Selecting previously unselected package libqscintilla2-qt5-l10n.
Preparing to unpack .../194-libqscintilla2-qt5-l10n_2.11.5+dfsg-3_all.deb ...
Unpacking libqscintilla2-qt5-l10n (2.11.5+dfsg-3) ...
Selecting previously unselected package shared-mime-info.
Preparing to unpack .../195-shared-mime-info_2.0-1_amd64.deb ...
Unpacking shared-mime-info (2.0-1) ...
Selecting previously unselected package libdouble-conversion3:amd64.
Preparing to unpack .../196-libdouble-conversion3_3.1.5-6_amd64.deb ...
Unpacking libdouble-conversion3:amd64 (3.1.5-6) ...
Selecting previously unselected package libpcre2-16-0:amd64.
Preparing to unpack .../197-libpcre2-16-0_10.34-7_amd64.deb ...
Unpacking libpcre2-16-0:amd64 (10.34-7) ...
Selecting previously unselected package libqt5core5a:amd64.
Preparing to unpack .../198-libqt5core5a_5.14.2+dfsg-6_amd64.deb ...
Unpacking libqt5core5a:amd64 (5.14.2+dfsg-6) ...
Selecting previously unselected package fontconfig.
Preparing to unpack .../199-fontconfig_2.13.1-4.2_amd64.deb ...
Unpacking fontconfig (2.13.1-4.2) ...
Selecting previously unselected package libwayland-server0:amd64.
Preparing to unpack .../200-libwayland-server0_1.18.0-2~exp1.1_amd64.deb ...
Unpacking libwayland-server0:amd64 (1.18.0-2~exp1.1) ...
Selecting previously unselected package libgbm1:amd64.
Preparing to unpack .../201-libgbm1_20.2.1-1_amd64.deb ...
Unpacking libgbm1:amd64 (20.2.1-1) ...
Selecting previously unselected package libwayland-client0:amd64.
Preparing to unpack .../202-libwayland-client0_1.18.0-2~exp1.1_amd64.deb ...
Unpacking libwayland-client0:amd64 (1.18.0-2~exp1.1) ...
Selecting previously unselected package libegl-mesa0:amd64.
Preparing to unpack .../203-libegl-mesa0_20.2.1-1_amd64.deb ...
Unpacking libegl-mesa0:amd64 (20.2.1-1) ...
Selecting previously unselected package libegl1:amd64.
Preparing to unpack .../204-libegl1_1.3.2-1_amd64.deb ...
Unpacking libegl1:amd64 (1.3.2-1) ...
Selecting previously unselected package libgraphite2-3:amd64.
Preparing to unpack .../205-libgraphite2-3_1.3.14-1_amd64.deb ...
Unpacking libgraphite2-3:amd64 (1.3.14-1) ...
Selecting previously unselected package libharfbuzz0b:amd64.
Preparing to unpack .../206-libharfbuzz0b_2.6.7-1_amd64.deb ...
Unpacking libharfbuzz0b:amd64 (2.6.7-1) ...
Selecting previously unselected package x11-common.
Preparing to unpack .../207-x11-common_1%3a7.7+21_all.deb ...
Unpacking x11-common (1:7.7+21) ...
Selecting previously unselected package libice6:amd64.
Preparing to unpack .../208-libice6_2%3a1.0.10-1_amd64.deb ...
Unpacking libice6:amd64 (2:1.0.10-1) ...
Selecting previously unselected package libevdev2:amd64.
Preparing to unpack .../209-libevdev2_1.9.1+dfsg-1_amd64.deb ...
Unpacking libevdev2:amd64 (1.9.1+dfsg-1) ...
Selecting previously unselected package libmtdev1:amd64.
Preparing to unpack .../210-libmtdev1_1.1.6-1_amd64.deb ...
Unpacking libmtdev1:amd64 (1.1.6-1) ...
Selecting previously unselected package libgudev-1.0-0:amd64.
Preparing to unpack .../211-libgudev-1.0-0_234-1_amd64.deb ...
Unpacking libgudev-1.0-0:amd64 (234-1) ...
Selecting previously unselected package libwacom-common.
Preparing to unpack .../212-libwacom-common_1.5-1_all.deb ...
Unpacking libwacom-common (1.5-1) ...
Selecting previously unselected package libwacom2:amd64.
Preparing to unpack .../213-libwacom2_1.5-1_amd64.deb ...
Unpacking libwacom2:amd64 (1.5-1) ...
Selecting previously unselected package libinput-bin.
Preparing to unpack .../214-libinput-bin_1.16.2-1_amd64.deb ...
Unpacking libinput-bin (1.16.2-1) ...
Selecting previously unselected package libinput10:amd64.
Preparing to unpack .../215-libinput10_1.16.2-1_amd64.deb ...
Unpacking libinput10:amd64 (1.16.2-1) ...
Selecting previously unselected package libmd4c0:amd64.
Preparing to unpack .../216-libmd4c0_0.4.6-1_amd64.deb ...
Unpacking libmd4c0:amd64 (0.4.6-1) ...
Selecting previously unselected package libdbus-1-3:amd64.
Preparing to unpack .../217-libdbus-1-3_1.12.20-1_amd64.deb ...
Unpacking libdbus-1-3:amd64 (1.12.20-1) ...
Selecting previously unselected package libqt5dbus5:amd64.
Preparing to unpack .../218-libqt5dbus5_5.14.2+dfsg-6_amd64.deb ...
Unpacking libqt5dbus5:amd64 (5.14.2+dfsg-6) ...
Selecting previously unselected package libqt5network5:amd64.
Preparing to unpack .../219-libqt5network5_5.14.2+dfsg-6_amd64.deb ...
Unpacking libqt5network5:amd64 (5.14.2+dfsg-6) ...
Selecting previously unselected package libsm6:amd64.
Preparing to unpack .../220-libsm6_2%3a1.2.3-1_amd64.deb ...
Unpacking libsm6:amd64 (2:1.2.3-1) ...
Selecting previously unselected package libxcb-icccm4:amd64.
Preparing to unpack .../221-libxcb-icccm4_0.4.1-1.1_amd64.deb ...
Unpacking libxcb-icccm4:amd64 (0.4.1-1.1) ...
Selecting previously unselected package libxcb-shm0:amd64.
Preparing to unpack .../222-libxcb-shm0_1.14-2_amd64.deb ...
Unpacking libxcb-shm0:amd64 (1.14-2) ...
Selecting previously unselected package libxcb-util0:amd64.
Preparing to unpack .../223-libxcb-util0_0.3.8-3+b2_amd64.deb ...
Unpacking libxcb-util0:amd64 (0.3.8-3+b2) ...
Selecting previously unselected package libxcb-image0:amd64.
Preparing to unpack .../224-libxcb-image0_0.4.0-1+b2_amd64.deb ...
Unpacking libxcb-image0:amd64 (0.4.0-1+b2) ...
Selecting previously unselected package libxcb-keysyms1:amd64.
Preparing to unpack .../225-libxcb-keysyms1_0.4.0-1+b2_amd64.deb ...
Unpacking libxcb-keysyms1:amd64 (0.4.0-1+b2) ...
Selecting previously unselected package libxcb-randr0:amd64.
Preparing to unpack .../226-libxcb-randr0_1.14-2_amd64.deb ...
Unpacking libxcb-randr0:amd64 (1.14-2) ...
Selecting previously unselected package libxcb-render0:amd64.
Preparing to unpack .../227-libxcb-render0_1.14-2_amd64.deb ...
Unpacking libxcb-render0:amd64 (1.14-2) ...
Selecting previously unselected package libxcb-render-util0:amd64.
Preparing to unpack .../228-libxcb-render-util0_0.3.9-1+b1_amd64.deb ...
Unpacking libxcb-render-util0:amd64 (0.3.9-1+b1) ...
Selecting previously unselected package libxcb-shape0:amd64.
Preparing to unpack .../229-libxcb-shape0_1.14-2_amd64.deb ...
Unpacking libxcb-shape0:amd64 (1.14-2) ...
Selecting previously unselected package libxcb-xinerama0:amd64.
Preparing to unpack .../230-libxcb-xinerama0_1.14-2_amd64.deb ...
Unpacking libxcb-xinerama0:amd64 (1.14-2) ...
Selecting previously unselected package libxcb-xinput0:amd64.
Preparing to unpack .../231-libxcb-xinput0_1.14-2_amd64.deb ...
Unpacking libxcb-xinput0:amd64 (1.14-2) ...
Selecting previously unselected package libxcb-xkb1:amd64.
Preparing to unpack .../232-libxcb-xkb1_1.14-2_amd64.deb ...
Unpacking libxcb-xkb1:amd64 (1.14-2) ...
Selecting previously unselected package xkb-data.
Preparing to unpack .../233-xkb-data_2.29-2_all.deb ...
Unpacking xkb-data (2.29-2) ...
Selecting previously unselected package libxkbcommon0:amd64.
Preparing to unpack .../234-libxkbcommon0_1.0.1-1_amd64.deb ...
Unpacking libxkbcommon0:amd64 (1.0.1-1) ...
Selecting previously unselected package libxkbcommon-x11-0:amd64.
Preparing to unpack .../235-libxkbcommon-x11-0_1.0.1-1_amd64.deb ...
Unpacking libxkbcommon-x11-0:amd64 (1.0.1-1) ...
Selecting previously unselected package libqt5gui5:amd64.
Preparing to unpack .../236-libqt5gui5_5.14.2+dfsg-6_amd64.deb ...
Unpacking libqt5gui5:amd64 (5.14.2+dfsg-6) ...
Selecting previously unselected package libavahi-common-data:amd64.
Preparing to unpack .../237-libavahi-common-data_0.8-3_amd64.deb ...
Unpacking libavahi-common-data:amd64 (0.8-3) ...
Selecting previously unselected package libavahi-common3:amd64.
Preparing to unpack .../238-libavahi-common3_0.8-3_amd64.deb ...
Unpacking libavahi-common3:amd64 (0.8-3) ...
Selecting previously unselected package libavahi-client3:amd64.
Preparing to unpack .../239-libavahi-client3_0.8-3_amd64.deb ...
Unpacking libavahi-client3:amd64 (0.8-3) ...
Selecting previously unselected package libcups2:amd64.
Preparing to unpack .../240-libcups2_2.3.3-3_amd64.deb ...
Unpacking libcups2:amd64 (2.3.3-3) ...
Selecting previously unselected package libqt5widgets5:amd64.
Preparing to unpack .../241-libqt5widgets5_5.14.2+dfsg-6_amd64.deb ...
Unpacking libqt5widgets5:amd64 (5.14.2+dfsg-6) ...
Selecting previously unselected package libqt5printsupport5:amd64.
Preparing to unpack .../242-libqt5printsupport5_5.14.2+dfsg-6_amd64.deb ...
Unpacking libqt5printsupport5:amd64 (5.14.2+dfsg-6) ...
Selecting previously unselected package libqscintilla2-qt5-15.
Preparing to unpack .../243-libqscintilla2-qt5-15_2.11.5+dfsg-3+b1_amd64.deb ...
Unpacking libqscintilla2-qt5-15 (2.11.5+dfsg-3+b1) ...
Selecting previously unselected package libqt5sql5:amd64.
Preparing to unpack .../244-libqt5sql5_5.14.2+dfsg-6_amd64.deb ...
Unpacking libqt5sql5:amd64 (5.14.2+dfsg-6) ...
Selecting previously unselected package libqt5help5:amd64.
Preparing to unpack .../245-libqt5help5_5.14.2-3_amd64.deb ...
Unpacking libqt5help5:amd64 (5.14.2-3) ...
Selecting previously unselected package libqt5xml5:amd64.
Preparing to unpack .../246-libqt5xml5_5.14.2+dfsg-6_amd64.deb ...
Unpacking libqt5xml5:amd64 (5.14.2+dfsg-6) ...
Selecting previously unselected package libogg0:amd64.
Preparing to unpack .../247-libogg0_1.3.2-1+b1_amd64.deb ...
Unpacking libogg0:amd64 (1.3.2-1+b1) ...
Selecting previously unselected package libflac8:amd64.
Preparing to unpack .../248-libflac8_1.3.3-1_amd64.deb ...
Unpacking libflac8:amd64 (1.3.3-1) ...
Selecting previously unselected package libvorbis0a:amd64.
Preparing to unpack .../249-libvorbis0a_1.3.7-1_amd64.deb ...
Unpacking libvorbis0a:amd64 (1.3.7-1) ...
Selecting previously unselected package libvorbisenc2:amd64.
Preparing to unpack .../250-libvorbisenc2_1.3.7-1_amd64.deb ...
Unpacking libvorbisenc2:amd64 (1.3.7-1) ...
Selecting previously unselected package libsndfile1:amd64.
Preparing to unpack .../251-libsndfile1_1.0.28-8_amd64.deb ...
Unpacking libsndfile1:amd64 (1.0.28-8) ...
Selecting previously unselected package libtext-unidecode-perl.
Preparing to unpack .../252-libtext-unidecode-perl_1.30-1_all.deb ...
Unpacking libtext-unidecode-perl (1.30-1) ...
Selecting previously unselected package libxml-namespacesupport-perl.
Preparing to unpack .../253-libxml-namespacesupport-perl_1.12-1_all.deb ...
Unpacking libxml-namespacesupport-perl (1.12-1) ...
Selecting previously unselected package libxml-sax-base-perl.
Preparing to unpack .../254-libxml-sax-base-perl_1.09-1_all.deb ...
Unpacking libxml-sax-base-perl (1.09-1) ...
Selecting previously unselected package libxml-sax-perl.
Preparing to unpack .../255-libxml-sax-perl_1.02+dfsg-1_all.deb ...
Unpacking libxml-sax-perl (1.02+dfsg-1) ...
Selecting previously unselected package libxml-libxml-perl.
Preparing to unpack .../256-libxml-libxml-perl_2.0134+dfsg-2_amd64.deb ...
Unpacking libxml-libxml-perl (2.0134+dfsg-2) ...
Selecting previously unselected package texinfo.
Preparing to unpack .../257-texinfo_6.7.0.dfsg.2-5_amd64.deb ...
Unpacking texinfo (6.7.0.dfsg.2-5) ...
Selecting previously unselected package octave-common.
Preparing to unpack .../258-octave-common_5.2.0-3_all.deb ...
Unpacking octave-common (5.2.0-3) ...
Selecting previously unselected package octave.
Preparing to unpack .../259-octave_5.2.0-3+b1_amd64.deb ...
Unpacking octave (5.2.0-3+b1) ...
Selecting previously unselected package libncurses6:amd64.
Preparing to unpack .../260-libncurses6_6.2+20200918-1_amd64.deb ...
Unpacking libncurses6:amd64 (6.2+20200918-1) ...
Selecting previously unselected package libncursesw6:amd64.
Preparing to unpack .../261-libncursesw6_6.2+20200918-1_amd64.deb ...
Unpacking libncursesw6:amd64 (6.2+20200918-1) ...
Selecting previously unselected package libncurses-dev:amd64.
Preparing to unpack .../262-libncurses-dev_6.2+20200918-1_amd64.deb ...
Unpacking libncurses-dev:amd64 (6.2+20200918-1) ...
Selecting previously unselected package libreadline-dev:amd64.
Preparing to unpack .../263-libreadline-dev_8.0-4_amd64.deb ...
Unpacking libreadline-dev:amd64 (8.0-4) ...
Selecting previously unselected package libhdf5-fortran-102:amd64.
Preparing to unpack .../264-libhdf5-fortran-102_1.10.6+repack-2_amd64.deb ...
Unpacking libhdf5-fortran-102:amd64 (1.10.6+repack-2) ...
Selecting previously unselected package libhdf5-hl-100:amd64.
Preparing to unpack .../265-libhdf5-hl-100_1.10.6+repack-2_amd64.deb ...
Unpacking libhdf5-hl-100:amd64 (1.10.6+repack-2) ...
Selecting previously unselected package libhdf5-hl-fortran-100:amd64.
Preparing to unpack .../266-libhdf5-hl-fortran-100_1.10.6+repack-2_amd64.deb ...
Unpacking libhdf5-hl-fortran-100:amd64 (1.10.6+repack-2) ...
Selecting previously unselected package libhdf5-cpp-103-1:amd64.
Preparing to unpack .../267-libhdf5-cpp-103-1_1.10.6+repack-2_amd64.deb ...
Unpacking libhdf5-cpp-103-1:amd64 (1.10.6+repack-2) ...
Selecting previously unselected package libhdf5-hl-cpp-100:amd64.
Preparing to unpack .../268-libhdf5-hl-cpp-100_1.10.6+repack-2_amd64.deb ...
Unpacking libhdf5-hl-cpp-100:amd64 (1.10.6+repack-2) ...
Selecting previously unselected package zlib1g-dev:amd64.
Preparing to unpack .../269-zlib1g-dev_1%3a1.2.11.dfsg-2_amd64.deb ...
Unpacking zlib1g-dev:amd64 (1:1.2.11.dfsg-2) ...
Selecting previously unselected package libjpeg62-turbo-dev:amd64.
Preparing to unpack .../270-libjpeg62-turbo-dev_1%3a2.0.5-1.1_amd64.deb ...
Unpacking libjpeg62-turbo-dev:amd64 (1:2.0.5-1.1) ...
Selecting previously unselected package libjpeg-dev.
Preparing to unpack .../271-libjpeg-dev_1%3a2.0.5-1.1_all.deb ...
Unpacking libjpeg-dev (1:2.0.5-1.1) ...
Selecting previously unselected package libaec-dev:amd64.
Preparing to unpack .../272-libaec-dev_1.0.4-1_amd64.deb ...
Unpacking libaec-dev:amd64 (1.0.4-1) ...
Selecting previously unselected package hdf5-helpers.
Preparing to unpack .../273-hdf5-helpers_1.10.6+repack-2_amd64.deb ...
Unpacking hdf5-helpers (1.10.6+repack-2) ...
Selecting previously unselected package libhdf5-dev.
Preparing to unpack .../274-libhdf5-dev_1.10.6+repack-2_amd64.deb ...
Unpacking libhdf5-dev (1.10.6+repack-2) ...
Selecting previously unselected package xorg-sgml-doctools.
Preparing to unpack .../275-xorg-sgml-doctools_1%3a1.11-1_all.deb ...
Unpacking xorg-sgml-doctools (1:1.11-1) ...
Selecting previously unselected package x11proto-dev.
Preparing to unpack .../276-x11proto-dev_2020.1-1_all.deb ...
Unpacking x11proto-dev (2020.1-1) ...
Selecting previously unselected package x11proto-core-dev.
Preparing to unpack .../277-x11proto-core-dev_2020.1-1_all.deb ...
Unpacking x11proto-core-dev (2020.1-1) ...
Selecting previously unselected package libxau-dev:amd64.
Preparing to unpack .../278-libxau-dev_1%3a1.0.8-1+b2_amd64.deb ...
Unpacking libxau-dev:amd64 (1:1.0.8-1+b2) ...
Selecting previously unselected package libxdmcp-dev:amd64.
Preparing to unpack .../279-libxdmcp-dev_1%3a1.1.2-3_amd64.deb ...
Unpacking libxdmcp-dev:amd64 (1:1.1.2-3) ...
Selecting previously unselected package xtrans-dev.
Preparing to unpack .../280-xtrans-dev_1.4.0-1_all.deb ...
Unpacking xtrans-dev (1.4.0-1) ...
Selecting previously unselected package libpthread-stubs0-dev:amd64.
Preparing to unpack .../281-libpthread-stubs0-dev_0.4-1_amd64.deb ...
Unpacking libpthread-stubs0-dev:amd64 (0.4-1) ...
Selecting previously unselected package libxcb1-dev:amd64.
Preparing to unpack .../282-libxcb1-dev_1.14-2_amd64.deb ...
Unpacking libxcb1-dev:amd64 (1.14-2) ...
Selecting previously unselected package libx11-dev:amd64.
Preparing to unpack .../283-libx11-dev_2%3a1.6.12-1_amd64.deb ...
Unpacking libx11-dev:amd64 (2:1.6.12-1) ...
Selecting previously unselected package libglx-dev:amd64.
Preparing to unpack .../284-libglx-dev_1.3.2-1_amd64.deb ...
Unpacking libglx-dev:amd64 (1.3.2-1) ...
Selecting previously unselected package libgl-dev:amd64.
Preparing to unpack .../285-libgl-dev_1.3.2-1_amd64.deb ...
Unpacking libgl-dev:amd64 (1.3.2-1) ...
Selecting previously unselected package libegl-dev:amd64.
Preparing to unpack .../286-libegl-dev_1.3.2-1_amd64.deb ...
Unpacking libegl-dev:amd64 (1.3.2-1) ...
Selecting previously unselected package libgles1:amd64.
Preparing to unpack .../287-libgles1_1.3.2-1_amd64.deb ...
Unpacking libgles1:amd64 (1.3.2-1) ...
Selecting previously unselected package libgles2:amd64.
Preparing to unpack .../288-libgles2_1.3.2-1_amd64.deb ...
Unpacking libgles2:amd64 (1.3.2-1) ...
Selecting previously unselected package libgles-dev:amd64.
Preparing to unpack .../289-libgles-dev_1.3.2-1_amd64.deb ...
Unpacking libgles-dev:amd64 (1.3.2-1) ...
Selecting previously unselected package libopengl0:amd64.
Preparing to unpack .../290-libopengl0_1.3.2-1_amd64.deb ...
Unpacking libopengl0:amd64 (1.3.2-1) ...
Selecting previously unselected package libopengl-dev:amd64.
Preparing to unpack .../291-libopengl-dev_1.3.2-1_amd64.deb ...
Unpacking libopengl-dev:amd64 (1.3.2-1) ...
Selecting previously unselected package libglvnd-dev:amd64.
Preparing to unpack .../292-libglvnd-dev_1.3.2-1_amd64.deb ...
Unpacking libglvnd-dev:amd64 (1.3.2-1) ...
Selecting previously unselected package libgl1-mesa-dev:amd64.
Preparing to unpack .../293-libgl1-mesa-dev_20.2.1-1_amd64.deb ...
Unpacking libgl1-mesa-dev:amd64 (20.2.1-1) ...
Selecting previously unselected package libblas-dev:amd64.
Preparing to unpack .../294-libblas-dev_3.9.0-3_amd64.deb ...
Unpacking libblas-dev:amd64 (3.9.0-3) ...
Selecting previously unselected package liblapack-dev:amd64.
Preparing to unpack .../295-liblapack-dev_3.9.0-3_amd64.deb ...
Unpacking liblapack-dev:amd64 (3.9.0-3) ...
Selecting previously unselected package libfftw3-long3:amd64.
Preparing to unpack .../296-libfftw3-long3_3.3.8-2_amd64.deb ...
Unpacking libfftw3-long3:amd64 (3.3.8-2) ...
Selecting previously unselected package libfftw3-quad3:amd64.
Preparing to unpack .../297-libfftw3-quad3_3.3.8-2_amd64.deb ...
Unpacking libfftw3-quad3:amd64 (3.3.8-2) ...
Selecting previously unselected package libfftw3-bin.
Preparing to unpack .../298-libfftw3-bin_3.3.8-2_amd64.deb ...
Unpacking libfftw3-bin (3.3.8-2) ...
Selecting previously unselected package libfftw3-dev:amd64.
Preparing to unpack .../299-libfftw3-dev_3.3.8-2_amd64.deb ...
Unpacking libfftw3-dev:amd64 (3.3.8-2) ...
Selecting previously unselected package libgfortran-10-dev:amd64.
Preparing to unpack .../300-libgfortran-10-dev_10.2.0-15_amd64.deb ...
Unpacking libgfortran-10-dev:amd64 (10.2.0-15) ...
Selecting previously unselected package gfortran-10.
Preparing to unpack .../301-gfortran-10_10.2.0-15_amd64.deb ...
Unpacking gfortran-10 (10.2.0-15) ...
Selecting previously unselected package gfortran.
Preparing to unpack .../302-gfortran_4%3a10.2.0-1_amd64.deb ...
Unpacking gfortran (4:10.2.0-1) ...
Selecting previously unselected package liboctave-dev.
Preparing to unpack .../303-liboctave-dev_5.2.0-3+b1_amd64.deb ...
Unpacking liboctave-dev (5.2.0-3+b1) ...
Selecting previously unselected package libapt-pkg-perl.
Preparing to unpack .../304-libapt-pkg-perl_0.1.36+b3_amd64.deb ...
Unpacking libapt-pkg-perl (0.1.36+b3) ...
Selecting previously unselected package libarray-intspan-perl.
Preparing to unpack .../305-libarray-intspan-perl_2.004-1_all.deb ...
Unpacking libarray-intspan-perl (2.004-1) ...
Selecting previously unselected package libyaml-0-2:amd64.
Preparing to unpack .../306-libyaml-0-2_0.2.2-1_amd64.deb ...
Unpacking libyaml-0-2:amd64 (0.2.2-1) ...
Selecting previously unselected package libyaml-libyaml-perl.
Preparing to unpack .../307-libyaml-libyaml-perl_0.82+repack-1_amd64.deb ...
Unpacking libyaml-libyaml-perl (0.82+repack-1) ...
Selecting previously unselected package libconfig-model-backend-yaml-perl.
Preparing to unpack .../308-libconfig-model-backend-yaml-perl_2.133-2_all.deb ...
Unpacking libconfig-model-backend-yaml-perl (2.133-2) ...
Selecting previously unselected package libexporter-lite-perl.
Preparing to unpack .../309-libexporter-lite-perl_0.08-1_all.deb ...
Unpacking libexporter-lite-perl (0.08-1) ...
Selecting previously unselected package libalgorithm-c3-perl.
Preparing to unpack .../310-libalgorithm-c3-perl_0.10-1_all.deb ...
Unpacking libalgorithm-c3-perl (0.10-1) ...
Selecting previously unselected package libclass-c3-perl.
Preparing to unpack .../311-libclass-c3-perl_0.34-1_all.deb ...
Unpacking libclass-c3-perl (0.34-1) ...
Selecting previously unselected package libmro-compat-perl.
Preparing to unpack .../312-libmro-compat-perl_0.13-1_all.deb ...
Unpacking libmro-compat-perl (0.13-1) ...
Selecting previously unselected package libdata-section-perl.
Preparing to unpack .../313-libdata-section-perl_0.200007-1_all.deb ...
Unpacking libdata-section-perl (0.200007-1) ...
Selecting previously unselected package libtext-template-perl.
Preparing to unpack .../314-libtext-template-perl_1.59-1_all.deb ...
Unpacking libtext-template-perl (1.59-1) ...
Selecting previously unselected package libsoftware-license-perl.
Preparing to unpack .../315-libsoftware-license-perl_0.103014-2_all.deb ...
Unpacking libsoftware-license-perl (0.103014-2) ...
Selecting previously unselected package libyaml-tiny-perl.
Preparing to unpack .../316-libyaml-tiny-perl_1.73-1_all.deb ...
Unpacking libyaml-tiny-perl (1.73-1) ...
Selecting previously unselected package libsoftware-licensemoreutils-perl.
Preparing to unpack .../317-libsoftware-licensemoreutils-perl_1.004-1_all.deb ...
Unpacking libsoftware-licensemoreutils-perl (1.004-1) ...
Selecting previously unselected package libsort-versions-perl.
Preparing to unpack .../318-libsort-versions-perl_1.62-1_all.deb ...
Unpacking libsort-versions-perl (1.62-1) ...
Selecting previously unselected package libtext-reform-perl.
Preparing to unpack .../319-libtext-reform-perl_1.20-3_all.deb ...
Unpacking libtext-reform-perl (1.20-3) ...
Selecting previously unselected package libtext-autoformat-perl.
Preparing to unpack .../320-libtext-autoformat-perl_1.750000-1_all.deb ...
Unpacking libtext-autoformat-perl (1.750000-1) ...
Selecting previously unselected package libtext-levenshtein-damerau-perl.
Preparing to unpack .../321-libtext-levenshtein-damerau-perl_0.41-1_all.deb ...
Unpacking libtext-levenshtein-damerau-perl (0.41-1) ...
Selecting previously unselected package liburi-perl.
Preparing to unpack .../322-liburi-perl_5.05-1_all.deb ...
Unpacking liburi-perl (5.05-1) ...
Selecting previously unselected package libencode-locale-perl.
Preparing to unpack .../323-libencode-locale-perl_1.05-1_all.deb ...
Unpacking libencode-locale-perl (1.05-1) ...
Selecting previously unselected package libtimedate-perl.
Preparing to unpack .../324-libtimedate-perl_2.3300-1_all.deb ...
Unpacking libtimedate-perl (2.3300-1) ...
Selecting previously unselected package libhttp-date-perl.
Preparing to unpack .../325-libhttp-date-perl_6.05-1_all.deb ...
Unpacking libhttp-date-perl (6.05-1) ...
Selecting previously unselected package libfile-listing-perl.
Preparing to unpack .../326-libfile-listing-perl_6.11-1_all.deb ...
Unpacking libfile-listing-perl (6.11-1) ...
Selecting previously unselected package libhtml-tagset-perl.
Preparing to unpack .../327-libhtml-tagset-perl_3.20-4_all.deb ...
Unpacking libhtml-tagset-perl (3.20-4) ...
Selecting previously unselected package libhtml-parser-perl.
Preparing to unpack .../328-libhtml-parser-perl_3.75-1_amd64.deb ...
Unpacking libhtml-parser-perl (3.75-1) ...
Selecting previously unselected package libhtml-tree-perl.
Preparing to unpack .../329-libhtml-tree-perl_5.07-2_all.deb ...
Unpacking libhtml-tree-perl (5.07-2) ...
Selecting previously unselected package libio-html-perl.
Preparing to unpack .../330-libio-html-perl_1.001-1_all.deb ...
Unpacking libio-html-perl (1.001-1) ...
Selecting previously unselected package liblwp-mediatypes-perl.
Preparing to unpack .../331-liblwp-mediatypes-perl_6.04-1_all.deb ...
Unpacking liblwp-mediatypes-perl (6.04-1) ...
Selecting previously unselected package libhttp-message-perl.
Preparing to unpack .../332-libhttp-message-perl_6.26-1_all.deb ...
Unpacking libhttp-message-perl (6.26-1) ...
Selecting previously unselected package libhttp-cookies-perl.
Preparing to unpack .../333-libhttp-cookies-perl_6.08-1_all.deb ...
Unpacking libhttp-cookies-perl (6.08-1) ...
Selecting previously unselected package libhttp-negotiate-perl.
Preparing to unpack .../334-libhttp-negotiate-perl_6.01-1_all.deb ...
Unpacking libhttp-negotiate-perl (6.01-1) ...
Selecting previously unselected package perl-openssl-defaults:amd64.
Preparing to unpack .../335-perl-openssl-defaults_5_amd64.deb ...
Unpacking perl-openssl-defaults:amd64 (5) ...
Selecting previously unselected package libnet-ssleay-perl.
Preparing to unpack .../336-libnet-ssleay-perl_1.88-3_amd64.deb ...
Unpacking libnet-ssleay-perl (1.88-3) ...
Selecting previously unselected package libio-socket-ssl-perl.
Preparing to unpack .../337-libio-socket-ssl-perl_2.068-1_all.deb ...
Unpacking libio-socket-ssl-perl (2.068-1) ...
Selecting previously unselected package libnet-http-perl.
Preparing to unpack .../338-libnet-http-perl_6.19-1_all.deb ...
Unpacking libnet-http-perl (6.19-1) ...
Selecting previously unselected package liblwp-protocol-https-perl.
Preparing to unpack .../339-liblwp-protocol-https-perl_6.09-1_all.deb ...
Unpacking liblwp-protocol-https-perl (6.09-1) ...
Selecting previously unselected package libwww-robotrules-perl.
Preparing to unpack .../340-libwww-robotrules-perl_6.02-1_all.deb ...
Unpacking libwww-robotrules-perl (6.02-1) ...
Selecting previously unselected package libwww-perl.
Preparing to unpack .../341-libwww-perl_6.49-1_all.deb ...
Unpacking libwww-perl (6.49-1) ...
Selecting previously unselected package liblist-someutils-perl.
Preparing to unpack .../342-liblist-someutils-perl_0.58-1_all.deb ...
Unpacking liblist-someutils-perl (0.58-1) ...
Selecting previously unselected package liblog-any-perl.
Preparing to unpack .../343-liblog-any-perl_1.708-1_all.deb ...
Unpacking liblog-any-perl (1.708-1) ...
Selecting previously unselected package liblog-any-adapter-screen-perl.
Preparing to unpack .../344-liblog-any-adapter-screen-perl_0.140-1_all.deb ...
Unpacking liblog-any-adapter-screen-perl (0.140-1) ...
Selecting previously unselected package libclass-method-modifiers-perl.
Preparing to unpack .../345-libclass-method-modifiers-perl_2.13-1_all.deb ...
Unpacking libclass-method-modifiers-perl (2.13-1) ...
Selecting previously unselected package libimport-into-perl.
Preparing to unpack .../346-libimport-into-perl_1.002005-1_all.deb ...
Unpacking libimport-into-perl (1.002005-1) ...
Selecting previously unselected package librole-tiny-perl.
Preparing to unpack .../347-librole-tiny-perl_2.001004-1_all.deb ...
Unpacking librole-tiny-perl (2.001004-1) ...
Selecting previously unselected package libstrictures-perl.
Preparing to unpack .../348-libstrictures-perl_2.000006-1_all.deb ...
Unpacking libstrictures-perl (2.000006-1) ...
Selecting previously unselected package libsub-quote-perl.
Preparing to unpack .../349-libsub-quote-perl_2.006006-1_all.deb ...
Unpacking libsub-quote-perl (2.006006-1) ...
Selecting previously unselected package libmoo-perl.
Preparing to unpack .../350-libmoo-perl_2.004000-1_all.deb ...
Unpacking libmoo-perl (2.004000-1) ...
Selecting previously unselected package libsub-exporter-progressive-perl.
Preparing to unpack .../351-libsub-exporter-progressive-perl_0.001013-1_all.deb ...
Unpacking libsub-exporter-progressive-perl (0.001013-1) ...
Selecting previously unselected package libvariable-magic-perl.
Preparing to unpack .../352-libvariable-magic-perl_0.62-1+b2_amd64.deb ...
Unpacking libvariable-magic-perl (0.62-1+b2) ...
Selecting previously unselected package libb-hooks-endofscope-perl.
Preparing to unpack .../353-libb-hooks-endofscope-perl_0.24-1_all.deb ...
Unpacking libb-hooks-endofscope-perl (0.24-1) ...
Selecting previously unselected package libsub-identify-perl.
Preparing to unpack .../354-libsub-identify-perl_0.14-1+b2_amd64.deb ...
Unpacking libsub-identify-perl (0.14-1+b2) ...
Selecting previously unselected package libsub-name-perl.
Preparing to unpack .../355-libsub-name-perl_0.26-1_amd64.deb ...
Unpacking libsub-name-perl (0.26-1) ...
Selecting previously unselected package libnamespace-clean-perl.
Preparing to unpack .../356-libnamespace-clean-perl_0.27-1_all.deb ...
Unpacking libnamespace-clean-perl (0.27-1) ...
Selecting previously unselected package libnamespace-autoclean-perl.
Preparing to unpack .../357-libnamespace-autoclean-perl_0.29-1_all.deb ...
Unpacking libnamespace-autoclean-perl (0.29-1) ...
Selecting previously unselected package libhash-fieldhash-perl.
Preparing to unpack .../358-libhash-fieldhash-perl_0.15-1+b2_amd64.deb ...
Unpacking libhash-fieldhash-perl (0.15-1+b2) ...
Selecting previously unselected package libobject-id-perl.
Preparing to unpack .../359-libobject-id-perl_0.1.2-2_all.deb ...
Unpacking libobject-id-perl (0.1.2-2) ...
Selecting previously unselected package libtype-tiny-perl.
Preparing to unpack .../360-libtype-tiny-perl_1.010006-1_all.deb ...
Unpacking libtype-tiny-perl (1.010006-1) ...
Selecting previously unselected package libmoox-struct-perl.
Preparing to unpack .../361-libmoox-struct-perl_0.020-1_all.deb ...
Unpacking libmoox-struct-perl (0.020-1) ...
Selecting previously unselected package libnumber-compare-perl.
Preparing to unpack .../362-libnumber-compare-perl_0.03-1_all.deb ...
Unpacking libnumber-compare-perl (0.03-1) ...
Selecting previously unselected package libtext-glob-perl.
Preparing to unpack .../363-libtext-glob-perl_0.11-1_all.deb ...
Unpacking libtext-glob-perl (0.11-1) ...
Selecting previously unselected package libpath-iterator-rule-perl.
Preparing to unpack .../364-libpath-iterator-rule-perl_1.014-1_all.deb ...
Unpacking libpath-iterator-rule-perl (1.014-1) ...
Selecting previously unselected package libpod-constants-perl.
Preparing to unpack .../365-libpod-constants-perl_0.19-2_all.deb ...
Unpacking libpod-constants-perl (0.19-2) ...
Selecting previously unselected package libre2-8:amd64.
Preparing to unpack .../366-libre2-8_20201001+dfsg-1_amd64.deb ...
Unpacking libre2-8:amd64 (20201001+dfsg-1) ...
Selecting previously unselected package libre-engine-re2-perl.
Preparing to unpack .../367-libre-engine-re2-perl_0.13-5+b3_amd64.deb ...
Unpacking libre-engine-re2-perl (0.13-5+b3) ...
Selecting previously unselected package libregexp-pattern-license-perl.
Preparing to unpack .../368-libregexp-pattern-license-perl_3.4.0-1_all.deb ...
Unpacking libregexp-pattern-license-perl (3.4.0-1) ...
Selecting previously unselected package libregexp-pattern-perl.
Preparing to unpack .../369-libregexp-pattern-perl_0.2.14-1_all.deb ...
Unpacking libregexp-pattern-perl (0.2.14-1) ...
Selecting previously unselected package libsort-key-perl.
Preparing to unpack .../370-libsort-key-perl_1.33-2+b2_amd64.deb ...
Unpacking libsort-key-perl (1.33-2+b2) ...
Selecting previously unselected package libnumber-range-perl.
Preparing to unpack .../371-libnumber-range-perl_0.12-1_all.deb ...
Unpacking libnumber-range-perl (0.12-1) ...
Selecting previously unselected package libstring-copyright-perl.
Preparing to unpack .../372-libstring-copyright-perl_0.003006-1_all.deb ...
Unpacking libstring-copyright-perl (0.003006-1) ...
Selecting previously unselected package libstring-escape-perl.
Preparing to unpack .../373-libstring-escape-perl_2010.002-2_all.deb ...
Unpacking libstring-escape-perl (2010.002-2) ...
Selecting previously unselected package licensecheck.
Preparing to unpack .../374-licensecheck_3.0.47-1_all.deb ...
Unpacking licensecheck (3.0.47-1) ...
Selecting previously unselected package diffstat.
Preparing to unpack .../375-diffstat_1.63-1_amd64.deb ...
Unpacking diffstat (1.63-1) ...
Selecting previously unselected package libassuan0:amd64.
Preparing to unpack .../376-libassuan0_2.5.3-7.1_amd64.deb ...
Unpacking libassuan0:amd64 (2.5.3-7.1) ...
Selecting previously unselected package gpgconf.
Preparing to unpack .../377-gpgconf_2.2.20-1_amd64.deb ...
Unpacking gpgconf (2.2.20-1) ...
Selecting previously unselected package libsqlite3-0:amd64.
Preparing to unpack .../378-libsqlite3-0_3.33.0-1_amd64.deb ...
Unpacking libsqlite3-0:amd64 (3.33.0-1) ...
Selecting previously unselected package gpg.
Preparing to unpack .../379-gpg_2.2.20-1_amd64.deb ...
Unpacking gpg (2.2.20-1) ...
Selecting previously unselected package libclass-xsaccessor-perl.
Preparing to unpack .../380-libclass-xsaccessor-perl_1.19-3+b5_amd64.deb ...
Unpacking libclass-xsaccessor-perl (1.19-3+b5) ...
Selecting previously unselected package libclone-perl.
Preparing to unpack .../381-libclone-perl_0.45-1_amd64.deb ...
Unpacking libclone-perl (0.45-1) ...
Selecting previously unselected package libconfig-tiny-perl.
Preparing to unpack .../382-libconfig-tiny-perl_2.24-1_all.deb ...
Unpacking libconfig-tiny-perl (2.24-1) ...
Selecting previously unselected package libcpanel-json-xs-perl.
Preparing to unpack .../383-libcpanel-json-xs-perl_4.24-1_amd64.deb ...
Unpacking libcpanel-json-xs-perl (4.24-1) ...
Selecting previously unselected package libaliased-perl.
Preparing to unpack .../384-libaliased-perl_0.34-1_all.deb ...
Unpacking libaliased-perl (0.34-1) ...
Selecting previously unselected package libclass-data-inheritable-perl.
Preparing to unpack .../385-libclass-data-inheritable-perl_0.08-3_all.deb ...
Unpacking libclass-data-inheritable-perl (0.08-3) ...
Selecting previously unselected package libdevel-stacktrace-perl.
Preparing to unpack .../386-libdevel-stacktrace-perl_2.0400-1_all.deb ...
Unpacking libdevel-stacktrace-perl (2.0400-1) ...
Selecting previously unselected package libexception-class-perl.
Preparing to unpack .../387-libexception-class-perl_1.44-1_all.deb ...
Unpacking libexception-class-perl (1.44-1) ...
Selecting previously unselected package libiterator-perl.
Preparing to unpack .../388-libiterator-perl_0.03+ds1-1_all.deb ...
Unpacking libiterator-perl (0.03+ds1-1) ...
Selecting previously unselected package libiterator-util-perl.
Preparing to unpack .../389-libiterator-util-perl_0.02+ds1-1_all.deb ...
Unpacking libiterator-util-perl (0.02+ds1-1) ...
Selecting previously unselected package libdata-dpath-perl.
Preparing to unpack .../390-libdata-dpath-perl_0.58-1_all.deb ...
Unpacking libdata-dpath-perl (0.58-1) ...
Selecting previously unselected package libnet-domain-tld-perl.
Preparing to unpack .../391-libnet-domain-tld-perl_1.75-1_all.deb ...
Unpacking libnet-domain-tld-perl (1.75-1) ...
Selecting previously unselected package libdata-validate-domain-perl.
Preparing to unpack .../392-libdata-validate-domain-perl_0.10-1_all.deb ...
Unpacking libdata-validate-domain-perl (0.10-1) ...
Selecting previously unselected package libdevel-size-perl.
Preparing to unpack .../393-libdevel-size-perl_0.83-1+b1_amd64.deb ...
Unpacking libdevel-size-perl (0.83-1+b1) ...
Selecting previously unselected package libemail-address-xs-perl.
Preparing to unpack .../394-libemail-address-xs-perl_1.04-1+b2_amd64.deb ...
Unpacking libemail-address-xs-perl (1.04-1+b2) ...
Selecting previously unselected package libipc-system-simple-perl.
Preparing to unpack .../395-libipc-system-simple-perl_1.30-1_all.deb ...
Unpacking libipc-system-simple-perl (1.30-1) ...
Selecting previously unselected package libfile-basedir-perl.
Preparing to unpack .../396-libfile-basedir-perl_0.08-1_all.deb ...
Unpacking libfile-basedir-perl (0.08-1) ...
Selecting previously unselected package libfile-find-rule-perl.
Preparing to unpack .../397-libfile-find-rule-perl_0.34-1_all.deb ...
Unpacking libfile-find-rule-perl (0.34-1) ...
Selecting previously unselected package libio-string-perl.
Preparing to unpack .../398-libio-string-perl_1.08-3_all.deb ...
Unpacking libio-string-perl (1.08-3) ...
Selecting previously unselected package libfont-ttf-perl.
Preparing to unpack .../399-libfont-ttf-perl_1.06-1_all.deb ...
Unpacking libfont-ttf-perl (1.06-1) ...
Selecting previously unselected package libhtml-html5-entities-perl.
Preparing to unpack .../400-libhtml-html5-entities-perl_0.004-1_all.deb ...
Unpacking libhtml-html5-entities-perl (0.004-1) ...
Selecting previously unselected package libipc-run3-perl.
Preparing to unpack .../401-libipc-run3-perl_0.048-2_all.deb ...
Unpacking libipc-run3-perl (0.048-2) ...
Selecting previously unselected package libjson-maybexs-perl.
Preparing to unpack .../402-libjson-maybexs-perl_1.004002-1_all.deb ...
Unpacking libjson-maybexs-perl (1.004002-1) ...
Selecting previously unselected package liblist-compare-perl.
Preparing to unpack .../403-liblist-compare-perl_0.55-1_all.deb ...
Unpacking liblist-compare-perl (0.55-1) ...
Selecting previously unselected package liblist-utilsby-perl.
Preparing to unpack .../404-liblist-utilsby-perl_0.11-1_all.deb ...
Unpacking liblist-utilsby-perl (0.11-1) ...
Selecting previously unselected package libmoox-aliases-perl.
Preparing to unpack .../405-libmoox-aliases-perl_0.001006-1_all.deb ...
Unpacking libmoox-aliases-perl (0.001006-1) ...
Selecting previously unselected package libperlio-gzip-perl.
Preparing to unpack .../406-libperlio-gzip-perl_0.19-1+b6_amd64.deb ...
Unpacking libperlio-gzip-perl (0.19-1+b6) ...
Selecting previously unselected package libproc-processtable-perl.
Preparing to unpack .../407-libproc-processtable-perl_0.59-2_amd64.deb ...
Unpacking libproc-processtable-perl (0.59-2) ...
Selecting previously unselected package libsereal-decoder-perl.
Preparing to unpack .../408-libsereal-decoder-perl_4.018+ds-1_amd64.deb ...
Unpacking libsereal-decoder-perl (4.018+ds-1) ...
Selecting previously unselected package libsereal-encoder-perl.
Preparing to unpack .../409-libsereal-encoder-perl_4.018+ds-1_amd64.deb ...
Unpacking libsereal-encoder-perl (4.018+ds-1) ...
Selecting previously unselected package libtext-levenshteinxs-perl.
Preparing to unpack .../410-libtext-levenshteinxs-perl_0.03-4+b7_amd64.deb ...
Unpacking libtext-levenshteinxs-perl (0.03-4+b7) ...
Selecting previously unselected package libmarkdown2:amd64.
Preparing to unpack .../411-libmarkdown2_2.2.6-1_amd64.deb ...
Unpacking libmarkdown2:amd64 (2.2.6-1) ...
Selecting previously unselected package libtext-markdown-discount-perl:amd64.
Preparing to unpack .../412-libtext-markdown-discount-perl_0.12-1_amd64.deb ...
Unpacking libtext-markdown-discount-perl:amd64 (0.12-1) ...
Selecting previously unselected package libdata-messagepack-perl.
Preparing to unpack .../413-libdata-messagepack-perl_1.00-4_amd64.deb ...
Unpacking libdata-messagepack-perl (1.00-4) ...
Selecting previously unselected package libtext-xslate-perl.
Preparing to unpack .../414-libtext-xslate-perl_3.5.8-1_amd64.deb ...
Unpacking libtext-xslate-perl (3.5.8-1) ...
Selecting previously unselected package libtime-duration-perl.
Preparing to unpack .../415-libtime-duration-perl_1.21-1_all.deb ...
Unpacking libtime-duration-perl (1.21-1) ...
Selecting previously unselected package libtime-moment-perl.
Preparing to unpack .../416-libtime-moment-perl_0.44-1+b2_amd64.deb ...
Unpacking libtime-moment-perl (0.44-1+b2) ...
Selecting previously unselected package libunicode-utf8-perl.
Preparing to unpack .../417-libunicode-utf8-perl_0.62-1+b1_amd64.deb ...
Unpacking libunicode-utf8-perl (0.62-1+b1) ...
Selecting previously unselected package lzip.
Preparing to unpack .../418-lzip_1.21-8_amd64.deb ...
Unpacking lzip (1.21-8) ...
Selecting previously unselected package liblzo2-2:amd64.
Preparing to unpack .../419-liblzo2-2_2.10-2_amd64.deb ...
Unpacking liblzo2-2:amd64 (2.10-2) ...
Selecting previously unselected package lzop.
Preparing to unpack .../420-lzop_1.04-1_amd64.deb ...
Unpacking lzop (1.04-1) ...
Selecting previously unselected package patchutils.
Preparing to unpack .../421-patchutils_0.4.2-1_amd64.deb ...
Unpacking patchutils (0.4.2-1) ...
Selecting previously unselected package t1utils.
Preparing to unpack .../422-t1utils_1.41-4_amd64.deb ...
Unpacking t1utils (1.41-4) ...
Selecting previously unselected package unzip.
Preparing to unpack .../423-unzip_6.0-25_amd64.deb ...
Unpacking unzip (6.0-25) ...
Selecting previously unselected package lintian.
Preparing to unpack .../424-lintian_2.99.0_all.deb ...
Unpacking lintian (2.99.0) ...
Selecting previously unselected package libconfig-model-dpkg-perl.
Preparing to unpack .../425-libconfig-model-dpkg-perl_2.139_all.deb ...
Unpacking libconfig-model-dpkg-perl (2.139) ...
Selecting previously unselected package liberror-perl.
Preparing to unpack .../426-liberror-perl_0.17029-1_all.deb ...
Unpacking liberror-perl (0.17029-1) ...
Selecting previously unselected package libparse-debcontrol-perl.
Preparing to unpack .../427-libparse-debcontrol-perl_2.005-4_all.deb ...
Unpacking libparse-debcontrol-perl (2.005-4) ...
Selecting previously unselected package libconvert-binhex-perl.
Preparing to unpack .../428-libconvert-binhex-perl_1.125-1_all.deb ...
Unpacking libconvert-binhex-perl (1.125-1) ...
Selecting previously unselected package libnet-smtp-ssl-perl.
Preparing to unpack .../429-libnet-smtp-ssl-perl_1.04-1_all.deb ...
Unpacking libnet-smtp-ssl-perl (1.04-1) ...
Selecting previously unselected package libmailtools-perl.
Preparing to unpack .../430-libmailtools-perl_2.21-1_all.deb ...
Unpacking libmailtools-perl (2.21-1) ...
Selecting previously unselected package libmime-tools-perl.
Preparing to unpack .../431-libmime-tools-perl_5.509-1_all.deb ...
Unpacking libmime-tools-perl (5.509-1) ...
Selecting previously unselected package gnuplot-data.
Preparing to unpack .../432-gnuplot-data_5.4.0+dfsg1-1_all.deb ...
Unpacking gnuplot-data (5.4.0+dfsg1-1) ...
Selecting previously unselected package libpixman-1-0:amd64.
Preparing to unpack .../433-libpixman-1-0_0.36.0-1_amd64.deb ...
Unpacking libpixman-1-0:amd64 (0.36.0-1) ...
Selecting previously unselected package libcairo2:amd64.
Preparing to unpack .../434-libcairo2_1.16.0-4_amd64.deb ...
Unpacking libcairo2:amd64 (1.16.0-4) ...
Selecting previously unselected package libxpm4:amd64.
Preparing to unpack .../435-libxpm4_1%3a3.5.12-1_amd64.deb ...
Unpacking libxpm4:amd64 (1:3.5.12-1) ...
Selecting previously unselected package libgd3:amd64.
Preparing to unpack .../436-libgd3_2.3.0-2_amd64.deb ...
Unpacking libgd3:amd64 (2.3.0-2) ...
Selecting previously unselected package liblua5.4-0:amd64.
Preparing to unpack .../437-liblua5.4-0_5.4.0-2_amd64.deb ...
Unpacking liblua5.4-0:amd64 (5.4.0-2) ...
Selecting previously unselected package libfribidi0:amd64.
Preparing to unpack .../438-libfribidi0_1.0.8-2_amd64.deb ...
Unpacking libfribidi0:amd64 (1.0.8-2) ...
Selecting previously unselected package libthai-data.
Preparing to unpack .../439-libthai-data_0.1.28-3_all.deb ...
Unpacking libthai-data (0.1.28-3) ...
Selecting previously unselected package libdatrie1:amd64.
Preparing to unpack .../440-libdatrie1_0.2.12-3_amd64.deb ...
Unpacking libdatrie1:amd64 (0.2.12-3) ...
Selecting previously unselected package libthai0:amd64.
Preparing to unpack .../441-libthai0_0.1.28-3_amd64.deb ...
Unpacking libthai0:amd64 (0.1.28-3) ...
Selecting previously unselected package libpango-1.0-0:amd64.
Preparing to unpack .../442-libpango-1.0-0_1.46.2-1_amd64.deb ...
Unpacking libpango-1.0-0:amd64 (1.46.2-1) ...
Selecting previously unselected package libpangoft2-1.0-0:amd64.
Preparing to unpack .../443-libpangoft2-1.0-0_1.46.2-1_amd64.deb ...
Unpacking libpangoft2-1.0-0:amd64 (1.46.2-1) ...
Selecting previously unselected package libpangocairo-1.0-0:amd64.
Preparing to unpack .../444-libpangocairo-1.0-0_1.46.2-1_amd64.deb ...
Unpacking libpangocairo-1.0-0:amd64 (1.46.2-1) ...
Selecting previously unselected package gnuplot-nox.
Preparing to unpack .../445-gnuplot-nox_5.4.0+dfsg1-1_amd64.deb ...
Unpacking gnuplot-nox (5.4.0+dfsg1-1) ...
Selecting previously unselected package dh-octave-autopkgtest.
Preparing to unpack .../446-dh-octave-autopkgtest_1.0.1_all.deb ...
Unpacking dh-octave-autopkgtest (1.0.1) ...
Selecting previously unselected package dh-octave.
Preparing to unpack .../447-dh-octave_1.0.1_all.deb ...
Unpacking dh-octave (1.0.1) ...
Selecting previously unselected package libgs9-common.
Preparing to unpack .../448-libgs9-common_9.53.3~dfsg-5_all.deb ...
Unpacking libgs9-common (9.53.3~dfsg-5) ...
Selecting previously unselected package libidn11:amd64.
Preparing to unpack .../449-libidn11_1.33-2.4_amd64.deb ...
Unpacking libidn11:amd64 (1.33-2.4) ...
Selecting previously unselected package libijs-0.35:amd64.
Preparing to unpack .../450-libijs-0.35_0.35-15_amd64.deb ...
Unpacking libijs-0.35:amd64 (0.35-15) ...
Selecting previously unselected package libjbig2dec0:amd64.
Preparing to unpack .../451-libjbig2dec0_0.19-1_amd64.deb ...
Unpacking libjbig2dec0:amd64 (0.19-1) ...
Selecting previously unselected package libpaper1:amd64.
Preparing to unpack .../452-libpaper1_1.1.28+b1_amd64.deb ...
Unpacking libpaper1:amd64 (1.1.28+b1) ...
Selecting previously unselected package libgs9:amd64.
Preparing to unpack .../453-libgs9_9.53.3~dfsg-5_amd64.deb ...
Unpacking libgs9:amd64 (9.53.3~dfsg-5) ...
Selecting previously unselected package ghostscript.
Preparing to unpack .../454-ghostscript_9.53.3~dfsg-5_amd64.deb ...
Unpacking ghostscript (9.53.3~dfsg-5) ...
Selecting previously unselected package hicolor-icon-theme.
Preparing to unpack .../455-hicolor-icon-theme_0.17-2_all.deb ...
Unpacking hicolor-icon-theme (0.17-2) ...
Selecting previously unselected package imagemagick-6.q16.
Preparing to unpack .../456-imagemagick-6.q16_8%3a6.9.11.24+dfsg-1+b1_amd64.deb ...
Unpacking imagemagick-6.q16 (8:6.9.11.24+dfsg-1+b1) ...
Selecting previously unselected package imagemagick.
Preparing to unpack .../457-imagemagick_8%3a6.9.11.24+dfsg-1+b1_amd64.deb ...
Unpacking imagemagick (8:6.9.11.24+dfsg-1+b1) ...
Selecting previously unselected package libgmpxx4ldbl:amd64.
Preparing to unpack .../458-libgmpxx4ldbl_2%3a6.2.0+dfsg-6_amd64.deb ...
Unpacking libgmpxx4ldbl:amd64 (2:6.2.0+dfsg-6) ...
Selecting previously unselected package libgmp-dev:amd64.
Preparing to unpack .../459-libgmp-dev_2%3a6.2.0+dfsg-6_amd64.deb ...
Unpacking libgmp-dev:amd64 (2:6.2.0+dfsg-6) ...
Selecting previously unselected package libmpfr-dev:amd64.
Preparing to unpack .../460-libmpfr-dev_4.1.0-3_amd64.deb ...
Unpacking libmpfr-dev:amd64 (4.1.0-3) ...
Selecting previously unselected package sbuild-build-depends-main-dummy.
Preparing to unpack .../461-sbuild-build-depends-main-dummy_0.invalid.0_amd64.deb ...
Unpacking sbuild-build-depends-main-dummy (0.invalid.0) ...
Setting up libre2-8:amd64 (20201001+dfsg-1) ...
Setting up libapt-pkg-perl (0.1.36+b3) ...
Setting up libexpat1:amd64 (2.2.10-1) ...
Setting up libmodule-pluggable-perl (5.2-1) ...
Setting up libpipeline1:amd64 (1.5.3-1) ...
Setting up libgraphite2-3:amd64 (1.3.14-1) ...
Setting up libstring-escape-perl (2010.002-2) ...
Setting up liblcms2-2:amd64 (2.9-4+b1) ...
Setting up libpixman-1-0:amd64 (0.36.0-1) ...
Setting up libwayland-server0:amd64 (1.18.0-2~exp1.1) ...
Setting up libx11-xcb1:amd64 (2:1.6.12-1) ...
Setting up libpciaccess0:amd64 (0.16-1) ...
Setting up libfile-which-perl (1.23-1) ...
Setting up libxau6:amd64 (1:1.0.8-1+b2) ...
Setting up imagemagick-6-common (8:6.9.11.24+dfsg-1) ...
Setting up libxdmcp6:amd64 (1:1.1.2-3) ...
Setting up libdouble-conversion3:amd64 (3.1.5-6) ...
Setting up libpsl5:amd64 (0.21.0-1.1) ...
Setting up libxcb1:amd64 (1.14-2) ...
Setting up libnumber-range-perl (0.12-1) ...
Setting up libunicode-utf8-perl (0.62-1+b1) ...
Setting up libfftw3-single3:amd64 (3.3.8-2) ...
Setting up libxcb-xfixes0:amd64 (1.14-2) ...
Setting up libogg0:amd64 (1.3.2-1+b1) ...
Setting up libmouse-perl (2.5.10-1) ...
Setting up libpod-pom-perl (2.01-3) ...
Setting up bsdextrautils (2.36-3+b1) ...
update-alternatives: using /usr/bin/write.ul to provide /usr/bin/write (write) in auto mode
Setting up hdf5-helpers (1.10.6+repack-2) ...
Setting up hicolor-icon-theme (0.17-2) ...
Setting up libregexp-pattern-perl (0.2.14-1) ...
Setting up libdata-messagepack-perl (1.00-4) ...
Setting up libxcb-xinput0:amd64 (1.14-2) ...
Setting up libicu67:amd64 (67.1-4) ...
Setting up libdynaloader-functions-perl (0.003-1) ...
Setting up libdatrie1:amd64 (0.2.12-3) ...
Setting up libtext-glob-perl (0.11-1) ...
Setting up libclass-method-modifiers-perl (2.13-1) ...
Setting up liblist-compare-perl (0.55-1) ...
Setting up libmagic-mgc (1:5.38-5) ...
Setting up libqhull8.0:amd64 (2020.1-2) ...
Setting up libxcb-render0:amd64 (1.14-2) ...
Setting up libsort-key-perl (1.33-2+b2) ...
Setting up libclone-perl (0.45-1) ...
Setting up libarchive-zip-perl (1.68-1) ...
Setting up libyaml-0-2:amd64 (0.2.2-1) ...
Setting up libsub-identify-perl (0.14-1+b2) ...
Setting up libglib2.0-0:amd64 (2.66.1-2) ...
No schema files found: doing nothing.
Setting up libcpanel-json-xs-perl (4.24-1) ...
Setting up libglvnd0:amd64 (1.3.2-1) ...
Setting up libio-stringy-perl (2.111-3) ...
Setting up libhtml-tagset-perl (3.20-4) ...
Setting up liblog-any-perl (1.708-1) ...
Setting up libqscintilla2-qt5-l10n (2.11.5+dfsg-3) ...
Setting up libijs-0.35:amd64 (0.35-15) ...
Setting up libxcb-glx0:amd64 (1.14-2) ...
Setting up libdevel-size-perl (0.83-1+b1) ...
Setting up unzip (6.0-25) ...
Setting up libaom0:amd64 (1.0.0.errata1-3) ...
Setting up libdebhelper-perl (13.2.1) ...
Setting up libbrotli1:amd64 (1.0.9-2+b1) ...
Setting up libpod-constants-perl (0.19-2) ...
Setting up libsqlite3-0:amd64 (3.33.0-1) ...
Setting up libconvert-binhex-perl (1.125-1) ...
Setting up liblwp-mediatypes-perl (6.04-1) ...
Setting up libyaml-libyaml-perl (0.82+repack-1) ...
Setting up fonts-freefont-otf (20120503-10) ...
Setting up libxcb-keysyms1:amd64 (0.4.0-1+b2) ...
Setting up libxcb-shape0:amd64 (1.14-2) ...
Setting up x11-common (1:7.7+21) ...
invoke-rc.d: could not determine current runlevel
All runlevel operations denied by policy
invoke-rc.d: policy-rc.d denied execution of start.
Setting up libtry-tiny-perl (0.30-1) ...
Setting up libsensors-config (1:3.6.0-2) ...
Setting up libnghttp2-14:amd64 (1.41.0-3) ...
Setting up libmagic1:amd64 (1:5.38-5) ...
Setting up perl-openssl-defaults:amd64 (5) ...
Setting up libxml-namespacesupport-perl (1.12-1) ...
Setting up libfftw3-long3:amd64 (3.3.8-2) ...
Setting up gettext-base (0.19.8.1-10) ...
Setting up libclone-choose-perl (0.010-1) ...
Setting up libxcb-render-util0:amd64 (0.3.9-1+b1) ...
Setting up xkb-data (2.29-2) ...
Setting up liblzo2-2:amd64 (2.10-2) ...
Setting up libtime-moment-perl (0.44-1+b2) ...
Setting up libencode-locale-perl (1.05-1) ...
Setting up libmetis5:amd64 (5.1.0.dfsg-7) ...
Setting up libxcb-shm0:amd64 (1.14-2) ...
Setting up libxcb-icccm4:amd64 (0.4.1-1.1) ...
Setting up file (1:5.38-5) ...
Setting up fonts-urw-base35 (20200910-1) ...
Setting up libxcb-util0:amd64 (0.3.8-3+b2) ...
Setting up libassuan0:amd64 (2.5.3-7.1) ...
Setting up libconfig-tiny-perl (2.24-1) ...
Setting up libsereal-encoder-perl (4.018+ds-1) ...
Setting up libyaml-perl (1.30-1) ...
Setting up liblist-utilsby-perl (0.11-1) ...
Setting up libyaml-tiny-perl (1.73-1) ...
Setting up libpthread-stubs0-dev:amd64 (0.4-1) ...
Setting up libjbig0:amd64 (2.1-3.1+b2) ...
Setting up octave-common (5.2.0-3) ...
Setting up libregexp-common-perl (2017060201-1) ...
Setting up libpcre2-16-0:amd64 (10.34-7) ...
Setting up libaec0:amd64 (1.0.4-1) ...
Setting up libopengl0:amd64 (1.3.2-1) ...
Setting up libsub-install-perl (0.928-1) ...
Setting up libflac8:amd64 (1.3.3-1) ...
Setting up poppler-data (0.4.9-2) ...
Setting up libxcb-xkb1:amd64 (1.14-2) ...
Setting up libxcb-image0:amd64 (0.4.0-1+b2) ...
Setting up libnumber-compare-perl (0.03-1) ...
Setting up libsasl2-modules-db:amd64 (2.1.27+dfsg-2) ...
Setting up libxcb-present0:amd64 (1.14-2) ...
Setting up liberror-perl (0.17029-1) ...
Setting up libasound2-data (1.2.3.2-1) ...
Setting up libjson-maybexs-perl (1.004002-1) ...
Setting up libxml-sax-base-perl (1.09-1) ...
Setting up libio-string-perl (1.08-3) ...
Setting up libboolean-perl (0.46-1) ...
Setting up xtrans-dev (1.4.0-1) ...
Setting up autotools-dev (20180224.1) ...
Setting up libblas3:amd64 (3.9.0-3) ...
update-alternatives: using /usr/lib/x86_64-linux-gnu/blas/libblas.so.3 to provide /usr/lib/x86_64-linux-gnu/libblas.so.3 (libblas.so.3-x86_64-linux-gnu) in auto mode
Setting up libclass-data-inheritable-perl (0.08-3) ...
Setting up libxcb-xinerama0:amd64 (1.14-2) ...
Setting up libgmpxx4ldbl:amd64 (2:6.2.0+dfsg-6) ...
Setting up libalgorithm-c3-perl (0.10-1) ...
Setting up libllvm11:amd64 (1:11.0.0-3) ...
Setting up libgles2:amd64 (1.3.2-1) ...
Setting up liblog-log4perl-perl (1.53-1) ...
Setting up libtext-reform-perl (1.20-3) ...
Setting up libjpeg62-turbo:amd64 (1:2.0.5-1.1) ...
Setting up libx11-data (2:1.6.12-1) ...
Setting up libjpeg62-turbo-dev:amd64 (1:2.0.5-1.1) ...
Setting up libfile-find-rule-perl (0.34-1) ...
Setting up libxcb-sync1:amd64 (1.14-2) ...
Setting up libjbig2dec0:amd64 (0.19-1) ...
Setting up librtmp1:amd64 (2.4+20151223.gitfa8646d.1-2+b2) ...
Setting up libipc-system-simple-perl (1.30-1) ...
Setting up libidn11:amd64 (1.33-2.4) ...
Setting up libio-tiecombine-perl (1.005-1) ...
Setting up libnet-domain-tld-perl (1.75-1) ...
Setting up aglfn (1.7+git20191031.4036a9c-2) ...
Setting up lzip (1.21-8) ...
Setting up libavahi-common-data:amd64 (0.8-3) ...
Setting up libncurses6:amd64 (6.2+20200918-1) ...
Setting up libgles1:amd64 (1.3.2-1) ...
Setting up libhash-fieldhash-perl (0.15-1+b2) ...
Setting up libdbus-1-3:amd64 (1.12.20-1) ...
Setting up libsigsegv2:amd64 (2.12-2) ...
Setting up libfftw3-quad3:amd64 (3.3.8-2) ...
Setting up libfribidi0:amd64 (1.0.8-2) ...
Setting up t1utils (1.41-4) ...
Setting up diffstat (1.63-1) ...
Setting up libpng16-16:amd64 (1.6.37-3) ...
Setting up libvorbis0a:amd64 (1.3.7-1) ...
Setting up libvariable-magic-perl (0.62-1+b2) ...
Setting up libio-html-perl (1.001-1) ...
Setting up libtext-template-perl (1.59-1) ...
Setting up autopoint (0.19.8.1-10) ...
Setting up libwebp6:amd64 (0.6.1-2+b1) ...
Setting up libb-hooks-op-check-perl (0.22-1+b2) ...
Setting up fonts-dejavu-core (2.37-2) ...
Setting up libsensors5:amd64 (1:3.6.0-2) ...
Setting up libncursesw6:amd64 (6.2+20200918-1) ...
Setting up libltdl7:amd64 (2.4.6-14) ...
Setting up libfftw3-double3:amd64 (3.3.8-2) ...
Setting up libglapi-mesa:amd64 (20.2.1-1) ...
Setting up libparams-util-perl (1.101-1) ...
Setting up libsasl2-2:amd64 (2.1.27+dfsg-2) ...
Setting up libgfortran5:amd64 (10.2.0-15) ...
Setting up libmtdev1:amd64 (1.1.6-1) ...
Setting up libvulkan1:amd64 (1.2.154.1-1) ...
Setting up libtime-duration-perl (1.21-1) ...
Setting up libtext-xslate-perl (3.5.8-1) ...
Setting up libsub-exporter-progressive-perl (0.001013-1) ...
Setting up libarray-intspan-perl (2.004-1) ...
Setting up libcapture-tiny-perl (0.48-1) ...
Setting up libtimedate-perl (2.3300-1) ...
Setting up libexporter-lite-perl (0.08-1) ...
Setting up libxcb-dri2-0:amd64 (1.14-2) ...
Setting up libsub-name-perl (0.26-1) ...
Setting up zlib1g-dev:amd64 (1:1.2.11.dfsg-2) ...
Setting up libnuma1:amd64 (2.0.12-1+b1) ...
Setting up libdata-validate-domain-perl (0.10-1) ...
Setting up libproc-processtable-perl (0.59-2) ...
Setting up libparse-recdescent-perl (1.967015+dfsg-2) ...
Setting up liblqr-1-0:amd64 (0.4.2-2.1) ...
Setting up sensible-utils (0.0.12+nmu1) ...
Setting up libxshmfence1:amd64 (1.3-1) ...
Setting up libxcb-randr0:amd64 (1.14-2) ...
Setting up libpath-tiny-perl (0.114-1) ...
Setting up libuchardet0:amd64 (0.0.7-1) ...
Setting up lzop (1.04-1) ...
Setting up libjson-perl (4.02000-2) ...
Setting up libasound2:amd64 (1.2.3.2-1) ...
Setting up liblog-any-adapter-screen-perl (0.140-1) ...
Setting up librole-tiny-perl (2.001004-1) ...
Setting up libipc-run3-perl (0.048-2) ...
Setting up libmd4c0:amd64 (0.4.6-1) ...
Setting up libmousex-strictconstructor-perl (0.02-2) ...
Setting up libsub-uplevel-perl (0.2800-1) ...
Setting up libdav1d4:amd64 (0.7.1-3) ...
Setting up liblua5.4-0:amd64 (5.4.0-2) ...
Setting up libopenjp2-7:amd64 (2.3.1-1) ...
Setting up libsub-override-perl (0.09-2) ...
Setting up libx11-6:amd64 (2:1.6.12-1) ...
Setting up libaliased-perl (0.34-1) ...
Setting up libthai-data (0.1.28-3) ...
Setting up libgfortran-10-dev:amd64 (10.2.0-15) ...
Setting up libssh2-1:amd64 (1.8.0-2.1) ...
Setting up xorg-sgml-doctools (1:1.11-1) ...
Setting up netbase (6.2) ...
Setting up libstrictures-perl (2.000006-1) ...
Setting up libsub-quote-perl (2.006006-1) ...
Setting up libdevel-stacktrace-perl (2.0400-1) ...
Setting up libclass-xsaccessor-perl (1.19-3+b5) ...
Setting up libcxsparse3:amd64 (1:5.8.1+dfsg-2) ...
Setting up libtext-autoformat-perl (1.750000-1) ...
Setting up libtiff5:amd64 (4.1.0+git191117-2) ...
Setting up libsort-versions-perl (1.62-1) ...
Setting up libopengl-dev:amd64 (1.3.2-1) ...
Setting up libexporter-tiny-perl (1.002002-1) ...
Setting up libre-engine-re2-perl (0.13-5+b3) ...
Setting up libtext-unidecode-perl (1.30-1) ...
Setting up libde265-0:amd64 (1.0.7-1) ...
Setting up libfont-ttf-perl (1.06-1) ...
Setting up libfile-homedir-perl (1.006-1) ...
Setting up libsamplerate0:amd64 (0.1.9-2) ...
Setting up openssl (1.1.1h-1) ...
Setting up libwebpmux3:amd64 (0.6.1-2+b1) ...
Setting up libtext-levenshteinxs-perl (0.03-4+b7) ...
Setting up libperlio-gzip-perl (0.19-1+b6) ...
Setting up libdrm-common (2.4.102-1) ...
Setting up libelf1:amd64 (0.181-1) ...
Setting up libevdev2:amd64 (1.9.1+dfsg-1) ...
Setting up readline-common (8.0-4) ...
Setting up libxml2:amd64 (2.9.10+dfsg-6.1) ...
Setting up libhtml-html5-entities-perl (0.004-1) ...
Setting up libtext-levenshtein-damerau-perl (0.41-1) ...
Setting up libsereal-decoder-perl (4.018+ds-1) ...
Setting up libmarkdown2:amd64 (2.2.6-1) ...
Setting up libsuitesparseconfig5:amd64 (1:5.8.1+dfsg-2) ...
Setting up liburi-perl (5.05-1) ...
Setting up libcarp-assert-perl (0.21-1) ...
Setting up libgudev-1.0-0:amd64 (234-1) ...
Setting up libblas-dev:amd64 (3.9.0-3) ...
update-alternatives: using /usr/lib/x86_64-linux-gnu/blas/libblas.so to provide /usr/lib/x86_64-linux-gnu/libblas.so (libblas.so-x86_64-linux-gnu) in auto mode
Setting up libsz2:amd64 (1.0.4-1) ...
Setting up libvorbisenc2:amd64 (1.3.7-1) ...
Setting up libwacom-common (1.5-1) ...
Setting up libmousex-nativetraits-perl (1.09-2) ...
Setting up libemail-address-xs-perl (1.04-1+b2) ...
Setting up libxkbcommon0:amd64 (1.0.1-1) ...
Setting up libwayland-client0:amd64 (1.18.0-2~exp1.1) ...
Setting up libnet-ssleay-perl (1.88-3) ...
Setting up libgs9-common (9.53.3~dfsg-5) ...
Setting up x11proto-dev (2020.1-1) ...
Setting up libfile-stripnondeterminism-perl (1.9.0-1) ...
Setting up libxcb-dri3-0:amd64 (1.14-2) ...
Setting up gnuplot-data (5.4.0+dfsg1-1) ...
Setting up libamd2:amd64 (1:5.8.1+dfsg-2) ...
Setting up libice6:amd64 (2:1.0.10-1) ...
Setting up libhttp-date-perl (6.05-1) ...
Setting up liblapack3:amd64 (3.9.0-3) ...
update-alternatives: using /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3 to provide /usr/lib/x86_64-linux-gnu/liblapack.so.3 (liblapack.so.3-x86_64-linux-gnu) in auto mode
Setting up libncurses-dev:amd64 (6.2+20200918-1) ...
Setting up libfile-basedir-perl (0.08-1) ...
Setting up libxdamage1:amd64 (1:1.1.5-2) ...
Setting up libgmp-dev:amd64 (2:6.2.0+dfsg-6) ...
Setting up libfile-listing-perl (6.11-1) ...
Setting up libxau-dev:amd64 (1:1.0.8-1+b2) ...
Setting up libcolamd2:amd64 (1:5.8.1+dfsg-2) ...
Setting up libxpm4:amd64 (1:3.5.12-1) ...
Setting up libxrender1:amd64 (1:0.9.10-1) ...
Setting up libtool (2.4.6-14) ...
Setting up libfftw3-bin (3.3.8-2) ...
Setting up libobject-id-perl (0.1.2-2) ...
Setting up liblist-moreutils-perl (0.416-1+b5) ...
Setting up libwebpdemux2:amd64 (0.6.1-2+b1) ...
Setting up libregexp-pattern-license-perl (3.4.0-1) ...
Setting up libreadline8:amd64 (8.0-4) ...
Setting up libhash-merge-perl (0.302-1) ...
Setting up libaec-dev:amd64 (1.0.4-1) ...
Setting up libarpack2:amd64 (3.7.0-3) ...
Setting up libavahi-common3:amd64 (0.8-3) ...
Setting up libtype-tiny-perl (1.010006-1) ...
Setting up libx265-192:amd64 (3.4-2) ...
Setting up libjpeg-dev (1:2.0.5-1.1) ...
Setting up libxext6:amd64 (2:1.3.3-1+b2) ...
Setting up libldap-2.4-2:amd64 (2.4.54+dfsg-1) ...
Setting up libnet-http-perl (6.19-1) ...
Setting up libpath-iterator-rule-perl (1.014-1) ...
Setting up libtext-markdown-discount-perl:amd64 (0.12-1) ...
Setting up m4 (1.4.18-4) ...
Setting up libcurl3-gnutls:amd64 (7.72.0-1) ...
Setting up libexception-class-perl (1.44-1) ...
Setting up libclass-c3-perl (0.34-1) ...
Setting up libreadline-dev:amd64 (8.0-4) ...
Setting up libqrupdate1:amd64 (1.1.2-4) ...
Setting up libdevel-callchecker-perl (0.008-1+b1) ...
Setting up libmpfr-dev:amd64 (4.1.0-3) ...
Setting up libxxf86vm1:amd64 (1:1.1.4-1+b2) ...
Setting up patchutils (0.4.2-1) ...
Setting up libthai0:amd64 (0.1.28-3) ...
Setting up ca-certificates (20200601) ...
Updating certificates in /etc/ssl/certs...
126 added, 0 removed; done.
Setting up libcamd2:amd64 (1:5.8.1+dfsg-2) ...
Setting up libxdmcp-dev:amd64 (1:1.1.2-3) ...
Setting up libtest-exception-perl (0.43-1) ...
Setting up libfreetype6:amd64 (2.10.2+dfsg-4) ...
Setting up libglpk40:amd64 (4.65-2) ...
Setting up libxfixes3:amd64 (1:5.0.3-2) ...
Setting up libstring-copyright-perl (0.003006-1) ...
Setting up x11proto-core-dev (2020.1-1) ...
Setting up shared-mime-info (2.0-1) ...
Setting up libxinerama1:amd64 (2:1.1.4-2) ...
Setting up libxkbcommon-x11-0:amd64 (1.0.1-1) ...
Setting up liblapack-dev:amd64 (3.9.0-3) ...
update-alternatives: using /usr/lib/x86_64-linux-gnu/lapack/liblapack.so to provide /usr/lib/x86_64-linux-gnu/liblapack.so (liblapack.so-x86_64-linux-gnu) in auto mode
Setting up gfortran-10 (10.2.0-15) ...
Setting up libdata-optlist-perl (0.110-1) ...
Setting up libcroco3:amd64 (0.6.13-1) ...
Setting up ucf (3.0043) ...
Setting up libqt5core5a:amd64 (5.14.2+dfsg-6) ...
Setting up autoconf (2.69-11.1) ...
Setting up dh-strip-nondeterminism (1.9.0-1) ...
Setting up libwww-robotrules-perl (6.02-1) ...
Setting up libjack-jackd2-0:amd64 (1.9.16~dfsg-1) ...
Setting up libdrm2:amd64 (2.4.102-1) ...
Setting up libhdf5-103-1:amd64 (1.10.6+repack-2) ...
Setting up dwz (0.13-5) ...
Setting up groff-base (1.22.4-5) ...
Setting up libqt5dbus5:amd64 (5.14.2+dfsg-6) ...
Setting up libccolamd2:amd64 (1:5.8.1+dfsg-2) ...
Setting up libhtml-parser-perl (3.75-1) ...
Setting up libhdf5-cpp-103-1:amd64 (1.10.6+repack-2) ...
Setting up gpgconf (2.2.20-1) ...
Setting up libharfbuzz0b:amd64 (2.6.7-1) ...
Setting up libsndfile1:amd64 (1.0.28-8) ...
Setting up libmro-compat-perl (0.13-1) ...
Setting up libwacom2:amd64 (1.5-1) ...
Setting up libsm6:amd64 (2:1.2.3-1) ...
Setting up libfftw3-dev:amd64 (3.3.8-2) ...
Setting up libavahi-client3:amd64 (0.8-3) ...
Setting up libcholmod3:amd64 (1:5.8.1+dfsg-2) ...
Setting up libio-socket-ssl-perl (2.068-1) ...
Setting up gpg (2.2.20-1) ...
Setting up libsub-exporter-perl (0.987-1) ...
Setting up libhttp-message-perl (6.26-1) ...
Setting up libdrm-amdgpu1:amd64 (2.4.102-1) ...
Setting up libhdf5-hl-100:amd64 (1.10.6+repack-2) ...
Setting up automake (1:1.16.2-4) ...
update-alternatives: using /usr/bin/automake-1.16 to provide /usr/bin/automake (automake) in auto mode
Setting up libiterator-perl (0.03+ds1-1) ...
Setting up libpaper1:amd64 (1.1.28+b1) ...

Creating config file /etc/papersize with new version
Setting up libportaudio2:amd64 (19.6.0-1.1) ...
Setting up libhttp-negotiate-perl (6.01-1) ...
Setting up libcarp-assert-more-perl (1.24-1) ...
Setting up libdrm-nouveau2:amd64 (2.4.102-1) ...
Setting up gettext (0.19.8.1-10) ...
Setting up libxcb1-dev:amd64 (1.14-2) ...
Setting up libiterator-util-perl (0.02+ds1-1) ...
Setting up libgbm1:amd64 (20.2.1-1) ...
Setting up libhttp-cookies-perl (6.08-1) ...
Setting up libwmf0.2-7:amd64 (0.2.8.4-17) ...
Setting up libdrm-radeon1:amd64 (2.4.102-1) ...
Setting up fontconfig-config (2.13.1-4.2) ...
Setting up libhtml-tree-perl (5.07-2) ...
Setting up libxcursor1:amd64 (1:1.2.0-2) ...
Setting up libparams-classify-perl (0.015-1+b2) ...
Setting up libdrm-intel1:amd64 (2.4.102-1) ...
Setting up libgl1-mesa-dri:amd64 (20.2.1-1) ...
Setting up libheif1:amd64 (1.9.1-1) ...
Setting up libx11-dev:amd64 (2:1.6.12-1) ...
Setting up man-db (2.9.3-2) ...
Not building database; man-db/auto-update is not 'true'.
Setting up libxml-sax-perl (1.02+dfsg-1) ...
update-perl-sax-parsers: Registering Perl SAX parser XML::SAX::PurePerl with priority 10...
update-perl-sax-parsers: Updating overall Perl SAX parser modules info file...

Creating config file /etc/perl/XML/SAX/ParserDetails.ini with new version
Setting up gfortran (4:10.2.0-1) ...
update-alternatives: using /usr/bin/gfortran to provide /usr/bin/f95 (f95) in auto mode
update-alternatives: using /usr/bin/gfortran to provide /usr/bin/f77 (f77) in auto mode
Setting up libqt5network5:amd64 (5.14.2+dfsg-6) ...
Setting up libinput-bin (1.16.2-1) ...
Setting up intltool-debian (0.35.0+20060710.5) ...
Setting up libqt5sql5:amd64 (5.14.2+dfsg-6) ...
Setting up tex-common (6.15) ...
update-language: texlive-base not installed and configured, doing nothing!
Setting up libqt5xml5:amd64 (5.14.2+dfsg-6) ...
Setting up libegl-mesa0:amd64 (20.2.1-1) ...
Setting up libhdf5-hl-cpp-100:amd64 (1.10.6+repack-2) ...
Setting up libumfpack5:amd64 (1:5.8.1+dfsg-2) ...
Setting up libnet-smtp-ssl-perl (1.04-1) ...
Setting up libmodule-runtime-perl (0.016-1) ...
Setting up libmailtools-perl (2.21-1) ...
Setting up libconfig-model-perl (2.140-1) ...
Setting up libhdf5-fortran-102:amd64 (1.10.6+repack-2) ...
Setting up libgraphicsmagick-q16-3 (1.4+really1.3.35+hg16348-1) ...
Setting up libxml-libxml-perl (2.0134+dfsg-2) ...
update-perl-sax-parsers: Registering Perl SAX parser XML::LibXML::SAX::Parser with priority 50...
update-perl-sax-parsers: Registering Perl SAX parser XML::LibXML::SAX with priority 50...
update-perl-sax-parsers: Updating overall Perl SAX parser modules info file...
Replacing config file /etc/perl/XML/SAX/ParserDetails.ini with new version
Setting up libcups2:amd64 (2.3.3-3) ...
Setting up libdata-section-perl (0.200007-1) ...
Setting up libegl1:amd64 (1.3.2-1) ...
Setting up libhdf5-hl-fortran-100:amd64 (1.10.6+repack-2) ...
Setting up libgraphicsmagick++-q16-12 (1.4+really1.3.35+hg16348-1) ...
Setting up libfontconfig1:amd64 (2.13.1-4.2) ...
Setting up libdata-dpath-perl (0.58-1) ...
Setting up libstring-rewriteprefix-perl (0.008-1) ...
Setting up libconfig-model-backend-yaml-perl (2.133-2) ...
Setting up libinput10:amd64 (1.16.2-1) ...
Setting up fontconfig (2.13.1-4.2) ...
Regenerating fonts cache... done.
Setting up libxft2:amd64 (2.3.2-2) ...
Setting up libglx-mesa0:amd64 (20.2.1-1) ...
Setting up libgs9:amd64 (9.53.3~dfsg-5) ...
Setting up libglx0:amd64 (1.3.2-1) ...
Setting up libmodule-implementation-perl (0.09-1) ...
Setting up libpackage-stash-perl (0.38-1) ...
Setting up libimport-into-perl (1.002005-1) ...
Setting up libmoo-perl (2.004000-1) ...
Setting up po-debconf (1.0.21) ...
Setting up libfltk1.3:amd64 (1.3.5-1) ...
Setting up libpango-1.0-0:amd64 (1.46.2-1) ...
Setting up liblist-someutils-perl (0.58-1) ...
Setting up ghostscript (9.53.3~dfsg-5) ...
Setting up libmime-tools-perl (5.509-1) ...
Setting up libcairo2:amd64 (1.16.0-4) ...
Setting up libsoftware-license-perl (0.103014-2) ...
Setting up libclass-load-perl (0.25-1) ...
Setting up libmagickcore-6.q16-6:amd64 (8:6.9.11.24+dfsg-1+b1) ...
Setting up libgl1:amd64 (1.3.2-1) ...
Setting up libhdf5-dev (1.10.6+repack-2) ...
update-alternatives: using /usr/lib/x86_64-linux-gnu/pkgconfig/hdf5-serial.pc to provide /usr/lib/x86_64-linux-gnu/pkgconfig/hdf5.pc (hdf5.pc) in auto mode
Setting up libgd3:amd64 (2.3.0-2) ...
Setting up texinfo (6.7.0.dfsg.2-5) ...
Setting up libmagickwand-6.q16-6:amd64 (8:6.9.11.24+dfsg-1+b1) ...
Setting up libglx-dev:amd64 (1.3.2-1) ...
Setting up libglu1-mesa:amd64 (9.0.1-1) ...
Setting up libpangoft2-1.0-0:amd64 (1.46.2-1) ...
Setting up libmoox-aliases-perl (0.001006-1) ...
Setting up libparams-validate-perl:amd64 (1.30-1) ...
Setting up libb-hooks-endofscope-perl (0.24-1) ...
Setting up libgl-dev:amd64 (1.3.2-1) ...
Setting up libpangocairo-1.0-0:amd64 (1.46.2-1) ...
Setting up libegl-dev:amd64 (1.3.2-1) ...
Setting up libsoftware-licensemoreutils-perl (1.004-1) ...
Setting up libfltk-gl1.3:amd64 (1.3.5-1) ...
Setting up libqt5gui5:amd64 (5.14.2+dfsg-6) ...
Setting up libqt5widgets5:amd64 (5.14.2+dfsg-6) ...
Setting up libqt5help5:amd64 (5.14.2-3) ...
Setting up libgl2ps1.4 (1.4.2+dfsg1-1) ...
Setting up libqt5printsupport5:amd64 (5.14.2+dfsg-6) ...
Setting up liboctave7:amd64 (5.2.0-3+b1) ...
Setting up libnamespace-clean-perl (0.27-1) ...
Setting up imagemagick-6.q16 (8:6.9.11.24+dfsg-1+b1) ...
update-alternatives: using /usr/bin/compare-im6.q16 to provide /usr/bin/compare (compare) in auto mode
update-alternatives: using /usr/bin/compare-im6.q16 to provide /usr/bin/compare-im6 (compare-im6) in auto mode
update-alternatives: using /usr/bin/animate-im6.q16 to provide /usr/bin/animate (animate) in auto mode
update-alternatives: using /usr/bin/animate-im6.q16 to provide /usr/bin/animate-im6 (animate-im6) in auto mode
update-alternatives: using /usr/bin/convert-im6.q16 to provide /usr/bin/convert (convert) in auto mode
update-alternatives: using /usr/bin/convert-im6.q16 to provide /usr/bin/convert-im6 (convert-im6) in auto mode
update-alternatives: using /usr/bin/composite-im6.q16 to provide /usr/bin/composite (composite) in auto mode
update-alternatives: using /usr/bin/composite-im6.q16 to provide /usr/bin/composite-im6 (composite-im6) in auto mode
update-alternatives: using /usr/bin/conjure-im6.q16 to provide /usr/bin/conjure (conjure) in auto mode
update-alternatives: using /usr/bin/conjure-im6.q16 to provide /usr/bin/conjure-im6 (conjure-im6) in auto mode
update-alternatives: using /usr/bin/import-im6.q16 to provide /usr/bin/import (import) in auto mode
update-alternatives: using /usr/bin/import-im6.q16 to provide /usr/bin/import-im6 (import-im6) in auto mode
update-alternatives: using /usr/bin/identify-im6.q16 to provide /usr/bin/identify (identify) in auto mode
update-alternatives: using /usr/bin/identify-im6.q16 to provide /usr/bin/identify-im6 (identify-im6) in auto mode
update-alternatives: using /usr/bin/stream-im6.q16 to provide /usr/bin/stream (stream) in auto mode
update-alternatives: using /usr/bin/stream-im6.q16 to provide /usr/bin/stream-im6 (stream-im6) in auto mode
update-alternatives: using /usr/bin/display-im6.q16 to provide /usr/bin/display (display) in auto mode
update-alternatives: using /usr/bin/display-im6.q16 to provide /usr/bin/display-im6 (display-im6) in auto mode
update-alternatives: using /usr/bin/montage-im6.q16 to provide /usr/bin/montage (montage) in auto mode
update-alternatives: using /usr/bin/montage-im6.q16 to provide /usr/bin/montage-im6 (montage-im6) in auto mode
update-alternatives: using /usr/bin/mogrify-im6.q16 to provide /usr/bin/mogrify (mogrify) in auto mode
update-alternatives: using /usr/bin/mogrify-im6.q16 to provide /usr/bin/mogrify-im6 (mogrify-im6) in auto mode
Setting up libgetopt-long-descriptive-perl (0.105-1) ...
Setting up gnuplot-nox (5.4.0+dfsg1-1) ...
update-alternatives: using /usr/bin/gnuplot-nox to provide /usr/bin/gnuplot (gnuplot) in auto mode
Setting up libgles-dev:amd64 (1.3.2-1) ...
Setting up libnamespace-autoclean-perl (0.29-1) ...
Setting up libapp-cmd-perl (0.331-1) ...
Setting up libglvnd-dev:amd64 (1.3.2-1) ...
Setting up libmoox-struct-perl (0.020-1) ...
Setting up lintian (2.99.0) ...
Setting up libqscintilla2-qt5-15 (2.11.5+dfsg-3+b1) ...
Setting up dh-octave-autopkgtest (1.0.1) ...
Setting up imagemagick (8:6.9.11.24+dfsg-1+b1) ...
Setting up octave (5.2.0-3+b1) ...
Setting up cme (1.032-1) ...
Setting up libgl1-mesa-dev:amd64 (20.2.1-1) ...
Setting up licensecheck (3.0.47-1) ...
Setting up liboctave-dev (5.2.0-3+b1) ...
Setting up liblwp-protocol-https-perl (6.09-1) ...
Setting up libwww-perl (6.49-1) ...
Setting up libparse-debcontrol-perl (2.005-4) ...
Setting up dh-autoreconf (19) ...
Setting up debhelper (13.2.1) ...
Setting up libconfig-model-dpkg-perl (2.139) ...
Setting up dh-octave (1.0.1) ...
Setting up sbuild-build-depends-main-dummy (0.invalid.0) ...
Processing triggers for libc-bin (2.31-4) ...
Processing triggers for ca-certificates (20200601) ...
Updating certificates in /etc/ssl/certs...
0 added, 0 removed; done.
Running hooks in /etc/ca-certificates/update.d...
done.

+------------------------------------------------------------------------------+
| Check architectures                                                          |
+------------------------------------------------------------------------------+

Arch check ok (amd64 included in any all)

+------------------------------------------------------------------------------+
| Build environment                                                            |
+------------------------------------------------------------------------------+

Kernel: Linux 4.19.0-6-cloud-amd64 #1 SMP Debian 4.19.67-2+deb10u2 (2019-11-11) amd64 (x86_64)
Toolchain package versions: binutils_2.35.1-2 dpkg-dev_1.20.5 g++-10_10.2.0-15 gcc-10_10.2.0-15 libc6-dev_2.31-4 libstdc++-10-dev_10.2.0-15 libstdc++6_10.2.0-15 linux-libc-dev_5.9.1-1
Package versions: adduser_3.118 aglfn_1.7+git20191031.4036a9c-2 apt_2.1.11 autoconf_2.69-11.1 automake_1:1.16.2-4 autopoint_0.19.8.1-10 autotools-dev_20180224.1 base-files_11 base-passwd_3.5.48 bash_5.1~rc1-2 binutils_2.35.1-2 binutils-common_2.35.1-2 binutils-x86-64-linux-gnu_2.35.1-2 bsdextrautils_2.36-3+b1 bsdutils_1:2.36-3+b1 build-essential_12.8 bzip2_1.0.8-4 ca-certificates_20200601 clang-10_1:10.0.1-7 cme_1.032-1 coreutils_8.32-4+b1 cpp_4:10.2.0-1 cpp-10_10.2.0-15 dash_0.5.10.2-7 debconf_1.5.74 debhelper_13.2.1 debian-archive-keyring_2019.1 debianutils_4.11.2 dh-autoreconf_19 dh-octave_1.0.1 dh-octave-autopkgtest_1.0.1 dh-strip-nondeterminism_1.9.0-1 diffstat_1.63-1 diffutils_1:3.7-3 dpkg_1.20.5 dpkg-dev_1.20.5 dwz_0.13-5 e2fsprogs_1.45.6-1 fakeroot_1.25.3-1 file_1:5.38-5 findutils_4.7.0+git20201010-2 fontconfig_2.13.1-4.2 fontconfig-config_2.13.1-4.2 fonts-dejavu-core_2.37-2 fonts-freefont-otf_20120503-10 fonts-urw-base35_20200910-1 g++_4:10.2.0-1 g++-10_10.2.0-15 gcc_4:10.2.0-1 gcc-10_10.2.0-15 gcc-10-base_10.2.0-15 gcc-9-base_9.3.0-18 gettext_0.19.8.1-10 gettext-base_0.19.8.1-10 gfortran_4:10.2.0-1 gfortran-10_10.2.0-15 ghostscript_9.53.3~dfsg-5 gnuplot-data_5.4.0+dfsg1-1 gnuplot-nox_5.4.0+dfsg1-1 gpg_2.2.20-1 gpgconf_2.2.20-1 gpgv_2.2.20-1 grep_3.4-1 groff-base_1.22.4-5 gzip_1.10-2 hdf5-helpers_1.10.6+repack-2 hicolor-icon-theme_0.17-2 hostname_3.23 imagemagick_8:6.9.11.24+dfsg-1+b1 imagemagick-6-common_8:6.9.11.24+dfsg-1 imagemagick-6.q16_8:6.9.11.24+dfsg-1+b1 init-system-helpers_1.58 intltool-debian_0.35.0+20060710.5 lib32gcc-s1_10.2.0-15 lib32stdc++6_10.2.0-15 libacl1_2.2.53-8 libaec-dev_1.0.4-1 libaec0_1.0.4-1 libalgorithm-c3-perl_0.10-1 libaliased-perl_0.34-1 libamd2_1:5.8.1+dfsg-2 libaom0_1.0.0.errata1-3 libapp-cmd-perl_0.331-1 libapt-pkg-perl_0.1.36+b3 libapt-pkg6.0_2.1.11 libarchive-zip-perl_1.68-1 libarpack2_3.7.0-3 libarray-intspan-perl_2.004-1 libasan5_9.3.0-18 libasan6_10.2.0-15 libasound2_1.2.3.2-1 libasound2-data_1.2.3.2-1 libassuan0_2.5.3-7.1 libatomic1_10.2.0-15 libattr1_1:2.4.48-5 libaudit-common_1:2.8.5-3.1 libaudit1_1:2.8.5-3.1 libavahi-client3_0.8-3 libavahi-common-data_0.8-3 libavahi-common3_0.8-3 libb-hooks-endofscope-perl_0.24-1 libb-hooks-op-check-perl_0.22-1+b2 libbinutils_2.35.1-2 libblas-dev_3.9.0-3 libblas3_3.9.0-3 libblkid1_2.36-3+b1 libboolean-perl_0.46-1 libbrotli1_1.0.9-2+b1 libbsd0_0.10.0-1 libbz2-1.0_1.0.8-4 libc-bin_2.31-4 libc-dev-bin_2.31-4 libc6_2.31-4 libc6-dev_2.31-4 libc6-i386_2.31-4 libcairo2_1.16.0-4 libcamd2_1:5.8.1+dfsg-2 libcap-ng0_0.7.9-2.2 libcapture-tiny-perl_0.48-1 libcarp-assert-more-perl_1.24-1 libcarp-assert-perl_0.21-1 libcc1-0_10.2.0-15 libccolamd2_1:5.8.1+dfsg-2 libcholmod3_1:5.8.1+dfsg-2 libclang-common-10-dev_1:10.0.1-7 libclang-cpp10_1:10.0.1-7 libclang1-10_1:10.0.1-7 libclass-c3-perl_0.34-1 libclass-data-inheritable-perl_0.08-3 libclass-load-perl_0.25-1 libclass-method-modifiers-perl_2.13-1 libclass-xsaccessor-perl_1.19-3+b5 libclone-choose-perl_0.010-1 libclone-perl_0.45-1 libcolamd2_1:5.8.1+dfsg-2 libcom-err2_1.45.6-1 libconfig-model-backend-yaml-perl_2.133-2 libconfig-model-dpkg-perl_2.139 libconfig-model-perl_2.140-1 libconfig-tiny-perl_2.24-1 libconvert-binhex-perl_1.125-1 libcpanel-json-xs-perl_4.24-1 libcroco3_0.6.13-1 libcrypt-dev_1:4.4.17-1 libcrypt1_1:4.4.17-1 libctf-nobfd0_2.35.1-2 libctf0_2.35.1-2 libcups2_2.3.3-3 libcurl3-gnutls_7.72.0-1 libcxsparse3_1:5.8.1+dfsg-2 libdata-dpath-perl_0.58-1 libdata-messagepack-perl_1.00-4 libdata-optlist-perl_0.110-1 libdata-section-perl_0.200007-1 libdata-validate-domain-perl_0.10-1 libdatrie1_0.2.12-3 libdav1d4_0.7.1-3 libdb5.3_5.3.28+dfsg1-0.6 libdbus-1-3_1.12.20-1 libde265-0_1.0.7-1 libdebconfclient0_0.255 libdebhelper-perl_13.2.1 libdevel-callchecker-perl_0.008-1+b1 libdevel-size-perl_0.83-1+b1 libdevel-stacktrace-perl_2.0400-1 libdouble-conversion3_3.1.5-6 libdpkg-perl_1.20.5 libdrm-amdgpu1_2.4.102-1 libdrm-common_2.4.102-1 libdrm-intel1_2.4.102-1 libdrm-nouveau2_2.4.102-1 libdrm-radeon1_2.4.102-1 libdrm2_2.4.102-1 libdynaloader-functions-perl_0.003-1 libedit2_3.1-20191231-1 libegl-dev_1.3.2-1 libegl-mesa0_20.2.1-1 libegl1_1.3.2-1 libelf1_0.181-1 libemail-address-xs-perl_1.04-1+b2 libencode-locale-perl_1.05-1 liberror-perl_0.17029-1 libevdev2_1.9.1+dfsg-1 libexception-class-perl_1.44-1 libexpat1_2.2.10-1 libexporter-lite-perl_0.08-1 libexporter-tiny-perl_1.002002-1 libext2fs2_1.45.6-1 libfakeroot_1.25.3-1 libffi7_3.3-4 libfftw3-bin_3.3.8-2 libfftw3-dev_3.3.8-2 libfftw3-double3_3.3.8-2 libfftw3-long3_3.3.8-2 libfftw3-quad3_3.3.8-2 libfftw3-single3_3.3.8-2 libfile-basedir-perl_0.08-1 libfile-find-rule-perl_0.34-1 libfile-homedir-perl_1.006-1 libfile-listing-perl_6.11-1 libfile-stripnondeterminism-perl_1.9.0-1 libfile-which-perl_1.23-1 libflac8_1.3.3-1 libfltk-gl1.3_1.3.5-1 libfltk1.3_1.3.5-1 libfont-ttf-perl_1.06-1 libfontconfig1_2.13.1-4.2 libfreetype6_2.10.2+dfsg-4 libfribidi0_1.0.8-2 libgbm1_20.2.1-1 libgc1_1:8.0.4-2.1 libgcc-10-dev_10.2.0-15 libgcc-9-dev_9.3.0-18 libgcc-s1_10.2.0-15 libgcrypt20_1.8.7-2 libgd3_2.3.0-2 libgdbm-compat4_1.18.1-5.1 libgdbm6_1.18.1-5.1 libgetopt-long-descriptive-perl_0.105-1 libgfortran-10-dev_10.2.0-15 libgfortran5_10.2.0-15 libgl-dev_1.3.2-1 libgl1_1.3.2-1 libgl1-mesa-dev_20.2.1-1 libgl1-mesa-dri_20.2.1-1 libgl2ps1.4_1.4.2+dfsg1-1 libglapi-mesa_20.2.1-1 libgles-dev_1.3.2-1 libgles1_1.3.2-1 libgles2_1.3.2-1 libglib2.0-0_2.66.1-2 libglpk40_4.65-2 libglu1-mesa_9.0.1-1 libglvnd-dev_1.3.2-1 libglvnd0_1.3.2-1 libglx-dev_1.3.2-1 libglx-mesa0_20.2.1-1 libglx0_1.3.2-1 libgmp-dev_2:6.2.0+dfsg-6 libgmp10_2:6.2.0+dfsg-6 libgmpxx4ldbl_2:6.2.0+dfsg-6 libgnutls30_3.6.15-4 libgomp1_10.2.0-15 libgpg-error0_1.38-2 libgraphicsmagick++-q16-12_1.4+really1.3.35+hg16348-1 libgraphicsmagick-q16-3_1.4+really1.3.35+hg16348-1 libgraphite2-3_1.3.14-1 libgs9_9.53.3~dfsg-5 libgs9-common_9.53.3~dfsg-5 libgssapi-krb5-2_1.17-10 libgudev-1.0-0_234-1 libharfbuzz0b_2.6.7-1 libhash-fieldhash-perl_0.15-1+b2 libhash-merge-perl_0.302-1 libhdf5-103-1_1.10.6+repack-2 libhdf5-cpp-103-1_1.10.6+repack-2 libhdf5-dev_1.10.6+repack-2 libhdf5-fortran-102_1.10.6+repack-2 libhdf5-hl-100_1.10.6+repack-2 libhdf5-hl-cpp-100_1.10.6+repack-2 libhdf5-hl-fortran-100_1.10.6+repack-2 libheif1_1.9.1-1 libhogweed6_3.6-2 libhtml-html5-entities-perl_0.004-1 libhtml-parser-perl_3.75-1 libhtml-tagset-perl_3.20-4 libhtml-tree-perl_5.07-2 libhttp-cookies-perl_6.08-1 libhttp-date-perl_6.05-1 libhttp-message-perl_6.26-1 libhttp-negotiate-perl_6.01-1 libice6_2:1.0.10-1 libicu67_67.1-4 libidn11_1.33-2.4 libidn2-0_2.3.0-1 libijs-0.35_0.35-15 libimport-into-perl_1.002005-1 libinput-bin_1.16.2-1 libinput10_1.16.2-1 libio-html-perl_1.001-1 libio-socket-ssl-perl_2.068-1 libio-string-perl_1.08-3 libio-stringy-perl_2.111-3 libio-tiecombine-perl_1.005-1 libipc-run3-perl_0.048-2 libipc-system-simple-perl_1.30-1 libisl22_0.22.1-1 libiterator-perl_0.03+ds1-1 libiterator-util-perl_0.02+ds1-1 libitm1_10.2.0-15 libjack-jackd2-0_1.9.16~dfsg-1 libjbig0_2.1-3.1+b2 libjbig2dec0_0.19-1 libjpeg-dev_1:2.0.5-1.1 libjpeg62-turbo_1:2.0.5-1.1 libjpeg62-turbo-dev_1:2.0.5-1.1 libjson-maybexs-perl_1.004002-1 libjson-perl_4.02000-2 libk5crypto3_1.17-10 libkeyutils1_1.6.1-2 libkrb5-3_1.17-10 libkrb5support0_1.17-10 liblapack-dev_3.9.0-3 liblapack3_3.9.0-3 liblcms2-2_2.9-4+b1 libldap-2.4-2_2.4.54+dfsg-1 liblist-compare-perl_0.55-1 liblist-moreutils-perl_0.416-1+b5 liblist-someutils-perl_0.58-1 liblist-utilsby-perl_0.11-1 libllvm10_1:10.0.1-7 libllvm11_1:11.0.0-3 liblog-any-adapter-screen-perl_0.140-1 liblog-any-perl_1.708-1 liblog-log4perl-perl_1.53-1 liblqr-1-0_0.4.2-2.1 liblsan0_10.2.0-15 libltdl7_2.4.6-14 liblua5.4-0_5.4.0-2 liblwp-mediatypes-perl_6.04-1 liblwp-protocol-https-perl_6.09-1 liblz4-1_1.9.2-2 liblzma5_5.2.4-1+b1 liblzo2-2_2.10-2 libmagic-mgc_1:5.38-5 libmagic1_1:5.38-5 libmagickcore-6.q16-6_8:6.9.11.24+dfsg-1+b1 libmagickwand-6.q16-6_8:6.9.11.24+dfsg-1+b1 libmailtools-perl_2.21-1 libmarkdown2_2.2.6-1 libmd4c0_0.4.6-1 libmetis5_5.1.0.dfsg-7 libmime-tools-perl_5.509-1 libmodule-implementation-perl_0.09-1 libmodule-pluggable-perl_5.2-1 libmodule-runtime-perl_0.016-1 libmoo-perl_2.004000-1 libmoox-aliases-perl_0.001006-1 libmoox-struct-perl_0.020-1 libmount1_2.36-3+b1 libmouse-perl_2.5.10-1 libmousex-nativetraits-perl_1.09-2 libmousex-strictconstructor-perl_0.02-2 libmpc3_1.2.0-1 libmpfr-dev_4.1.0-3 libmpfr6_4.1.0-3 libmro-compat-perl_0.13-1 libmtdev1_1.1.6-1 libnamespace-autoclean-perl_0.29-1 libnamespace-clean-perl_0.27-1 libncurses-dev_6.2+20200918-1 libncurses6_6.2+20200918-1 libncursesw6_6.2+20200918-1 libnet-domain-tld-perl_1.75-1 libnet-http-perl_6.19-1 libnet-smtp-ssl-perl_1.04-1 libnet-ssleay-perl_1.88-3 libnettle8_3.6-2 libnghttp2-14_1.41.0-3 libnsl-dev_1.3.0-2 libnsl2_1.3.0-2 libnss-nis_3.1-4 libnss-nisplus_1.3-4 libnuma1_2.0.12-1+b1 libnumber-compare-perl_0.03-1 libnumber-range-perl_0.12-1 libobjc-10-dev_10.2.0-15 libobjc-9-dev_9.3.0-18 libobjc4_10.2.0-15 libobject-id-perl_0.1.2-2 liboctave-dev_5.2.0-3+b1 liboctave7_5.2.0-3+b1 libogg0_1.3.2-1+b1 libomp-10-dev_1:10.0.1-7 libomp5-10_1:10.0.1-7 libopengl-dev_1.3.2-1 libopengl0_1.3.2-1 libopenjp2-7_2.3.1-1 libp11-kit0_0.23.21-2 libpackage-stash-perl_0.38-1 libpam-modules_1.3.1-5 libpam-modules-bin_1.3.1-5 libpam-runtime_1.3.1-5 libpam0g_1.3.1-5 libpango-1.0-0_1.46.2-1 libpangocairo-1.0-0_1.46.2-1 libpangoft2-1.0-0_1.46.2-1 libpaper1_1.1.28+b1 libparams-classify-perl_0.015-1+b2 libparams-util-perl_1.101-1 libparams-validate-perl_1.30-1 libparse-debcontrol-perl_2.005-4 libparse-recdescent-perl_1.967015+dfsg-2 libpath-iterator-rule-perl_1.014-1 libpath-tiny-perl_0.114-1 libpciaccess0_0.16-1 libpcre2-16-0_10.34-7 libpcre2-8-0_10.34-7 libpcre3_2:8.39-13 libperl5.30_5.30.3-4 libperlio-gzip-perl_0.19-1+b6 libpipeline1_1.5.3-1 libpixman-1-0_0.36.0-1 libpng16-16_1.6.37-3 libpod-constants-perl_0.19-2 libpod-pom-perl_2.01-3 libportaudio2_19.6.0-1.1 libproc-processtable-perl_0.59-2 libpsl5_0.21.0-1.1 libpthread-stubs0-dev_0.4-1 libqhull8.0_2020.1-2 libqrupdate1_1.1.2-4 libqscintilla2-qt5-15_2.11.5+dfsg-3+b1 libqscintilla2-qt5-l10n_2.11.5+dfsg-3 libqt5core5a_5.14.2+dfsg-6 libqt5dbus5_5.14.2+dfsg-6 libqt5gui5_5.14.2+dfsg-6 libqt5help5_5.14.2-3 libqt5network5_5.14.2+dfsg-6 libqt5printsupport5_5.14.2+dfsg-6 libqt5sql5_5.14.2+dfsg-6 libqt5widgets5_5.14.2+dfsg-6 libqt5xml5_5.14.2+dfsg-6 libquadmath0_10.2.0-15 libre-engine-re2-perl_0.13-5+b3 libre2-8_20201001+dfsg-1 libreadline-dev_8.0-4 libreadline8_8.0-4 libregexp-common-perl_2017060201-1 libregexp-pattern-license-perl_3.4.0-1 libregexp-pattern-perl_0.2.14-1 librole-tiny-perl_2.001004-1 librtmp1_2.4+20151223.gitfa8646d.1-2+b2 libsamplerate0_0.1.9-2 libsasl2-2_2.1.27+dfsg-2 libsasl2-modules-db_2.1.27+dfsg-2 libseccomp2_2.4.4-1+b1 libselinux1_3.1-2+b1 libsemanage-common_3.1-1 libsemanage1_3.1-1+b1 libsensors-config_1:3.6.0-2 libsensors5_1:3.6.0-2 libsepol1_3.1-1 libsereal-decoder-perl_4.018+ds-1 libsereal-encoder-perl_4.018+ds-1 libsigsegv2_2.12-2 libsm6_2:1.2.3-1 libsmartcols1_2.36-3+b1 libsndfile1_1.0.28-8 libsoftware-license-perl_0.103014-2 libsoftware-licensemoreutils-perl_1.004-1 libsort-key-perl_1.33-2+b2 libsort-versions-perl_1.62-1 libsqlite3-0_3.33.0-1 libss2_1.45.6-1 libssh2-1_1.8.0-2.1 libssl1.1_1.1.1h-1 libstdc++-10-dev_10.2.0-15 libstdc++6_10.2.0-15 libstrictures-perl_2.000006-1 libstring-copyright-perl_0.003006-1 libstring-escape-perl_2010.002-2 libstring-rewriteprefix-perl_0.008-1 libsub-exporter-perl_0.987-1 libsub-exporter-progressive-perl_0.001013-1 libsub-identify-perl_0.14-1+b2 libsub-install-perl_0.928-1 libsub-name-perl_0.26-1 libsub-override-perl_0.09-2 libsub-quote-perl_2.006006-1 libsub-uplevel-perl_0.2800-1 libsuitesparseconfig5_1:5.8.1+dfsg-2 libsystemd0_246.6-2 libsz2_1.0.4-1 libtasn1-6_4.16.0-2 libtest-exception-perl_0.43-1 libtext-autoformat-perl_1.750000-1 libtext-glob-perl_0.11-1 libtext-levenshtein-damerau-perl_0.41-1 libtext-levenshteinxs-perl_0.03-4+b7 libtext-markdown-discount-perl_0.12-1 libtext-reform-perl_1.20-3 libtext-template-perl_1.59-1 libtext-unidecode-perl_1.30-1 libtext-xslate-perl_3.5.8-1 libthai-data_0.1.28-3 libthai0_0.1.28-3 libtiff5_4.1.0+git191117-2 libtime-duration-perl_1.21-1 libtime-moment-perl_0.44-1+b2 libtimedate-perl_2.3300-1 libtinfo6_6.2+20200918-1 libtirpc-common_1.2.6-3 libtirpc-dev_1.2.6-3 libtirpc3_1.2.6-3 libtool_2.4.6-14 libtry-tiny-perl_0.30-1 libtsan0_10.2.0-15 libtype-tiny-perl_1.010006-1 libubsan1_10.2.0-15 libuchardet0_0.0.7-1 libudev1_246.6-2 libumfpack5_1:5.8.1+dfsg-2 libunicode-utf8-perl_0.62-1+b1 libunistring2_0.9.10-4 liburi-perl_5.05-1 libuuid1_2.36-3+b1 libvariable-magic-perl_0.62-1+b2 libvorbis0a_1.3.7-1 libvorbisenc2_1.3.7-1 libvulkan1_1.2.154.1-1 libwacom-common_1.5-1 libwacom2_1.5-1 libwayland-client0_1.18.0-2~exp1.1 libwayland-server0_1.18.0-2~exp1.1 libwebp6_0.6.1-2+b1 libwebpdemux2_0.6.1-2+b1 libwebpmux3_0.6.1-2+b1 libwmf0.2-7_0.2.8.4-17 libwww-perl_6.49-1 libwww-robotrules-perl_6.02-1 libx11-6_2:1.6.12-1 libx11-data_2:1.6.12-1 libx11-dev_2:1.6.12-1 libx11-xcb1_2:1.6.12-1 libx265-192_3.4-2 libxau-dev_1:1.0.8-1+b2 libxau6_1:1.0.8-1+b2 libxcb-dri2-0_1.14-2 libxcb-dri3-0_1.14-2 libxcb-glx0_1.14-2 libxcb-icccm4_0.4.1-1.1 libxcb-image0_0.4.0-1+b2 libxcb-keysyms1_0.4.0-1+b2 libxcb-present0_1.14-2 libxcb-randr0_1.14-2 libxcb-render-util0_0.3.9-1+b1 libxcb-render0_1.14-2 libxcb-shape0_1.14-2 libxcb-shm0_1.14-2 libxcb-sync1_1.14-2 libxcb-util0_0.3.8-3+b2 libxcb-xfixes0_1.14-2 libxcb-xinerama0_1.14-2 libxcb-xinput0_1.14-2 libxcb-xkb1_1.14-2 libxcb1_1.14-2 libxcb1-dev_1.14-2 libxcursor1_1:1.2.0-2 libxdamage1_1:1.1.5-2 libxdmcp-dev_1:1.1.2-3 libxdmcp6_1:1.1.2-3 libxext6_2:1.3.3-1+b2 libxfixes3_1:5.0.3-2 libxft2_2.3.2-2 libxinerama1_2:1.1.4-2 libxkbcommon-x11-0_1.0.1-1 libxkbcommon0_1.0.1-1 libxml-libxml-perl_2.0134+dfsg-2 libxml-namespacesupport-perl_1.12-1 libxml-sax-base-perl_1.09-1 libxml-sax-perl_1.02+dfsg-1 libxml2_2.9.10+dfsg-6.1 libxpm4_1:3.5.12-1 libxrender1_1:0.9.10-1 libxshmfence1_1.3-1 libxxf86vm1_1:1.1.4-1+b2 libyaml-0-2_0.2.2-1 libyaml-libyaml-perl_0.82+repack-1 libyaml-perl_1.30-1 libyaml-tiny-perl_1.73-1 libz3-4_4.8.9-1 libzstd1_1.4.5+dfsg-4 licensecheck_3.0.47-1 lintian_2.99.0 linux-libc-dev_5.9.1-1 login_1:4.8.1-1 logsave_1.45.6-1 lsb-base_11.1.0 lzip_1.21-8 lzop_1.04-1 m4_1.4.18-4 make_4.3-4 man-db_2.9.3-2 mawk_1.3.4.20200120-2 mount_2.36-3+b1 ncurses-base_6.2+20200918-1 ncurses-bin_6.2+20200918-1 netbase_6.2 octave_5.2.0-3+b1 octave-common_5.2.0-3 openssl_1.1.1h-1 passwd_1:4.8.1-1 patch_2.7.6-6 patchutils_0.4.2-1 perl_5.30.3-4 perl-base_5.30.3-4 perl-modules-5.30_5.30.3-4 perl-openssl-defaults_5 po-debconf_1.0.21 poppler-data_0.4.9-2 qt5-qmake_5.14.2+dfsg-6 qt5-qmake-bin_5.14.2+dfsg-6 qtchooser_66-2 readline-common_8.0-4 sbuild-build-depends-main-dummy_0.invalid.0 sed_4.7-1 sensible-utils_0.0.12+nmu1 shared-mime-info_2.0-1 sysvinit-utils_2.96-5 t1utils_1.41-4 tar_1.30+dfsg-7 tex-common_6.15 texinfo_6.7.0.dfsg.2-5 tzdata_2020d-1 ucf_3.0043 unzip_6.0-25 util-linux_2.36-3+b1 x11-common_1:7.7+21 x11proto-core-dev_2020.1-1 x11proto-dev_2020.1-1 xkb-data_2.29-2 xorg-sgml-doctools_1:1.11-1 xtrans-dev_1.4.0-1 xz-utils_5.2.4-1+b1 zlib1g_1:1.2.11.dfsg-2 zlib1g-dev_1:1.2.11.dfsg-2

+------------------------------------------------------------------------------+
| Build                                                                        |
+------------------------------------------------------------------------------+


Unpack source
-------------

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA256

Format: 3.0 (quilt)
Source: octave-interval
Binary: octave-interval, octave-interval-doc
Architecture: any all
Version: 3.2.0-6
Maintainer: Debian Octave Group <team+pkg-octave-team@tracker.debian.org>
Uploaders: Oliver Heimlich <oheim@posteo.de>,
Homepage: https://octave.sourceforge.io/interval/
Standards-Version: 4.5.0
Vcs-Browser: https://salsa.debian.org/pkg-octave-team/octave-interval
Vcs-Git: https://salsa.debian.org/pkg-octave-team/octave-interval.git
Testsuite: autopkgtest-pkg-octave
Build-Depends: debhelper-compat (= 13), dh-octave (>= 0.7.1), ghostscript, libmpfr-dev (>= 3.1.0)
Build-Depends-Indep: texinfo, imagemagick, gnuplot-nox
Package-List:
 octave-interval deb math optional arch=any
 octave-interval-doc deb doc optional arch=all
Checksums-Sha1:
 9890115852745616ec5ca157aec518243d5b8030 2672463 octave-interval_3.2.0.orig.tar.gz
 3d1e552f8accb5514a3b7d42fed0ab126f0afdad 7828 octave-interval_3.2.0-6.debian.tar.xz
Checksums-Sha256:
 40dca588e32167484a3e9d1c77858db11f4eacb5ea92dcc37c78144fd6f91a28 2672463 octave-interval_3.2.0.orig.tar.gz
 549852960b935a955f565a48a529897063d952933966aa0fad349a21869df38b 7828 octave-interval_3.2.0-6.debian.tar.xz
Files:
 be6ea4eef9e92f9198776c05c5b56f30 2672463 octave-interval_3.2.0.orig.tar.gz
 14f95327bde1a6a896b4dd93622546ef 7828 octave-interval_3.2.0-6.debian.tar.xz

-----BEGIN PGP SIGNATURE-----

iQIzBAEBCAAdFiEEP0ZDkUmP6HS9tdmPISSqGYN4XJAFAl8n8CQACgkQISSqGYN4
XJBsMg/9H5mCh+e5XUlZybS4S9A/xeLmCkZiJLo9EX19lwXh1du45jRZr4fNaNjI
rzpns8XhXwvxLVAJEfUfAQOs8V3LsrziI0sEKc9i9uHwmnG+Ihc2TCArcgSNv3zU
El9WuWmTEUpDHcFC5CifW/FqNEw6bA/P06F1oJTx7EVUKuqpeFolqeDdXRxHuT7x
ZMGCDIDYUeOx//BtBPhPlSf5KF68+fgyf1Hq8C/lsul1Pr0c4oqF/S2oOvQzhH6L
FzXcuqgdv7Yok/xO7xyrI98wKN7mYF4KTb6F44VY2G2eGayCBaIVWx8ZM9S8ckL9
aRRPmHFMSk86wgQyTs7+TaSuRbZjjCKiD61y7WpIMiU9BSxBmc8v7yYoBbxuEuOl
dZiV4iGpSy1s51xeV5LeMPGmM3k1WYDCtI/dW0eX1CzdASOVdUZKAFIvdG9D3qLe
psiafu8pS3EuJLtrCLoQIqqgCSP7n014IUNUubl6uOBlGZuA/BBOwtyX3SufwF3y
6tr1LK0U+I5YBZaa/DeGPT//3dPHHOOxzI9JYcCL/KdODCEE0lxwQsE+kColudT/
juczrCPJ58vV2T7oFZshHEy+2n/bjfiJCGMxzeccYNpAdgsKjpQHZbirtaNbWLYl
ahp4sY3+bIez1sTPoltoN99VtvRRd3Ag7mfA8TSdpGL7ASeNEfQ=
=L/LY
-----END PGP SIGNATURE-----

gpgv: unknown type of key resource 'trustedkeys.kbx'
gpgv: keyblock resource '/tmp/dpkg-verify-sig.aDvEG4rv/trustedkeys.kbx': General error
gpgv: Signature made Mon Aug  3 11:08:20 2020 UTC
gpgv:                using RSA key 3F464391498FE874BDB5D98F2124AA1983785C90
gpgv: Can't check signature: No public key
dpkg-source: warning: failed to verify signature on ./octave-interval_3.2.0-6.dsc
dpkg-source: info: extracting octave-interval in /<<PKGBUILDDIR>>
dpkg-source: info: unpacking octave-interval_3.2.0.orig.tar.gz
dpkg-source: info: unpacking octave-interval_3.2.0-6.debian.tar.xz
dpkg-source: info: using patch list from debian/patches/series
dpkg-source: info: applying clean-src-compatibility-dir.patch
dpkg-source: info: applying no-pkg-load-at-docs-build.patch
dpkg-source: info: applying ignore-fesetround-tests.patch
dpkg-source: info: applying xtest-in-mpfr-matrix-mul-d.patch

Check disk space
----------------

Sufficient free space for build

User Environment
----------------

APT_CONFIG=/var/lib/sbuild/apt.conf
HOME=/sbuild-nonexistent
LANG=C.UTF-8
LC_ALL=C.UTF-8
LOGNAME=user42
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games
SCHROOT_ALIAS_NAME=unstable
SCHROOT_CHROOT_NAME=sid-amd64-sbuild
SCHROOT_COMMAND=env
SCHROOT_GID=1001
SCHROOT_GROUP=user42
SCHROOT_SESSION_ID=sid-amd64-sbuild-3c7de257-03f5-47ac-9e90-0b92c197f321
SCHROOT_UID=1001
SCHROOT_USER=user42
SHELL=/bin/sh
USER=user42

dpkg-buildpackage
-----------------

Command: dpkg-buildpackage -us -uc -b -rfakeroot
dpkg-buildpackage: info: source package octave-interval
dpkg-buildpackage: info: source version 3.2.0-6
dpkg-buildpackage: info: source distribution unstable
dpkg-buildpackage: info: source changed by Rafael Laboissière <rafael@debian.org>
 dpkg-source --before-build .
dpkg-buildpackage: info: host architecture amd64
dpkg-source: info: using options from octave-interval-3.2.0/debian/source/options: --extend-diff-ignore=src/crlibm/Makefile\.in|src/crlibm/aclocal\.m4|src/crlibm/scs_lib/Makefile\.in|src/crlibm/configure|src/crlibm/depcomp
 debian/rules clean
dh clean --buildsystem=octave --with=octave
   debian/rules override_dh_auto_clean
make[1]: Entering directory '/<<PKGBUILDDIR>>'
dh_auto_clean
	dh_octave_clean
make[2]: Entering directory '/<<PKGBUILDDIR>>/src'
make[2]: -p: No such file or directory
make[2]: -p: No such file or directory
/bin/sh: 1: -dM: not found
test ! -e crlibm/Makefile || make -C crlibm clean
make -C compatibility clean
make[3]: Entering directory '/<<PKGBUILDDIR>>/src/compatibility'
make[3]: -p: No such file or directory
rm -f octave.cc
make[3]: Leaving directory '/<<PKGBUILDDIR>>/src/compatibility'
rm -f *.oct *.o
make[2]: Leaving directory '/<<PKGBUILDDIR>>/src'
[ ! -f Makefile ] || /usr/bin/make clean
[ ! -f doc/Makefile ] || /usr/bin/make -C doc clean
make[2]: Entering directory '/<<PKGBUILDDIR>>/doc'
rm -f manual.html manual.pdf image/interval-sombrero.m.png image/poly-example-surf.m.png image/cameleon.m.png image/contractor-rings-intersect.m.png image/contractor-rings-union.m.png image/interval-plot3.m.png image/interval-vs-normal-plot.m.png image/poly-example-roots-simple.m.png image/poly-example-roots-with-deriv.m.png
rm -f *.aux *.cp *.fn *.ky *.log *.pg *.toc *.tp *.vr
make[2]: Leaving directory '/<<PKGBUILDDIR>>/doc'
[ ! -f src/crlibm/Makefile ] || /usr/bin/make -C src/crlibm maintainer-clean
make[1]: Leaving directory '/<<PKGBUILDDIR>>'
   dh_autoreconf_clean -O--buildsystem=octave
   dh_clean -O--buildsystem=octave
 debian/rules binary
dh binary --buildsystem=octave --with=octave
   dh_update_autotools_config -O--buildsystem=octave
   dh_autoreconf -O--buildsystem=octave
   dh_octave_version -O--buildsystem=octave
Checking the Octave version... ok
   debian/rules override_dh_auto_configure
make[1]: Entering directory '/<<PKGBUILDDIR>>'
(cd src/crlibm ; autoreconf -i)
Makefile.am: installing './depcomp'
dh_auto_configure
make[1]: Leaving directory '/<<PKGBUILDDIR>>'
   dh_auto_build -O--buildsystem=octave
   dh_auto_test -O--buildsystem=octave
   create-stamp debian/debhelper-build-stamp
   dh_testroot -O--buildsystem=octave
   dh_prep -O--buildsystem=octave
   debian/rules override_dh_auto_install-indep
make[1]: Entering directory '/<<PKGBUILDDIR>>'
dh_auto_install
	octave --no-gui --no-history --silent --no-init-file --no-window-system /usr/share/dh-octave/install-pkg.m
warning: creating installation directory /<<PKGBUILDDIR>>/debian/octave-interval/usr/share/octave/packages
warning: called from
    install at line 30 column 5
    pkg at line 441 column 9
    /usr/share/dh-octave/install-pkg.m at line 43 column 1
checking whether the C++ compiler works... yes
checking for C++ compiler default output file name... a.out
checking for suffix of executables... 
checking whether we are cross compiling... no
checking for suffix of object files... o
checking whether we are using the GNU C++ compiler... yes
checking whether g++ accepts -g... yes
checking for mpfr_init2 in -lmpfr... yes
checking for floor in -lm... yes
checking how to run the C++ preprocessor... g++ -E
checking for grep that handles long lines and -e... /bin/grep
checking for egrep... /bin/grep -E
checking for ANSI C header files... yes
checking for sys/types.h... yes
checking for sys/stat.h... yes
checking for stdlib.h... yes
checking for string.h... yes
checking for memory.h... yes
checking for strings.h... yes
checking for inttypes.h... yes
checking for stdint.h... yes
checking for unistd.h... yes
checking sstream usability... yes
checking sstream presence... yes
checking for sstream... yes
checking fenv.h usability... yes
checking fenv.h presence... yes
checking for fenv.h... yes
checking mpfr.h usability... yes
checking mpfr.h presence... yes
checking for mpfr.h... yes
checking for int32_t... yes
checking for uint32_t... yes
checking for uint64_t... yes
checking for uint8_t... yes
checking for error_at_line... yes
checking for fesetround... yes
make[2]: Entering directory '/<<PKGBUILDDIR>>/src'
(cd crlibm && ./configure --disable-dependency-tracking --enable-sse2)
 [MKOCTFILE] crlibm_function.cc
 [MAKE] compatibility
 [MKOCTFILE] __setround__.cc
g++ -c -Wdate-time -D_FORTIFY_SOURCE=2 -fPIC -I/usr/include/octave-5.2.0/octave/.. -I/usr/include/octave-5.2.0/octave  -pthread -fopenmp -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security    crlibm_function.cc -o crlibm_function.o
make[3]: Entering directory '/<<PKGBUILDDIR>>/src/compatibility'
g++ -c -Wdate-time -D_FORTIFY_SOURCE=2 -fPIC -I/usr/include/octave-5.2.0/octave/.. -I/usr/include/octave-5.2.0/octave  -pthread -fopenmp -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security  -Wno-unknown-pragmas   __setround__.cc -o /tmp/oct-7Hafj0.o
Detected Octave version: 5.2.0
cp "octave_current.cc" "octave.cc"
make[3]: Leaving directory '/<<PKGBUILDDIR>>/src/compatibility'
 [MKOCTFILE] intervaltotext.cc
g++ -c -Wdate-time -D_FORTIFY_SOURCE=2 -fPIC -I/usr/include/octave-5.2.0/octave/.. -I/usr/include/octave-5.2.0/octave  -pthread -fopenmp -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security    intervaltotext.cc -o /tmp/oct-FaOYRJ.o
checking for a BSD-compatible install... /usr/bin/install -c
checking whether build environment is sane... yes
checking for a thread-safe mkdir -p... /bin/mkdir -p
checking for gawk... no
checking for mawk... mawk
checking whether make sets $(MAKE)... yes
checking whether make supports nested variables... yes
checking build system type... x86_64-pc-linux-gnu
checking host system type... x86_64-pc-linux-gnu
checking whether make sets $(MAKE)... (cached) yes
checking for gcc... gcc
checking whether the C compiler works... yes
checking for C compiler default output file name... a.out
checking for suffix of executables... 
checking whether we are cross compiling... no
checking for suffix of object files... o
checking whether we are using the GNU C compiler... yes
checking whether gcc accepts -g... yes
checking for gcc option to accept ISO C89... none needed
checking whether gcc understands -c and -o together... yes
checking whether make supports the include directive... yes (GNU style)
checking dependency style of gcc... none
checking for ranlib... ranlib
checking whether ln -s works... yes
checking how to run the C preprocessor... gcc -E
checking for grep that handles long lines and -e... /bin/grep
checking for egrep... /bin/grep -E
checking for ANSI C header files... yes
checking for an ANSI C-conforming const... yes
checking for inline... inline
checking for sqrt... no
checking for sys/types.h... yes
checking for sys/stat.h... yes
checking for stdlib.h... yes
checking for string.h... yes
checking for memory.h... yes
checking for strings.h... yes
checking for inttypes.h... yes
checking for stdint.h... yes
checking for unistd.h... yes
checking fenv.h usability... yes
checking fenv.h presence... yes
checking for fenv.h... yes
checking float.h usability... yes
checking float.h presence... yes
checking for float.h... yes
checking fpu_control.h usability... yes
checking fpu_control.h presence... yes
checking for fpu_control.h... yes
checking for log in -lm... yes
checking whether byte ordering is bigendian... no
checking for long double with more range or precision than double... yes
checking size of int... 4
checking that generated files are newer than configure... done
configure: creating ./config.status
config.status: creating Makefile
config.status: creating scs_lib/Makefile
config.status: creating crlibm_config.h
config.status: executing depfiles commands
 [MKOCTFILE] mpfr_function_d.cc
g++ -c -Wdate-time -D_FORTIFY_SOURCE=2 -fPIC -I/usr/include/octave-5.2.0/octave/.. -I/usr/include/octave-5.2.0/octave  -pthread -fopenmp -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security    mpfr_function_d.cc -o /tmp/oct-f29wma.o
g++ -I/usr/include/octave-5.2.0/octave/.. -I/usr/include/octave-5.2.0/octave  -pthread -fopenmp -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security -shared -Wl,-Bsymbolic -Wl,-z,relro  -Wno-unknown-pragmas -o __setround__.oct  /tmp/oct-7Hafj0.o    -L/usr/lib/x86_64-linux-gnu  -Wl,-z,relro 
 [MKOCTFILE] mpfr_linspace_d.cc
g++ -c -Wdate-time -D_FORTIFY_SOURCE=2 -fPIC -I/usr/include/octave-5.2.0/octave/.. -I/usr/include/octave-5.2.0/octave  -pthread -fopenmp -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security    mpfr_linspace_d.cc -o /tmp/oct-TaFKpL.o
 [MKOCTFILE] mpfr_matrix_mul_d.cc
g++ -c -Wdate-time -D_FORTIFY_SOURCE=2 -fPIC -I/usr/include/octave-5.2.0/octave/.. -I/usr/include/octave-5.2.0/octave  -pthread -fopenmp -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security  -fopenmp   mpfr_matrix_mul_d.cc -o /tmp/oct-DfXhda.o
g++ -I/usr/include/octave-5.2.0/octave/.. -I/usr/include/octave-5.2.0/octave  -pthread -fopenmp -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security -shared -Wl,-Bsymbolic -Wl,-z,relro  -o intervaltotext.oct  /tmp/oct-FaOYRJ.o   -lmpfr  -L/usr/lib/x86_64-linux-gnu  -Wl,-z,relro 
 [MKOCTFILE] mpfr_matrix_sqr_d.cc
g++ -c -Wdate-time -D_FORTIFY_SOURCE=2 -fPIC -I/usr/include/octave-5.2.0/octave/.. -I/usr/include/octave-5.2.0/octave  -pthread -fopenmp -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security  -fopenmp   mpfr_matrix_sqr_d.cc -o /tmp/oct-ZttRRI.o
mpfr_function_d.cc:220:7: warning: 'mpfr_root' is deprecated [-Wdeprecated-declarations]
      mpfr_root (mp, mp, static_cast <uint64_t> (arg2.elem(i)), rnd);
      ^
/usr/include/mpfr.h:725:1: note: 'mpfr_root' has been explicitly marked deprecated here
MPFR_DEPRECATED
^
/usr/include/mpfr.h:347:42: note: expanded from macro 'MPFR_DEPRECATED'
# define MPFR_DEPRECATED __attribute__ ((__deprecated__))
                                         ^
g++ -I/usr/include/octave-5.2.0/octave/.. -I/usr/include/octave-5.2.0/octave  -pthread -fopenmp -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security -shared -Wl,-Bsymbolic -Wl,-z,relro  -o mpfr_linspace_d.oct  /tmp/oct-TaFKpL.o   -lmpfr  -L/usr/lib/x86_64-linux-gnu  -Wl,-z,relro 
 [MKOCTFILE] mpfr_to_string_d.cc
g++ -c -Wdate-time -D_FORTIFY_SOURCE=2 -fPIC -I/usr/include/octave-5.2.0/octave/.. -I/usr/include/octave-5.2.0/octave  -pthread -fopenmp -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security    mpfr_to_string_d.cc -o /tmp/oct-quz8Te.o
g++ -I/usr/include/octave-5.2.0/octave/.. -I/usr/include/octave-5.2.0/octave  -pthread -fopenmp -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security -shared -Wl,-Bsymbolic -Wl,-z,relro  -fopenmp -o mpfr_matrix_mul_d.oct  /tmp/oct-DfXhda.o   -lmpfr  -L/usr/lib/x86_64-linux-gnu  -Wl,-z,relro 
1 warning generated.
g++ -I/usr/include/octave-5.2.0/octave/.. -I/usr/include/octave-5.2.0/octave  -pthread -fopenmp -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security -shared -Wl,-Bsymbolic -Wl,-z,relro  -o mpfr_function_d.oct  /tmp/oct-f29wma.o   -lmpfr  -L/usr/lib/x86_64-linux-gnu  -Wl,-z,relro 
 [MKOCTFILE] mpfr_vector_sum_d.cc
g++ -c -Wdate-time -D_FORTIFY_SOURCE=2 -fPIC -I/usr/include/octave-5.2.0/octave/.. -I/usr/include/octave-5.2.0/octave  -pthread -fopenmp -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security    mpfr_vector_sum_d.cc -o /tmp/oct-5nQa1T.o
 [MKOCTFILE] mpfr_vector_dot_d.cc
g++ -c -Wdate-time -D_FORTIFY_SOURCE=2 -fPIC -I/usr/include/octave-5.2.0/octave/.. -I/usr/include/octave-5.2.0/octave  -pthread -fopenmp -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security    mpfr_vector_dot_d.cc -o /tmp/oct-UDsAUf.o
g++ -I/usr/include/octave-5.2.0/octave/.. -I/usr/include/octave-5.2.0/octave  -pthread -fopenmp -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security -shared -Wl,-Bsymbolic -Wl,-z,relro  -fopenmp -o mpfr_matrix_sqr_d.oct  /tmp/oct-ZttRRI.o   -lmpfr  -L/usr/lib/x86_64-linux-gnu  -Wl,-z,relro 
make -C crlibm CFLAGS+="-fPIC -Wno-div-by-zero -Wno-unused-variable -Wno-unused-but-set-variable"
make[3]: Entering directory '/<<PKGBUILDDIR>>/src/crlibm'
(CDPATH="${ZSH_VERSION+.}:" && cd . && /bin/bash /<<PKGBUILDDIR>>/src/crlibm/missing autoheader)
rm -f stamp-h1
touch crlibm_config.h.in
cd . && /bin/bash ./config.status crlibm_config.h
config.status: creating crlibm_config.h
config.status: crlibm_config.h is unchanged
make  all-recursive
make[4]: Entering directory '/<<PKGBUILDDIR>>/src/crlibm'
Making all in scs_lib
make[5]: Entering directory '/<<PKGBUILDDIR>>/src/crlibm/scs_lib'
gcc -DHAVE_CONFIG_H -I. -I..  -I.. -Wdate-time -D_FORTIFY_SOURCE=2  -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security -fPIC -Wno-div-by-zero -Wno-unused-variable -Wno-unused-but-set-variable -c -o scs_private.o scs_private.c
warning: unknown warning option '-Wno-unused-but-set-variable'; did you mean '-Wno-unused-const-variable'? [-Wunknown-warning-option]
1 warning generated.
gcc -DHAVE_CONFIG_H -I. -I..  -I.. -Wdate-time -D_FORTIFY_SOURCE=2  -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security -fPIC -Wno-div-by-zero -Wno-unused-variable -Wno-unused-but-set-variable -c -o double2scs.o double2scs.c
warning: unknown warning option '-Wno-unused-but-set-variable'; did you mean '-Wno-unused-const-variable'? [-Wunknown-warning-option]
1 warning generated.
gcc -DHAVE_CONFIG_H -I. -I..  -I.. -Wdate-time -D_FORTIFY_SOURCE=2  -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security -fPIC -Wno-div-by-zero -Wno-unused-variable -Wno-unused-but-set-variable -c -o print_scs.o print_scs.c
warning: unknown warning option '-Wno-unused-but-set-variable'; did you mean '-Wno-unused-const-variable'? [-Wunknown-warning-option]
1 warning generated.
gcc -DHAVE_CONFIG_H -I. -I..  -I.. -Wdate-time -D_FORTIFY_SOURCE=2  -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security -fPIC -Wno-div-by-zero -Wno-unused-variable -Wno-unused-but-set-variable -c -o division_scs.o division_scs.c
warning: unknown warning option '-Wno-unused-but-set-variable'; did you mean '-Wno-unused-const-variable'? [-Wunknown-warning-option]
1 warning generated.
gcc -DHAVE_CONFIG_H -I. -I..  -I.. -Wdate-time -D_FORTIFY_SOURCE=2  -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security -fPIC -Wno-div-by-zero -Wno-unused-variable -Wno-unused-but-set-variable -c -o addition_scs.o addition_scs.c
warning: unknown warning option '-Wno-unused-but-set-variable'; did you mean '-Wno-unused-const-variable'? [-Wunknown-warning-option]
1 warning generated.
gcc -DHAVE_CONFIG_H -I. -I..  -I.. -Wdate-time -D_FORTIFY_SOURCE=2  -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security -fPIC -Wno-div-by-zero -Wno-unused-variable -Wno-unused-but-set-variable -c -o multiplication_scs.o multiplication_scs.c
warning: unknown warning option '-Wno-unused-but-set-variable'; did you mean '-Wno-unused-const-variable'? [-Wunknown-warning-option]
1 warning generated.
gcc -DHAVE_CONFIG_H -I. -I..  -I.. -Wdate-time -D_FORTIFY_SOURCE=2  -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security -fPIC -Wno-div-by-zero -Wno-unused-variable -Wno-unused-but-set-variable -c -o scs2double.o scs2double.c
warning: unknown warning option '-Wno-unused-but-set-variable'; did you mean '-Wno-unused-const-variable'? [-Wunknown-warning-option]
1 warning generated.
gcc -DHAVE_CONFIG_H -I. -I..  -I.. -Wdate-time -D_FORTIFY_SOURCE=2  -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security -fPIC -Wno-div-by-zero -Wno-unused-variable -Wno-unused-but-set-variable -c -o zero_scs.o zero_scs.c
warning: unknown warning option '-Wno-unused-but-set-variable'; did you mean '-Wno-unused-const-variable'? [-Wunknown-warning-option]
1 warning generated.
gcc -DHAVE_CONFIG_H -I. -I..  -I.. -Wdate-time -D_FORTIFY_SOURCE=2  -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security -fPIC -Wno-div-by-zero -Wno-unused-variable -Wno-unused-but-set-variable -c -o scs2mpfr.o scs2mpfr.c
warning: unknown warning option '-Wno-unused-but-set-variable'; did you mean '-Wno-unused-const-variable'? [-Wunknown-warning-option]
1 warning generated.
rm -f libscs.a
ar cr libscs.a scs_private.o double2scs.o print_scs.o division_scs.o addition_scs.o multiplication_scs.o scs2double.o zero_scs.o scs2mpfr.o 
ranlib libscs.a
make[5]: Leaving directory '/<<PKGBUILDDIR>>/src/crlibm/scs_lib'
Making all in .
make[5]: Entering directory '/<<PKGBUILDDIR>>/src/crlibm'
gcc -DHAVE_CONFIG_H -I.   -Wdate-time -D_FORTIFY_SOURCE=2 -std=c99 -Wall -msse2 -mfpmath=sse  -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security -fPIC -Wno-div-by-zero -Wno-unused-variable -Wno-unused-but-set-variable -c -o crlibm_private.o crlibm_private.c
warning: unknown warning option '-Wno-unused-but-set-variable'; did you mean '-Wno-unused-const-variable'? [-Wunknown-warning-option]
1 warning generated.
gcc -DHAVE_CONFIG_H -I.   -Wdate-time -D_FORTIFY_SOURCE=2 -std=c99 -Wall -msse2 -mfpmath=sse  -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security -fPIC -Wno-div-by-zero -Wno-unused-variable -Wno-unused-but-set-variable -c -o triple-double.o triple-double.c
warning: unknown warning option '-Wno-unused-but-set-variable'; did you mean '-Wno-unused-const-variable'? [-Wunknown-warning-option]
1 warning generated.
gcc -DHAVE_CONFIG_H -I.   -Wdate-time -D_FORTIFY_SOURCE=2 -std=c99 -Wall -msse2 -mfpmath=sse  -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security -fPIC -Wno-div-by-zero -Wno-unused-variable -Wno-unused-but-set-variable -c -o exp-td.o exp-td.c
warning: unknown warning option '-Wno-unused-but-set-variable'; did you mean '-Wno-unused-const-variable'? [-Wunknown-warning-option]
1 warning generated.
gcc -DHAVE_CONFIG_H -I.   -Wdate-time -D_FORTIFY_SOURCE=2 -std=c99 -Wall -msse2 -mfpmath=sse  -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security -fPIC -Wno-div-by-zero -Wno-unused-variable -Wno-unused-but-set-variable -c -o exp-td-standalone.o exp-td-standalone.c
warning: unknown warning option '-Wno-unused-but-set-variable'; did you mean '-Wno-unused-const-variable'? [-Wunknown-warning-option]
1 warning generated.
gcc -DHAVE_CONFIG_H -I.   -Wdate-time -D_FORTIFY_SOURCE=2 -std=c99 -Wall -msse2 -mfpmath=sse  -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security -fPIC -Wno-div-by-zero -Wno-unused-variable -Wno-unused-but-set-variable -c -o expm1-standalone.o expm1-standalone.c
warning: unknown warning option '-Wno-unused-but-set-variable'; did you mean '-Wno-unused-const-variable'? [-Wunknown-warning-option]
1 warning generated.
gcc -DHAVE_CONFIG_H -I.   -Wdate-time -D_FORTIFY_SOURCE=2 -std=c99 -Wall -msse2 -mfpmath=sse  -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security -fPIC -Wno-div-by-zero -Wno-unused-variable -Wno-unused-but-set-variable -c -o expm1.o expm1.c
warning: unknown warning option '-Wno-unused-but-set-variable'; did you mean '-Wno-unused-const-variable'? [-Wunknown-warning-option]
g++ -I/usr/include/octave-5.2.0/octave/.. -I/usr/include/octave-5.2.0/octave  -pthread -fopenmp -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security -shared -Wl,-Bsymbolic -Wl,-z,relro  -o mpfr_vector_sum_d.oct  /tmp/oct-5nQa1T.o   -lmpfr  -L/usr/lib/x86_64-linux-gnu  -Wl,-z,relro 
gcc -DHAVE_CONFIG_H -I.   -Wdate-time -D_FORTIFY_SOURCE=2 -std=c99 -Wall -msse2 -mfpmath=sse  -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security -fPIC -Wno-div-by-zero -Wno-unused-variable -Wno-unused-but-set-variable -c -o log-de.o log-de.c
1 warning generated.
gcc -DHAVE_CONFIG_H -I.   -Wdate-time -D_FORTIFY_SOURCE=2 -std=c99 -Wall -msse2 -mfpmath=sse  -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security -fPIC -Wno-div-by-zero -Wno-unused-variable -Wno-unused-but-set-variable -c -o log1p.o log1p.c
warning: unknown warning option '-Wno-unused-but-set-variable'; did you mean '-Wno-unused-const-variable'? [-Wunknown-warning-option]
warning: unknown warning option '-Wno-unused-but-set-variable'; did you mean '-Wno-unused-const-variable'? [-Wunknown-warning-option]
log1p.c:213:8: warning: variable 'E' is used uninitialized whenever 'if' condition is true [-Wsometimes-uninitialized]
   if ((xdb.i[HI] & 0x7fffffff) < 0x3f700000) {
       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
log1p.c:424:7: note: uninitialized use occurs here
   if(E==0)
      ^
log1p.c:213:4: note: remove the 'if' if its condition is always false
   if ((xdb.i[HI] & 0x7fffffff) < 0x3f700000) {
   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
log1p.c:176:9: note: initialize the variable 'E' to silence this warning
   int E, index;
        ^
         = 0
log1p.c:501:8: warning: variable 'E' is used uninitialized whenever 'if' condition is true [-Wsometimes-uninitialized]
   if ((xdb.i[HI] & 0x7fffffff) < 0x3f700000) {
       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
log1p.c:712:7: note: uninitialized use occurs here
   if(E==0)
      ^
log1p.c:501:4: note: remove the 'if' if its condition is always false
   if ((xdb.i[HI] & 0x7fffffff) < 0x3f700000) {
   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
log1p.c:455:9: note: initialize the variable 'E' to silence this warning
   int E, index;
        ^
         = 0
log1p.c:788:8: warning: variable 'E' is used uninitialized whenever 'if' condition is true [-Wsometimes-uninitialized]
   if ((xdb.i[HI] & 0x7fffffff) < 0x3f700000) {
       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
log1p.c:999:7: note: uninitialized use occurs here
   if(E==0)
      ^
log1p.c:788:4: note: remove the 'if' if its condition is always false
   if ((xdb.i[HI] & 0x7fffffff) < 0x3f700000) {
   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
log1p.c:734:9: note: initialize the variable 'E' to silence this warning
   int E, index;
        ^
         = 0
log1p.c:1075:8: warning: variable 'E' is used uninitialized whenever 'if' condition is true [-Wsometimes-uninitialized]
   if ((xdb.i[HI] & 0x7fffffff) < 0x3f700000) {
       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
log1p.c:1286:7: note: uninitialized use occurs here
   if(E==0)
      ^
log1p.c:1075:4: note: remove the 'if' if its condition is always false
   if ((xdb.i[HI] & 0x7fffffff) < 0x3f700000) {
   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
log1p.c:1021:9: note: initialize the variable 'E' to silence this warning
   int E, index;
        ^
         = 0
1 warning generated.
gcc -DHAVE_CONFIG_H -I.   -Wdate-time -D_FORTIFY_SOURCE=2 -std=c99 -Wall -msse2 -mfpmath=sse  -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security -fPIC -Wno-div-by-zero -Wno-unused-variable -Wno-unused-but-set-variable -c -o log10-td.o log10-td.c
warning: unknown warning option '-Wno-unused-but-set-variable'; did you mean '-Wno-unused-const-variable'? [-Wunknown-warning-option]
5 warnings generated.
gcc -DHAVE_CONFIG_H -I.   -Wdate-time -D_FORTIFY_SOURCE=2 -std=c99 -Wall -msse2 -mfpmath=sse  -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security -fPIC -Wno-div-by-zero -Wno-unused-variable -Wno-unused-but-set-variable -c -o log2-td.o log2-td.c
warning: unknown warning option '-Wno-unused-but-set-variable'; did you mean '-Wno-unused-const-variable'? [-Wunknown-warning-option]
1 warning generated.
gcc -DHAVE_CONFIG_H -I.   -Wdate-time -D_FORTIFY_SOURCE=2 -std=c99 -Wall -msse2 -mfpmath=sse  -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security -fPIC -Wno-div-by-zero -Wno-unused-variable -Wno-unused-but-set-variable -c -o rem_pio2_accurate.o rem_pio2_accurate.c
warning: unknown warning option '-Wno-unused-but-set-variable'; did you mean '-Wno-unused-const-variable'? [-Wunknown-warning-option]
rem_pio2_accurate.c:98:14: warning: equality comparison with extraneous parentheses [-Wparentheses-equality]
  if ((X_IND == -1)){
       ~~~~~~^~~~~
rem_pio2_accurate.c:98:14: note: remove extraneous parentheses around the comparison to silence this warning
  if ((X_IND == -1)){
      ~      ^    ~
rem_pio2_accurate.c:98:14: note: use '=' to turn this equality comparison into an assignment
  if ((X_IND == -1)){
             ^~
             =
2 warnings generated.
1 warning generated.
gcc -DHAVE_CONFIG_H -I.   -Wdate-time -D_FORTIFY_SOURCE=2 -std=c99 -Wall -msse2 -mfpmath=sse  -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security -fPIC -Wno-div-by-zero -Wno-unused-variable -Wno-unused-but-set-variable -c -o trigo_fast.o trigo_fast.c
gcc -DHAVE_CONFIG_H -I.   -Wdate-time -D_FORTIFY_SOURCE=2 -std=c99 -Wall -msse2 -mfpmath=sse  -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security -fPIC -Wno-div-by-zero -Wno-unused-variable -Wno-unused-but-set-variable -c -o trigo_accurate.o trigo_accurate.c
warningwarning: unknown warning option '-Wno-unused-but-set-variable'; did you mean '-Wno-unused-const-variable'? [-Wunknown-warning-option]
: unknown warning option '-Wno-unused-but-set-variable'; did you mean '-Wno-unused-const-variable'? [-Wunknown-warning-option]
trigo_fast.c:181:14: warning: equality comparison with extraneous parentheses [-Wparentheses-equality]
  if ((X_IND == -2)){
       ~~~~~~^~~~~
trigo_fast.c:181:14: note: remove extraneous parentheses around the comparison to silence this warning
  if ((X_IND == -2)){
      ~      ^    ~
trigo_fast.c:181:14: note: use '=' to turn this equality comparison into an assignment
  if ((X_IND == -2)){
             ^~
             =
trigo_fast.c:423:15: warning: equality comparison with extraneous parentheses [-Wparentheses-equality]
    if((index == 0)) { 
        ~~~~~~^~~~
trigo_fast.c:423:15: note: remove extraneous parentheses around the comparison to silence this warning
    if((index == 0)) { 
       ~      ^   ~
trigo_fast.c:423:15: note: use '=' to turn this equality comparison into an assignment
    if((index == 0)) { 
              ^~
              =
1 warning generated.
gcc -DHAVE_CONFIG_H -I.   -Wdate-time -D_FORTIFY_SOURCE=2 -std=c99 -Wall -msse2 -mfpmath=sse  -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security -fPIC -Wno-div-by-zero -Wno-unused-variable -Wno-unused-but-set-variable -c -o trigpi.o trigpi.c
warning: unknown warning option '-Wno-unused-but-set-variable'; did you mean '-Wno-unused-const-variable'? [-Wunknown-warning-option]
g++ -I/usr/include/octave-5.2.0/octave/.. -I/usr/include/octave-5.2.0/octave  -pthread -fopenmp -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security -shared -Wl,-Bsymbolic -Wl,-z,relro  -o mpfr_vector_dot_d.oct  /tmp/oct-UDsAUf.o   -lmpfr  -L/usr/lib/x86_64-linux-gnu  -Wl,-z,relro 
gcc -DHAVE_CONFIG_H -I.   -Wdate-time -D_FORTIFY_SOURCE=2 -std=c99 -Wall -msse2 -mfpmath=sse  -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security -fPIC -Wno-div-by-zero -Wno-unused-variable -Wno-unused-but-set-variable -c -o asincos.o asincos.c
warning: unknown warning option '-Wno-unused-but-set-variable'; did you mean '-Wno-unused-const-variable'? [-Wunknown-warning-option]
3 warnings generated.
gcc -DHAVE_CONFIG_H -I.   -Wdate-time -D_FORTIFY_SOURCE=2 -std=c99 -Wall -msse2 -mfpmath=sse  -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security -fPIC -Wno-div-by-zero -Wno-unused-variable -Wno-unused-but-set-variable -c -o pow.o pow.c
warning: unknown warning option '-Wno-unused-but-set-variable'; did you mean '-Wno-unused-const-variable'? [-Wunknown-warning-option]
g++ -I/usr/include/octave-5.2.0/octave/.. -I/usr/include/octave-5.2.0/octave  -pthread -fopenmp -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security -shared -Wl,-Bsymbolic -Wl,-z,relro  -o mpfr_to_string_d.oct  /tmp/oct-quz8Te.o   -lmpfr  -L/usr/lib/x86_64-linux-gnu  -Wl,-z,relro 
gcc -DHAVE_CONFIG_H -I.   -Wdate-time -D_FORTIFY_SOURCE=2 -std=c99 -Wall -msse2 -mfpmath=sse  -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security -fPIC -Wno-div-by-zero -Wno-unused-variable -Wno-unused-but-set-variable -c -o atan_fast.o atan_fast.c
warning: unknown warning option '-Wno-unused-but-set-variable'; did you mean '-Wno-unused-const-variable'? [-Wunknown-warning-option]
1 warning generated.
gcc -DHAVE_CONFIG_H -I.   -Wdate-time -D_FORTIFY_SOURCE=2 -std=c99 -Wall -msse2 -mfpmath=sse  -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security -fPIC -Wno-div-by-zero -Wno-unused-variable -Wno-unused-but-set-variable -c -o atan_accurate.o atan_accurate.c
warning: unknown warning option '-Wno-unused-but-set-variable'; did you mean '-Wno-unused-const-variable'? [-Wunknown-warning-option]
1 warning generated.
gcc -DHAVE_CONFIG_H -I.   -Wdate-time -D_FORTIFY_SOURCE=2 -std=c99 -Wall -msse2 -mfpmath=sse  -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security -fPIC -Wno-div-by-zero -Wno-unused-variable -Wno-unused-but-set-variable -c -o csh_fast.o csh_fast.c
warning: unknown warning option '-Wno-unused-but-set-variable'; did you mean '-Wno-unused-const-variable'? [-Wunknown-warning-option]
1 warning generated.
1 warning generated.
1 warning generated.
1 warning generated.
rm -f libcrlibm.a
ar cr libcrlibm.a crlibm_private.o triple-double.o exp-td.o exp-td-standalone.o expm1-standalone.o expm1.o log-de.o log1p.o log10-td.o log2-td.o rem_pio2_accurate.o trigo_fast.o trigo_accurate.o trigpi.o asincos.o pow.o atan_fast.o atan_accurate.o csh_fast.o scs_lib/scs_private.o scs_lib/addition_scs.o scs_lib/division_scs.o scs_lib/print_scs.o scs_lib/double2scs.o scs_lib/zero_scs.o scs_lib/multiplication_scs.o scs_lib/scs2double.o
ranlib libcrlibm.a
make[5]: Leaving directory '/<<PKGBUILDDIR>>/src/crlibm'
make[4]: Leaving directory '/<<PKGBUILDDIR>>/src/crlibm'
make[3]: Leaving directory '/<<PKGBUILDDIR>>/src/crlibm'
 [MKOCTFILE] crlibm_function.o
g++ -I/usr/include/octave-5.2.0/octave/.. -I/usr/include/octave-5.2.0/octave  -pthread -fopenmp -g -O2 -fdebug-prefix-map=/<<PKGBUILDDIR>>=. -fstack-protector-strong -Wformat -Werror=format-security -shared -Wl,-Bsymbolic -Wl,-z,relro  -o crlibm_function.oct  crlibm_function.o crlibm/asincos.o crlibm/atan_accurate.o crlibm/atan_fast.o crlibm/crlibm_private.o crlibm/csh_fast.o crlibm/exp-td-standalone.o crlibm/exp-td.o crlibm/expm1-standalone.o crlibm/expm1.o crlibm/log-de.o crlibm/log10-td.o crlibm/log1p.o crlibm/log2-td.o crlibm/pow.o crlibm/rem_pio2_accurate.o crlibm/trigo_accurate.o crlibm/trigo_fast.o crlibm/trigpi.o crlibm/triple-double.o crlibm/scs_lib/addition_scs.o crlibm/scs_lib/division_scs.o crlibm/scs_lib/double2scs.o crlibm/scs_lib/multiplication_scs.o crlibm/scs_lib/print_scs.o crlibm/scs_lib/scs2double.o crlibm/scs_lib/scs2mpfr.o crlibm/scs_lib/scs_private.o crlibm/scs_lib/zero_scs.o    -L/usr/lib/x86_64-linux-gnu  -Wl,-z,relro 
make[2]: Leaving directory '/<<PKGBUILDDIR>>/src'
copyfile /<<PKGBUILDDIR>>/./src/__setround__.oct /<<PKGBUILDDIR>>/./src/crlibm_function.oct /<<PKGBUILDDIR>>/./src/intervaltotext.oct /<<PKGBUILDDIR>>/./src/mpfr_function_d.oct /<<PKGBUILDDIR>>/./src/mpfr_linspace_d.oct /<<PKGBUILDDIR>>/./src/mpfr_matrix_mul_d.oct /<<PKGBUILDDIR>>/./src/mpfr_matrix_sqr_d.oct /<<PKGBUILDDIR>>/./src/mpfr_to_string_d.oct /<<PKGBUILDDIR>>/./src/mpfr_vector_dot_d.oct /<<PKGBUILDDIR>>/./src/mpfr_vector_sum_d.oct /<<PKGBUILDDIR>>/./inst/x86_64-pc-linux-gnu-api-v53
For information about changes from previous versions of the interval package, run 'news interval'.
chmod: cannot access 'debian/*/usr/lib/*/octave/packages/*/*/*.mex': No such file or directory
# The documentation build needs to load the package,
# so we have to set paths for the build process.
OCTAVE='octave --no-window-system --no-init-file'	\
	make -C doc manual.html
make[2]: Entering directory '/<<PKGBUILDDIR>>/doc'
 [OCTAVE] image/interval-sombrero.m
warning: crlibm is not working properly, using MPFR as a fallback
warning: called from
    __check_crlibm__>verify_crlibm at line 56 column 5
    __check_crlibm__ at line 33 column 3
    sin at line 57 column 3
    sin at line 45 column 10
    image/interval-sombrero.m at line 19 column 3
 [IMAGEMAGICK] image/interval-sombrero.m.png
 [OCTAVE] image/poly-example-surf.m
 [IMAGEMAGICK] image/poly-example-surf.m.png
 [MAKEINFO --plaintext] image/cameleon.m.texinfo
 [OCTAVE] image/cameleon.m
warning: crlibm is not working properly, using MPFR as a fallback
warning: called from
    __check_crlibm__>verify_crlibm at line 56 column 5
    __check_crlibm__ at line 33 column 3
    sin at line 57 column 3
    check_parameters at line 34 column 10
    fsolve>vectorized at line 456 column 12
    fsolve at line 254 column 34
    image/cameleon.m at line 48 column 25
 [IMAGEMAGICK] image/cameleon.m.png
 [MAKEINFO --plaintext] image/contractor-rings-intersect.m.texinfo
 [OCTAVE] image/contractor-rings-intersect.m
 [IMAGEMAGICK] image/contractor-rings-intersect.m.png
 [MAKEINFO --plaintext] image/contractor-rings-union.m.texinfo
 [OCTAVE] image/contractor-rings-union.m
 [IMAGEMAGICK] image/contractor-rings-union.m.png
 [MAKEINFO --plaintext] image/interval-plot3.m.texinfo
 [OCTAVE] image/interval-plot3.m
 [IMAGEMAGICK] image/interval-plot3.m.png
 [MAKEINFO --plaintext] image/interval-vs-normal-plot.m.texinfo
 [OCTAVE] image/interval-vs-normal-plot.m
warning: crlibm is not working properly, using MPFR as a fallback
warning: called from
    __check_crlibm__>verify_crlibm at line 56 column 5
    __check_crlibm__ at line 33 column 3
    sin at line 57 column 3
    image/interval-vs-normal-plot.m at line 6 column 6
 [IMAGEMAGICK] image/interval-vs-normal-plot.m.png
 [MAKEINFO --plaintext] image/poly-example-roots-simple.m.texinfo
 [OCTAVE] image/poly-example-roots-simple.m
 [IMAGEMAGICK] image/poly-example-roots-simple.m.png
convert-im6.q16: profile 'icc': 'RGB ': RGB color space not permitted on grayscale PNG `image/poly-example-roots-simple.m.png' @ warning/png.c/MagickPNGWarningHandler/1668.
 [MAKEINFO --plaintext] image/poly-example-roots-with-deriv.m.texinfo
 [OCTAVE] image/poly-example-roots-with-deriv.m
 [IMAGEMAGICK] image/poly-example-roots-with-deriv.m.png
convert-im6.q16: profile 'icc': 'RGB ': RGB color space not permitted on grayscale PNG `image/poly-example-roots-with-deriv.m.png' @ warning/png.c/MagickPNGWarningHandler/1668.
grep: ../packinfo/DESCRIPTION: No such file or directory
 [MAKEINFO --html] manual.texinfo
rm image/poly-example-roots-with-deriv.m image/interval-vs-normal-plot.m image/poly-example-roots-simple.m image/contractor-rings-intersect.m image/contractor-rings-union.m image/cameleon.m image/interval-plot3.m
make[2]: Leaving directory '/<<PKGBUILDDIR>>/doc'
# dh_installdocs does not support subdirectories,
# so we move everything in place
mkdir -p /<<PKGBUILDDIR>>/debian/octave-interval-doc/usr/share/doc/octave-interval/image
cp doc/manual.html /<<PKGBUILDDIR>>/debian/octave-interval-doc/usr/share/doc/octave-interval/
cp doc/image/*.png doc/image/*.svg /<<PKGBUILDDIR>>/debian/octave-interval-doc/usr/share/doc/octave-interval/image/
rm -rf \
	 /<<PKGBUILDDIR>>/debian/octave-interval//*/doc
make[1]: Leaving directory '/<<PKGBUILDDIR>>'
   dh_auto_install -O--buildsystem=octave -Noctave-interval-doc
	octave --no-gui --no-history --silent --no-init-file --no-window-system /usr/share/dh-octave/install-pkg.m
checking whether the C++ compiler works... yes
checking for C++ compiler default output file name... a.out
checking for suffix of executables... 
checking whether we are cross compiling... no
checking for suffix of object files... o
checking whether we are using the GNU C++ compiler... yes
checking whether g++ accepts -g... yes
checking for mpfr_init2 in -lmpfr... yes
checking for floor in -lm... yes
checking how to run the C++ preprocessor... g++ -E
checking for grep that handles long lines and -e... /bin/grep
checking for egrep... /bin/grep -E
checking for ANSI C header files... yes
checking for sys/types.h... yes
checking for sys/stat.h... yes
checking for stdlib.h... yes
checking for string.h... yes
checking for memory.h... yes
checking for strings.h... yes
checking for inttypes.h... yes
checking for stdint.h... yes
checking for unistd.h... yes
checking sstream usability... yes
checking sstream presence... yes
checking for sstream... yes
checking fenv.h usability... yes
checking fenv.h presence... yes
checking for fenv.h... yes
checking mpfr.h usability... yes
checking mpfr.h presence... yes
checking for mpfr.h... yes
checking for int32_t... yes
checking for uint32_t... yes
checking for uint64_t... yes
checking for uint8_t... yes
checking for error_at_line... yes
checking for fesetround... yes
make[1]: Entering directory '/<<PKGBUILDDIR>>/src'
make[1]: Nothing to be done for 'all'.
make[1]: Leaving directory '/<<PKGBUILDDIR>>/src'
copyfile /<<PKGBUILDDIR>>/./src/__setround__.oct /<<PKGBUILDDIR>>/./src/crlibm_function.oct /<<PKGBUILDDIR>>/./src/intervaltotext.oct /<<PKGBUILDDIR>>/./src/mpfr_function_d.oct /<<PKGBUILDDIR>>/./src/mpfr_linspace_d.oct /<<PKGBUILDDIR>>/./src/mpfr_matrix_mul_d.oct /<<PKGBUILDDIR>>/./src/mpfr_matrix_sqr_d.oct /<<PKGBUILDDIR>>/./src/mpfr_to_string_d.oct /<<PKGBUILDDIR>>/./src/mpfr_vector_dot_d.oct /<<PKGBUILDDIR>>/./src/mpfr_vector_sum_d.oct /<<PKGBUILDDIR>>/./inst/x86_64-pc-linux-gnu-api-v53
For information about changes from previous versions of the interval package, run 'news interval'.
chmod: cannot access 'debian/*/usr/lib/*/octave/packages/*/*/*.mex': No such file or directory
   dh_octave_check -O--buildsystem=octave
Checking package...
Checking m files ...
[inst/@infsup/mulrev.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/mulrev.m
***** #IEEE Std 1788-2015 mulRevToPair examples
***** test
  [u, v] = mulrev (infsup (0), infsup (1, 2));
  assert (isempty (u) & isempty (v));
***** test
  [u, v] = mulrev (infsup (0), infsup (0, 1));
  assert (isentire (u) & isempty (v));
***** test
  [u, v] = mulrev (infsup (1), infsup (1, 2));
  assert (eq (u, infsup (1, 2)) & isempty (v));
***** test
  [u, v] = mulrev (infsup (1, inf), infsup (1));
  assert (eq (u, infsup (0, 1)) & isempty (v));
***** test
  [u, v] = mulrev (infsup (-1, 1), infsup (1, 2));
  assert (eq (u, infsup (-inf, -1)) & eq (v, infsup (1, inf)));
***** test
  [u, v] = mulrev (infsup (-inf, inf), infsup (1));
  assert (eq (u, infsup (-inf, 0)) & eq (v, infsup (0, inf)));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.mulRevToPair1;
 for testcase = [testcases]'
   assert (isequaln (...
     nthargout (1, 2, @mulrev, testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.mulRevToPair1;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (nthargout (1, 2, @mulrev, in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.mulRevToPair1;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (nthargout (1, 2, @mulrev, in1, in2), out));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.mulRevToPair2;
 for testcase = [testcases]'
   assert (isequaln (...
     nthargout (2, @mulrev, testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.mulRevToPair2;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (nthargout (2, @mulrev, in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.mulRevToPair2;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (nthargout (2, @mulrev, in1, in2), out));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.mulRev;
 for testcase = [testcases]'
   assert (isequaln (...
     mulrev (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.mulRev;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (mulrev (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.mulRev;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (mulrev (in1, in2), out));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.mulRevTen;
 for testcase = [testcases]'
   assert (isequaln (...
     mulrev (testcase.in{1}, testcase.in{2}, testcase.in{3}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.mulRevTen;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 in3 = vertcat (vertcat (testcases.in){:, 3});
 out = vertcat (testcases.out);
 assert (isequaln (mulrev (in1, in2, in3), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.mulRevTen;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 in3 = vertcat (vertcat (testcases.in){:, 3});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 in3 = reshape ([in3; in3(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (mulrev (in1, in2, in3), out));
18 tests, 18 passed, 0 known failure, 0 skipped
[inst/@infsup/prepad.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/prepad.m
***** assert (prepad (infsup (2:4), 4, 1) == infsup (1:4));
***** assert (prepad (infsup (0:2), 2, 1) == infsup (1:2));
***** test
 if (compare_versions (OCTAVE_VERSION (), "4.0.0", ">="))
   assert (prepad (infsup (0), 10, 0, 3) == infsup (zeros (1, 1, 10)))
 else
   # In Octave 3.8.x it is not possible to increase the number of dimensions.
 endif
***** assert (prepad (infsup (zeros (1, 2, 2)), 3) == infsup (zeros (1, 3, 2)));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsup/numel.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/numel.m
***** assert (numel (infsup ([])), 0);
***** assert (numel (infsup (0)), 1);
***** assert (numel (infsup (zeros (3, 1))), 3);
***** assert (numel (infsup (zeros (1, 4))), 4);
***** assert (numel (infsup (zeros (3, 4))), 12);
***** assert (numel (infsup (ones (2, 3)), 3:5), 3);
***** assert (numel (infsup (ones (2, 3)), ":", 2), 2);
***** assert (numel (infsup (ones (2, 3)), 2, ":"), 3);
***** # numel is called implicitly during this subsref expression (see bug #53375)
***** assert (infsup ()(:).inf, inf);
***** error <invalid use> numel (1, infsup(1));
10 tests, 10 passed, 0 known failure, 0 skipped
[inst/@infsup/factorial.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/factorial.m
***** # from the documentation string
***** assert (factorial (infsup (6)) == 720);
***** assert (factorial (infsup (0)) == 1);
***** assert (factorial (infsup ("[0, 1.99]")) == 1);
***** assert (factorial (infsup ("[0, 2]")) == "[1, 2]");
***** assert (factorial (infsup ("[1.4, 1.6]")) == "[Empty]");
5 tests, 5 passed, 0 known failure, 0 skipped
[inst/@infsup/hdist.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/hdist.m
***** # from the documentation string
***** assert (hdist (infsup (1, 6), infsup (2, 8)), 2);
1 test, 1 passed, 0 known failure, 0 skipped
[inst/@infsup/pow2.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/pow2.m
***** # from the documentation string
 assert (pow2 (infsup (5)) == infsup (32));
***** # correct use of signed zeros
***** test
 x = pow2 (infsup (-inf, -realmax));
 assert (signbit (inf (x)));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.exp2;
 for testcase = [testcases]'
   assert (isequaln (...
     pow2 (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.exp2;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (pow2 (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.exp2;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (pow2 (in1), out));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsup/plot.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/plot.m
***** # this test is rather pointless
***** test
  clf
  plot (empty ());
  close
***** demo
  clf
  hold on
  plot (infsup (0), infsup (0));
  plot (infsup (1, 2), infsup (0));
  plot (infsup (0), infsup (1, 2));
  plot (infsup (1, 2), infsup (1, 2));
  axis ([-.5, 2.5, -.5, 2.5]);
  hold off
***** demo
  clf
  plot (infsup (-rand (50, 1), +rand (50, 1)));
***** demo
  clf
  hold on
  axis off
  range = infsup (0, 9);
  x = linspace (inf (range), sup (range), 250);
  X = mince (range, 9);
  f = @ (x) 0.5 * sin (x) .* x .^ 2;
  y = f (x);
  Y = f (X);
  plot (range, f (range), [42 161 152]/255);
  plot (X, Y, [238 232 213]/255, [88 110 117]/255);
  plot (x, y, '-', 'color', [220 50 47]/255, 'linewidth', 2);
  hold off
1 test, 1 passed, 0 known failure, 0 skipped
[inst/@infsup/ceil.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/ceil.m
***** # Empty interval
***** assert (ceil (infsup ()) == infsup ());
***** # Singleton intervals
***** assert (ceil (infsup (0)) == infsup (0));
***** assert (ceil (infsup (0.5)) == infsup (1));
***** assert (ceil (infsup (-0.5)) == infsup (0));
***** # Bounded intervals
***** assert (ceil (infsup (-0.5, 0)) == infsup (0));
***** assert (ceil (infsup (0, 0.5)) == infsup (0, 1));
***** assert (ceil (infsup (0.25, 0.5)) == infsup (1));
***** assert (ceil (infsup (-1, 0)) == infsup (-1, 0));
***** assert (ceil (infsup (-1, 1)) == infsup (-1, 1));
***** assert (ceil (infsup (-realmin, realmin)) == infsup (0, 1));
***** assert (ceil (infsup (-realmax, realmax)) == infsup (-realmax, realmax));
***** # Unbounded intervals
***** assert (ceil (infsup (-realmin, inf)) == infsup (0, inf));
***** assert (ceil (infsup (-realmax, inf)) == infsup (-realmax, inf));
***** assert (ceil (infsup (-inf, realmin)) == infsup (-inf, 1));
***** assert (ceil (infsup (-inf, realmax)) == infsup (-inf, realmax));
***** assert (ceil (infsup (-inf, inf)) == infsup (-inf, inf));
***** # from the documentation string
***** assert (ceil (infsup (2.5, 3.5)) == infsup (3, 4));
***** assert (ceil (infsup (-.5, 5)) == infsup (0, 5));
***** # correct use of signed zeros
***** test
 x = ceil (infsup (-0.5));
 assert (signbit (inf (x)));
 assert (not (signbit (sup (x))));
***** test
 x = ceil (infsup (0));
 assert (signbit (inf (x)));
 assert (not (signbit (sup (x))));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.ceil;
 for testcase = [testcases]'
   assert (isequaln (...
     ceil (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.ceil;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (ceil (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.ceil;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (ceil (in1), out));
23 tests, 23 passed, 0 known failure, 0 skipped
[inst/@infsup/mtimes.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/mtimes.m
***** # from the documentation string
***** assert (infsup ([1, 2; 7, 15], [2, 2; 7.5, 15]) * infsup ([3, 3; 0, 1], [3, 3.25; 0, 2]) == infsup ([3, 5; 21, 36], [6, 10.5; 22.5, 54.375]));
***** # matrix multiplication using BLAS routines
***** assert (mtimes (infsup ([1, 2; 7, 15], [2, 2; 7.5, 15]), infsup ([3, 3; 0, 1], [3, 3.25; 0, 2]), 'valid') == infsup ([3, 5; 21, 36], [6, 10.5; 22.5, 54.375]));
2 tests, 2 passed, 0 known failure, 0 skipped
[inst/@infsup/sprintf.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/sprintf.m
***** assert (sprintf ("%g", infsup ("pi")), "3.14159 3.1416");
1 test, 1 passed, 0 known failure, 0 skipped
[inst/@infsup/cosrev.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/cosrev.m
***** # from the documentation string
***** assert (cosrev (0, infsup (6, 9)) == "[0x1.F6A7A2955385Ep2, 0x1.F6A7A2955386p2]");
warning: crlibm is not working properly, using MPFR as a fallback
***** # correct use of signed zeros
***** test
 x = cosrev (infsup (1), infsup (0));
 assert (signbit (inf (x)));
 assert (not (signbit (sup (x))));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.cosRev;
 for testcase = [testcases]'
   assert (isequaln (...
     cosrev (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.cosRev;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (cosrev (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.cosRev;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (cosrev (in1), out));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.cosRevBin;
 for testcase = [testcases]'
   assert (isequaln (...
     cosrev (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.cosRevBin;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (cosrev (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.cosRevBin;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (cosrev (in1, in2), out));
8 tests, 8 passed, 0 known failure, 0 skipped
[inst/@infsup/tanrev.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/tanrev.m
***** # from the documentation string
***** assert (tanrev (infsup (0), infsup (2, 4)) == infsup ("pi"));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.tanRev;
 for testcase = [testcases]'
   assert (isequaln (...
     tanrev (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.tanRev;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (tanrev (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.tanRev;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (tanrev (in1), out));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.tanRevBin;
 for testcase = [testcases]'
   assert (isequaln (...
     tanrev (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.tanRevBin;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (tanrev (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.tanRevBin;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (tanrev (in1, in2), out));
7 tests, 7 passed, 0 known failure, 0 skipped
[inst/@infsup/dilog.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/dilog.m
***** assert (dilog (infsup (-inf, inf)) == "[-Inf, +0x1.3BD3CC9BE45DFp1]");
***** # from the documentation string
***** assert (dilog (infsup (1)) == "[0x1.A51A6625307D3, 0x1.A51A6625307D4]");
2 tests, 2 passed, 0 known failure, 0 skipped
[inst/@infsup/newdec.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/newdec.m
***** # from the documentation string
***** assert (isequal (newdec (infsup (2, 3)), infsupdec (2, 3)));
***** assert (isequal (newdec (infsupdec (2, 3)), infsupdec (2, 3)));
***** assert (isequal (newdec (infsupdec (1, "trv")), infsupdec (1, "trv")));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.newDec;
 for testcase = [testcases]'
   assert (isequaln (...
     newdec (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.newDec;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (newdec (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.newDec;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (newdec (in1), out));
6 tests, 6 passed, 0 known failure, 0 skipped
[inst/@infsup/gauss.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/gauss.m
***** # from the documentation string
***** assert (gauss (infsup ([1, 0; 0, 2]), [2, 0; 0, 4]) == [2, 0; 0, 2]);
1 test, 1 passed, 0 known failure, 0 skipped
[inst/@infsup/horzcat.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/horzcat.m
***** assert (horzcat (infsup (1), infsup (2)) == infsup (horzcat (1, 2)));
***** test
 # from the documentation string
 a = infsup (2, 5);
 assert (horzcat (a, a, a) == infsup ([2, 2, 2], [5, 5, 5]));
2 tests, 2 passed, 0 known failure, 0 skipped
[inst/@infsup/polyval.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/polyval.m
***** assert (polyval (infsup (42), 0) == 42);
***** assert (polyval (infsup ([42 42]), 0) == 42);
***** assert (polyval (infsup ([42 42]), 1) == 84);
***** assert (polyval (infsup ([42 42]), -1) == 0);
***** assert (polyval (infsup ([-42 42 42]), .5) == -42*0.5^2 + 42*0.5 + 42);
***** assert (polyval (infsup (vec (pascal (3))), 0.1) == "[0X6.502E9A7231A08P+0, 0X6.502E9A7231A0CP+0]");
6 tests, 6 passed, 0 known failure, 0 skipped
[inst/@infsup/iscolumn.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/iscolumn.m
***** assert (not (iscolumn (infsup ([]))));
***** assert (iscolumn (infsup (0)));
***** assert (not (iscolumn (infsup (zeros (1, 2)))));
***** assert (iscolumn (infsup (zeros (2, 1))));
***** assert (not (iscolumn (infsup (zeros (5)))));
5 tests, 5 passed, 0 known failure, 0 skipped
[inst/@infsup/fprintf.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/fprintf.m
***** test
 if (compare_versions (OCTAVE_VERSION, "4.2", ">="))
   assert (evalc ("n = fprintf ('%g', infsup ('pi'));"), "3.14159 3.1416");
   assert (n, 14);
 endif
1 test, 1 passed, 0 known failure, 0 skipped
[inst/@infsup/rdivide.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/rdivide.m
***** # from the documentation string
***** assert (infsup (2, 3) ./ infsup (1, 2) == infsup (1, 3));
***** assert (1 ./ infsup (1, 4) == infsup (0.25, 1));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.div;
 for testcase = [testcases]'
   assert (isequaln (...
     rdivide (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.div;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (rdivide (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.div;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (rdivide (in1, in2), out));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.recip;
 for testcase = [testcases]'
   assert (isequaln (...
     rdivide (1, testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.recip;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (rdivide (1, in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsupdec.recip;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (rdivide (1, in1), out));
8 tests, 8 passed, 0 known failure, 0 skipped
[inst/@infsup/display.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/display.m
***** # Test for the display function are also largely done with the help of the
***** # doctest package.
***** # evalc has been introduced in Octave 4.2
***** test
 if (compare_versions (OCTAVE_VERSION, "4.2", ">="))
   assert (evalc ("display (infsup ())"), "[Empty]\n\n");
   assert (evalc ("display (infsupdec ())"), "[Empty]_trv\n\n");
 endif
***** test
 if (compare_versions (OCTAVE_VERSION, "4.2", ">="))
   assert (evalc ("a = infsup ()"), "a = [Empty]\n");
   assert (evalc ("b = infsupdec ()"), "b = [Empty]_trv\n");
 endif
***** test
 if (compare_versions (OCTAVE_VERSION, "4.2", ">="))
   assert (evalc ("a = infsup (); display (a)"), "a = [Empty]\n");
   assert (evalc ("b = infsupdec (); display (b)"), "b = [Empty]_trv\n");
 endif
***** test
 if (compare_versions (OCTAVE_VERSION, "4.2", ">=") && !ispc ())
   assert (evalc ("display (infsup (magic (3)))"), ...
    ["3×3 interval matrix\n", ...
     "\n", ...
     "   [8]   [1]   [6]\n", ...
     "   [3]   [5]   [7]\n", ...
     "   [4]   [9]   [2]\n", ...
     "\n"]);
 endif
***** test
 if (compare_versions (OCTAVE_VERSION, "4.2", ">=") && !ispc ())
   assert (evalc ("infsup (magic (3))"), ...
    ["ans = 3×3 interval matrix\n", ...
     "\n", ...
     "   [8]   [1]   [6]\n", ...
     "   [3]   [5]   [7]\n", ...
     "   [4]   [9]   [2]\n", ...
     "\n"]);
 endif
***** test
 if (compare_versions (OCTAVE_VERSION, "4.2", ">=") && !ispc ())
   assert (evalc ("infsup ('pi')"), "ans ⊂ [3.1415, 3.1416]\n");
 endif
***** test
 if (compare_versions (OCTAVE_VERSION, "4.2", ">=") && !ispc ())
   assert (evalc ("infsup (1:3)"), ...
    ["ans = 1×3 interval vector\n", ...
     "\n", ...
     "   [1]   [2]   [3]\n", ...
     "\n"]);
 endif
***** test
 if (compare_versions (OCTAVE_VERSION, "4.2", ">=") && !ispc ())
   assert (evalc ("infsup (ones(2, 2, 2))"), ...
    ["ans = 2×2×2 interval array\n", ...
     "\n", ...
     "ans(:,:,1) =\n", ...
     "\n", ...
     "   [1]   [1]\n", ...
     "   [1]   [1]\n", ...
     "\n", ...
     "ans(:,:,2) =\n", ...
     "\n", ...
     "   [1]   [1]\n", ...
     "   [1]   [1]\n", ...
     "\n"]);
 endif
warning: test: file /<<PKGBUILDDIR>>/inst/@infsup/display.m leaked global variables: current_print_indent_level
8 tests, 8 passed, 0 known failure, 0 skipped
[inst/@infsup/cancelplus.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/cancelplus.m
***** # from the documentation string
***** assert (cancelplus (infsup (2, 3), infsup (1, 1.5)) == infsup (3.5, 4));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.cancelPlus;
 for testcase = [testcases]'
   assert (isequaln (...
     cancelplus (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.cancelPlus;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (cancelplus (in1, in2), out));
***** test
 # Decorated scalar evaluation
 testcases = testdata.NoSignal.infsupdec.cancelPlus;
 for testcase = [testcases]'
   assert (isequaln (...
     cancelplus (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Decorated vector evaluation
 testcases = testdata.NoSignal.infsupdec.cancelPlus;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (cancelplus (in1, in2), out));
***** test
 # N-dimensional array vector evaluation
 testcases = testdata.NoSignal.infsupdec.cancelPlus;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (cancelplus (in1, in2), out));
6 tests, 6 passed, 0 known failure, 0 skipped
[inst/@infsup/smig.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/smig.m
***** assert (smig (infsup (-1, 2)), 0);
***** assert (smig (infsup (-42, -23)), -23);
***** assert (smig (infsup (23, 42)), 23);
3 tests, 3 passed, 0 known failure, 0 skipped
[inst/@infsup/realsqrt.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/realsqrt.m
***** # from the documentation string
***** assert (realsqrt (infsup (-6, 4)) == infsup (0, 2));
***** # correct use of signed zeros
***** test
 x = realsqrt (infsup (0));
 assert (signbit (inf (x)));
 assert (not (signbit (sup (x))));
***** test
 x = realsqrt (infsup (0, 2));
 assert (signbit (inf (x)));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.sqrt;
 for testcase = [testcases]'
   assert (isequaln (...
     realsqrt (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.sqrt;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (realsqrt (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.sqrt;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (realsqrt (in1), out));
6 tests, 6 passed, 0 known failure, 0 skipped
[inst/@infsup/gammaln.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/gammaln.m
***** assert (gammaln (infsup (-inf, inf)) == "[-0x1.F19B9BCC38A42p-4, +Inf]");
***** # from the documentation string
***** assert (gammaln (infsup (1.5)) == "[-0x1.EEB95B094C192p-4, -0x1.EEB95B094C191p-4]");
***** # correct use of signed zeros
***** test
 x = gammaln (infsup (1));
 assert (signbit (inf (x)));
 assert (not (signbit (sup (x))));
***** test
 x = gammaln (infsup (2));
 assert (signbit (inf (x)));
 assert (not (signbit (sup (x))));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsup/floor.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/floor.m
***** # Empty interval
***** assert (floor (infsup ()) == infsup ());
***** # Singleton intervals
***** assert (floor (infsup (0)) == infsup (0));
***** assert (floor (infsup (0.5)) == infsup (0));
***** assert (floor (infsup (-0.5)) == infsup (-1));
***** # Bounded intervals
***** assert (floor (infsup (-0.5, 0)) == infsup (-1, 0));
***** assert (floor (infsup (0, 0.5)) == infsup (0));
***** assert (floor (infsup (0.25, 0.5)) == infsup (0));
***** assert (floor (infsup (-1, 0)) == infsup (-1, 0));
***** assert (floor (infsup (-1, 1)) == infsup (-1, 1));
***** assert (floor (infsup (-realmin, realmin)) == infsup (-1, 0));
***** assert (floor (infsup (-realmax, realmax)) == infsup (-realmax, realmax));
***** # Unbounded intervals
***** assert (floor (infsup (-realmin, inf)) == infsup (-1, inf));
***** assert (floor (infsup (-realmax, inf)) == infsup (-realmax, inf));
***** assert (floor (infsup (-inf, realmin)) == infsup (-inf, 0));
***** assert (floor (infsup (-inf, realmax)) == infsup (-inf, realmax));
***** assert (floor (infsup (-inf, inf)) == infsup (-inf, inf));
***** # from the documentation string
***** assert (floor (infsup (2.5, 3.5)) == infsup (2, 3));
***** assert (floor (infsup (-0.5, 5)) == infsup (-1, 5));
***** # correct use of signed zeros
***** test
 x = floor (infsup (0.5));
 assert (signbit (inf (x)));
 assert (not (signbit (sup (x))));
***** test
 x = floor (infsup (0));
 assert (signbit (inf (x)));
 assert (not (signbit (sup (x))));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.floor;
 for testcase = [testcases]'
   assert (isequaln (...
     floor (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.floor;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (floor (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.floor;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (floor (in1), out));
23 tests, 23 passed, 0 known failure, 0 skipped
[inst/@infsup/expm.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/expm.m
***** # from the paper
***** test
 A = infsup ([0 1; 0 -3], [0 1; 0 -2]);
 assert (all (all (subset (infsup ([1, 0.316738; 0, 0.0497871], [1, 0.432332; 0, 0.135335]), expm (A)))));
1 test, 1 passed, 0 known failure, 0 skipped
[inst/@infsup/sinh.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/sinh.m
***** # from the documentation string
***** assert (sinh (infsup (1)) == "[0x1.2CD9FC44EB982, 0x1.2CD9FC44EB983]");
***** # correct use of signed zeros
***** test
 x = sinh (infsup (0));
 assert (signbit (inf (x)));
 assert (not (signbit (sup (x))));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.sinh;
 for testcase = [testcases]'
   assert (isequaln (...
     sinh (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.sinh;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (sinh (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.sinh;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (sinh (in1), out));
5 tests, 5 passed, 0 known failure, 0 skipped
[inst/@infsup/ge.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/ge.m
***** assert (ge (infsup (2, 3), infsup (1, 3)));
1 test, 1 passed, 0 known failure, 0 skipped
[inst/@infsup/rows.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/rows.m
***** assert (rows (infsup (zeros (3, 4))), 3);
1 test, 1 passed, 0 known failure, 0 skipped
[inst/@infsup/fsolve.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/fsolve.m
***** test
  sqr = @(x) x .^ 2;
  assert (subset (sqrt (infsup (2)), fsolve (sqr, infsup (0, 3), 2)));
***** test
  sqr = @(x) x .^ 2;
  assert (subset (sqrt (infsup (2)), fsolve (sqr, infsup (0, 3), 2, struct ("Vectorize", false))));
***** function [fval, x] = contractor (y, x)
  fval = x .^ 2;
  y = intersect (y, fval);
  x = sqrrev (y, x);
***** endfunction
***** assert (subset (sqrt (infsup (2)), fsolve (@contractor, infsup (0, 3), 2, struct ("Contract", true))));
***** assert (subset (sqrt (infsup (2)), fsolve (@contractor, infsup (0, 3), 2, struct ("Contract", true, "Vectorize", false))));
***** demo
 clf
 hold on
 grid on
 axis equal
 shade = [238 232 213] / 255;
 blue = [38 139 210] / 255;
 cyan = [42 161 152] / 255;
 red = [220 50 47] / 255;
 # 2D ring
 f = @(x, y) hypot (x, y);
 [outer, paving, inner] = fsolve (f, infsup ([-3; -3], [3; 3]), ...
                                  infsup (0.5, 2), ...
                                  optimset ('TolX', 0.1));
 # Plot the outer interval enclosure
 plot (outer(1), outer(2), shade)
 # Plot the guaranteed inner interval enclosures of the preimage
 plot (paving(1, inner), paving(2, inner), blue, cyan);
 # Plot the boundary of the preimage
 plot (paving(1, not (inner)), paving(2, not (inner)), red);
***** demo
 clf
 hold on
 grid on
 shade = [238 232 213] / 255;
 blue = [38 139 210] / 255;
 # This 3D ring is difficult to approximate with interval boxes
 f = @(x, y, z) hypot (hypot (x, y) - 2, z);
 [~, paving, inner] = fsolve (f, infsup ([-4; -4; -2], [4; 4; 2]), ...
                                 infsup (0, 0.5), ...
                                 optimset ('TolX', 0.2));
 plot3 (paving(1, not (inner)), ...
        paving(2, not (inner)), ...
        paving(3, not (inner)), shade, blue);
 view (50, 60)
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsup/idist.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/idist.m
***** # from the documentation string
***** assert (idist (infsup (0, 6), infsup (7, 20)), 1);
1 test, 1 passed, 0 known failure, 0 skipped
[inst/@infsup/reshape.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/reshape.m
***** assert (reshape (infsup (1 : 6), 2, 3) == infsup (reshape (1 : 6, 2, 3)));
***** assert (reshape (infsup (1 : 24), 2, [], 4) == infsup (reshape (1 : 24, 2, 3, 4)));
2 tests, 2 passed, 0 known failure, 0 skipped
[inst/@infsup/powrev1.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/powrev1.m
***** # from the documentation string
***** assert (powrev1 (infsup (2, 5), infsup (3, 6)) == "[0x1.3EE8390D43955, 0x1.3988E1409212Fp1]");
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.powRev1;
 for testcase = [testcases]'
   assert (isequaln (...
     powrev1 (testcase.in{1}, testcase.in{2}, testcase.in{3}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.powRev1;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 in3 = vertcat (vertcat (testcases.in){:, 3});
 out = vertcat (testcases.out);
 assert (isequaln (powrev1 (in1, in2, in3), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.powRev1;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 in3 = vertcat (vertcat (testcases.in){:, 3});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 in3 = reshape ([in3; in3(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (powrev1 (in1, in2, in3), out));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsup/log10.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/log10.m
***** # from the documentation string
***** assert (log10 (infsup (2)) == "[0x1.34413509F79FEp-2, 0x1.34413509F79FFp-2]");
***** # correct use of signed zeros
***** test
 x = log10 (infsup (1));
 assert (signbit (inf (x)));
 assert (not (signbit (sup (x))));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.log10;
 for testcase = [testcases]'
   assert (isequaln (...
     log10 (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.log10;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (log10 (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.log10;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (log10 (in1), out));
5 tests, 5 passed, 0 known failure, 0 skipped
[inst/@infsup/pown.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/pown.m
***** # from the documentation string
***** assert (pown (infsup (5, 6), 2) == infsup (25, 36));
***** assert (pown (infsup (-2, 1), 2) == infsup (0, 4));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.sqr;
 for testcase = [testcases]'
   assert (isequaln (...
     pown (testcase.in{1}, 2), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.sqr;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (pown (in1, 2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.sqr;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (pown (in1, 2), out));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.pown;
 for testcase = [testcases]'
   assert (isequaln (...
     pown (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.pown;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (pown (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.pown;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (pown (in1, in2), out));
8 tests, 8 passed, 0 known failure, 0 skipped
[inst/@infsup/le.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/le.m
***** assert (le (infsup (1, 3), infsup (3)));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.less;
 for testcase = [testcases]'
   assert (isequaln (...
     le (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.less;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (le (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.less;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (le (in1, in2), out));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsup/mag.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/mag.m
***** assert (mag (infsup (-3, 4)), 4);
***** assert (mag (infsup (-4, 3)), 4);
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.mag;
 for testcase = [testcases]'
   assert (isequaln (...
     mag (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.mag;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (mag (in1), out));
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.mag;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (mag (in1), out));
***** test
 # Decorated scalar evaluation
 testcases = testdata.NoSignal.infsupdec.mag;
 for testcase = [testcases]'
   assert (isequaln (...
     mag (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Decorated vector evaluation
 testcases = testdata.NoSignal.infsupdec.mag;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (mag (in1), out));
***** test
 # Decorated N-dimensional array evaluation
 testcases = testdata.NoSignal.infsupdec.mag;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (mag (in1), out));
7 tests, 7 passed, 0 known failure, 0 skipped
[inst/@infsup/isvector.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/isvector.m
***** assert (not (isvector (infsup ([]))));
***** assert (isvector (infsup (0)));
***** assert (isvector (infsup (zeros (1, 2))));
***** assert (isvector (infsup (zeros (2, 1))));
***** assert (not (isvector (infsup (zeros (5)))));
5 tests, 5 passed, 0 known failure, 0 skipped
[inst/@infsup/ei.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/ei.m
***** assert (isempty (ei (infsup (0))));
***** assert (isempty (ei (infsup (-inf, -2))));
***** assert (isentire (ei (infsup (0, inf))));
***** # from the documentation string
***** assert (ei (infsup (1)) == "[0x1.E52670F350D08, 0x1.E52670F350D09]");
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsup/uminus.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/uminus.m
***** # from the documentation string
***** assert (-infsup (2, 3) == infsup (-3, -2));
***** # correct use of signed zeros
***** test
 x = uminus (infsup (0));
 assert (signbit (inf (x)));
 assert (not (signbit (sup (x))));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.neg;
 for testcase = [testcases]'
   assert (isequaln (...
     uminus (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.neg;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (uminus (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.neg;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (uminus (in1), out));
5 tests, 5 passed, 0 known failure, 0 skipped
[inst/@infsup/cancelminus.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/cancelminus.m
***** # from the documentation string
***** assert (cancelminus (infsup (2, 3), infsup (1, 1.5)) == infsup (1, 1.5));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.cancelMinus;
 for testcase = [testcases]'
   assert (isequaln (...
     cancelminus (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.cancelMinus;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (cancelminus (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.cancelMinus;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (cancelminus (in1, in2), out));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsup/columns.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/columns.m
***** assert (columns (infsup (zeros (3, 4))), 4);
***** assert (columns (infsup (zeros (0, 4))), 4);
***** assert (columns (infsup (zeros (3, 0))), 0);
***** assert (columns (infsup (zeros (3, 1))), 1);
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsup/vertcat.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/vertcat.m
***** assert (vertcat (infsup (1), infsup (2)) == infsup (vertcat (1, 2)));
***** test
 # from the documentation string
 a = infsup (2, 5);
 assert (vertcat (a, a, a) == infsup ([2; 2; 2], [5; 5; 5]));
2 tests, 2 passed, 0 known failure, 0 skipped
[inst/@infsup/fma.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/fma.m
***** # from the documentation string
***** assert (fma (infsup (1+eps), infsup (7), infsup ("0.1")) == "[0x1.C666666666668p2, 0x1.C666666666669p2]");
***** # correct use of signed zeros
***** test
 x = fma (infsup (0), 0, 0);
 assert (signbit (inf (x)));
 assert (not (signbit (sup (x))));
***** test
 x = fma (infsup (1), 0, 0);
 assert (signbit (inf (x)));
 assert (not (signbit (sup (x))));
***** test
 x = fma (infsup (1), 1, -1);
 assert (signbit (inf (x)));
 assert (not (signbit (sup (x))));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.fma;
 for testcase = [testcases]'
   assert (isequaln (...
     fma (testcase.in{1}, testcase.in{2}, testcase.in{3}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.fma;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 in3 = vertcat (vertcat (testcases.in){:, 3});
 out = vertcat (testcases.out);
 assert (isequaln (fma (in1, in2, in3), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.fma;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 in3 = vertcat (vertcat (testcases.in){:, 3});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 in3 = reshape ([in3; in3(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (fma (in1, in2, in3), out));
7 tests, 7 passed, 0 known failure, 0 skipped
[inst/@infsup/atan2rev2.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/atan2rev2.m
***** # from the documentation string
***** assert (atan2rev2 (infsup (1, 2), infsup ("pi") / 4) == "[0x1.FFFFFFFFFFFFEp-1, 0x1.0000000000001p1]");
1 test, 1 passed, 0 known failure, 0 skipped
[inst/@infsup/det.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/det.m
***** # from the documentation string
***** assert (det (infsup (magic (3))) == -360);
1 test, 1 passed, 0 known failure, 0 skipped
[inst/@infsup/max.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/max.m
***** # from the documentation string
***** assert (max (infsup (2, 3), infsup (1, 2)) == infsup (2, 3));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.max;
 for testcase = [testcases]'
   assert (isequaln (...
     max (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.max;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (max (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.max;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (max (in1, in2), out));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsup/sumsq.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/sumsq.m
***** # from the documentation string
***** assert (sumsq ([infsup(1), pow2(-1074), -1]) == infsup (2, 2+eps*2));
***** assert (sumsq (infsup ([])) == 0);
***** # correct use of signed zeros
***** test
 x = sumsq (infsup (0));
 assert (signbit (inf (x)));
 assert (not (signbit (sup (x))));
3 tests, 3 passed, 0 known failure, 0 skipped
[inst/@infsup/abs.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/abs.m
***** # Empty interval
***** assert (abs (infsup ()) == infsup ());
***** # Singleton intervals
***** assert (abs (infsup (1)) == infsup (1));
***** assert (abs (infsup (0)) == infsup (0));
***** assert (abs (infsup (-1)) == infsup (1));
***** assert (abs (infsup (realmax)) == infsup (realmax));
***** assert (abs (infsup (realmin)) == infsup (realmin));
***** assert (abs (infsup (-realmin)) == infsup (realmin));
***** assert (abs (infsup (-realmax)) == infsup (realmax));
***** # Bounded intervals
***** assert (abs (infsup (1, 2)) == infsup (1, 2));
***** assert (abs (infsup (0, 1)) == infsup (0, 1));
***** assert (abs (infsup (-1, 1)) == infsup (0, 1));
***** assert (abs (infsup (-1, 0)) == infsup (0, 1));
***** assert (abs (infsup (-2, -1)) == infsup (1, 2));
***** # Unbounded intervals
***** assert (abs (infsup (0, inf)) == infsup (0, inf));
***** assert (abs (infsup (-inf, inf)) == infsup (0, inf));
***** assert (abs (infsup (-inf, 0)) == infsup (0, inf));
***** assert (abs (infsup (1, inf)) == infsup (1, inf));
***** assert (abs (infsup (-1, inf)) == infsup (0, inf));
***** assert (abs (infsup (-inf, -1)) == infsup (1, inf));
***** assert (abs (infsup (-inf, 1)) == infsup (0, inf));
***** # from the documentation string
***** assert (abs (infsup (2.5, 3.5)) == infsup (2.5, 3.5));
***** assert (abs (infsup (-0.5, 5.5)) == infsup (0, 5.5));
***** # correct use of signed zeros
***** assert (signbit (inf (abs (infsup (-1, 0)))));
***** test
 x = abs (infsup (0));
 assert (signbit (inf (x)));
 assert (not (signbit (sup (x))));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.abs;
 for testcase = [testcases]'
   assert (isequaln (...
     abs (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.abs;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (abs (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.abs;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (abs (in1), out));
27 tests, 27 passed, 0 known failure, 0 skipped
[inst/@infsup/csch.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/csch.m
***** # from the documentation string
***** assert (csch (infsup (1)) == "[0x1.B3AB8A78B90Cp-1, 0x1.B3AB8A78B90C1p-1]");
***** # correct use of signed zeros
***** test
 x = csch (infsup (0, inf));
 assert (signbit (inf (x)));
 assert (not (signbit (sup (x))));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.csch;
 for testcase = [testcases]'
   assert (isequaln (...
     csch (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.csch;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (csch (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.csch;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (csch (in1), out));
5 tests, 5 passed, 0 known failure, 0 skipped
[inst/@infsup/hypot.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/hypot.m
***** # from the documentation string
***** assert (hypot (infsup (2, 3), infsup (1, 2)) == "[0x1.1E3779B97F4A7p1, 0x1.CD82B446159F4p1]");
***** # correct use of signed zeros
***** test
 x = hypot (infsup (0), infsup (0));
 assert (signbit (inf (x)));
 assert (not (signbit (sup (x))));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.hypot;
 for testcase = [testcases]'
   assert (isequaln (...
     hypot (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.hypot;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (hypot (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.hypot;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (hypot (in1, in2), out));
5 tests, 5 passed, 0 known failure, 0 skipped
[inst/@infsup/mod.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/mod.m
***** assert (mod (infsup (), infsup ()) == infsup ());
***** assert (mod (infsup (0), infsup ()) == infsup ());
***** assert (mod (infsup (), infsup (0)) == infsup ());
***** assert (mod (infsup (0), infsup (0)) == infsup ());
***** assert (mod (infsup (1), infsup (0)) == infsup ());
***** assert (mod (infsup (0, 1), infsup (0)) == infsup ());
***** assert (mod (infsup (1, 2), infsup (0)) == infsup ());
***** assert (mod (infsup (0, inf), infsup (0)) == infsup ());
***** assert (mod (infsup (1, inf), infsup (0)) == infsup ());
***** assert (mod (infsup (realmax, inf), infsup (0)) == infsup ());
***** assert (mod (infsup (0), infsup (1)) == infsup (0));
***** assert (mod (infsup (0), infsup (0, 1)) == infsup (0));
***** assert (mod (infsup (0), infsup (1, 2)) == infsup (0));
***** assert (mod (infsup (0), infsup (0, inf)) == infsup (0));
***** assert (mod (infsup (0), infsup (1, inf)) == infsup (0));
***** assert (mod (infsup (0), infsup (realmax, inf)) == infsup (0));
***** assert (mod (infsup (1), infsup (1)) == infsup (0));
***** assert (mod (infsup (2), infsup (1)) == infsup (0));
***** assert (mod (infsup (4), infsup (2)) == infsup (0));
***** assert (mod (infsup (6), infsup (3)) == infsup (0));
***** assert (mod (infsup (8), infsup (2)) == infsup (0));
***** assert (mod (infsup (9), infsup (3)) == infsup (0));
***** assert (mod (infsup (realmax), infsup (realmax)) == infsup (0));
***** assert (mod (infsup (realmax), infsup (realmax / 2)) == infsup (0));
***** assert (mod (infsup (realmax), infsup (realmax / 4)) == infsup (0));
***** assert (mod (infsup (realmax), infsup (realmax / 8)) == infsup (0));
***** assert (mod (infsup (realmax), infsup (realmax / 16)) == infsup (0));
***** assert (mod (infsup (realmax), infsup (realmax / 32)) == infsup (0));
***** assert (mod (infsup (0.1), infsup (0.1)) == infsup (0));
***** assert (mod (infsup (0.1 * 2), infsup (0.1)) == infsup (0));
***** assert (mod (infsup (0.1 * 4), infsup (0.1)) == infsup (0));
***** assert (mod (infsup (pi), infsup (pi)) == infsup (0));
***** assert (mod (infsup (pi), infsup (pi / 2)) == infsup (0));
***** assert (mod (infsup (pi), infsup (pi / 4)) == infsup (0));
***** assert (mod (infsup (pow2 (-1074)), infsup (pow2 (-1074))) == infsup (0));
***** assert (mod (infsup (pow2 (-1073)), infsup (pow2 (-1074))) == infsup (0));
***** assert (mod (infsup (pow2 (-1072)), infsup (pow2 (-1074))) == infsup (0));
***** assert (mod (infsup (1), infsup (2)) == infsup (1));
***** assert (mod (infsup (0.5), infsup (1)) == infsup (0.5));
***** assert (mod (infsup (pi), infsup (3.15)) == infsup (pi));
***** assert (mod (infsup (1), infsup (2, 3)) == infsup (1));
***** assert (mod (infsup (1), infsup (2, inf)) == infsup (1));
***** assert (mod (infsup (0.5), infsup (1, 2)) == infsup (0.5));
***** assert (mod (infsup (0.5), infsup (1, inf)) == infsup (0.5));
***** assert (mod (infsup (pi), infsup (3.15)) == infsup (pi));
***** assert (mod (infsup (pi), infsup (3.15, inf)) == infsup (pi));
***** assert (mod (infsup (0, 1), infsup (0, 1)) == infsup (0, 1));
***** assert (mod (infsup (0, 2), infsup (0, 1)) == infsup (0, 1));
***** assert (mod (infsup (0, 1), infsup (0, 2)) == infsup (0, 1));
***** assert (mod (infsup (0, realmax), infsup (0, realmax)) == infsup (0, realmax));
***** assert (mod (infsup (realmax, inf), infsup (realmax, inf)) == infsup (0, inf));
***** assert (mod (infsup (0, inf), infsup (0, inf)) == infsup (0, inf));
***** assert (mod (infsup (0), infsup (1)) == infsup (0));
***** assert (mod (infsup (1), infsup (1)) == infsup (0));
***** assert (mod (infsup (0, 1), infsup (1)) == infsup (0, 1));
***** assert (mod (infsup (1, 2), infsup (1)) == infsup (0, 1));
***** assert (mod (infsup (0, inf), infsup (1)) == infsup (0, 1));
***** assert (mod (infsup (1, inf), infsup (1)) == infsup (0, 1));
***** assert (mod (infsup (realmax, inf), infsup (1)) == infsup (0, 1));
***** assert (mod (infsup (1), infsup (1)) == infsup (0));
***** assert (mod (infsup (1), infsup (0, 1)) == infsup (0, 0.5));
***** assert (mod (infsup (1), infsup (1, 2)) == infsup (0, 1));
***** assert (mod (infsup (1), infsup (0, inf)) == infsup (0, 1));
***** assert (mod (infsup (1), infsup (1, inf)) == infsup (0, 1));
***** assert (mod (infsup (1), infsup (2, inf)) == infsup (1));
***** assert (mod (infsup (1), infsup (realmax, inf)) == infsup (1));
66 tests, 66 passed, 0 known failure, 0 skipped
[inst/@infsup/inv.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/inv.m
***** # from the wiki
***** test
  A = infsup ([1, 2, 3; 4, 0, 0; 0, 0, 1]);
  A (2, 3) = "[0, 6]";
  B = inv (A);
  assert (inf (B) == [0, .25, -1.5; .5, -.125, -1.5; 0, 0, 1]);
  assert (sup (B) == [0, .25,    0; .5, -.125, -.75; 0, 0, 1]);
***** # from the documentation string
***** assert (inv (infsup ([2, 1, 1; 0, 1, 0; 1, 0, 0])) == [0, 0, 1; 0, 1, 0; 1, -1, -2]);
***** assert (inv (infsup ([1, 2, 3; 4, 0, 6; 0, 0, 1])) == [0, .25, -1.5; .5, -.125, -.75; 0, 0, 1]);
3 tests, 3 passed, 0 known failure, 0 skipped
[inst/@infsup/atan2.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/atan2.m
***** test "from the documentation string";
***** assert (atan2 (infsup (1), infsup (-1)) == "[0x1.2D97C7F3321D2p1, 0x1.2D97C7F3321D3p1]");
***** # correct use of signed zeros
***** test
 x = atan2 (0, infsup (1));
 assert (signbit (inf (x)));
 assert (not (signbit (sup (x))));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.atan2;
 for testcase = [testcases]'
   assert (isequaln (...
     atan2 (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.atan2;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (atan2 (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.atan2;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (atan2 (in1, in2), out));
6 tests, 6 passed, 0 known failure, 0 skipped
[inst/@infsup/fminsearch.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/fminsearch.m
***** test
  sqr = @(x) x .^ 2;
  [x, y] = fminsearch (sqr, infsup (-inf, inf));
  assert (y == 0);
***** demo
  clf
  hold on
  draw = @(x) plot (x(1), x(2), [238 232 213]/255, [88 110 117]/255);
  f = @(x) (x(1) - 2) .^ 2 - x(2) .^ 2;
  fminsearch (f, infsup ("[1, 3] [0, 1]"), ...
              optimset ('OutputFcn', draw));
  hold off
1 test, 1 passed, 0 known failure, 0 skipped
[inst/@infsup/plot3.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/plot3.m
***** # this test is rather pointless
***** test
  clf
  plot3 (empty (), empty (), empty ());
  close
***** demo
  clf
  colormap hot
  x = y = z = (1 : 3) + infsup ("[0, 1]");
  plot3 (x, y, z);
  grid on
***** demo
  clf
  colormap jet
  z = 1 : 8;
  x = y = infsup ("[-1, 1]") ./ z;
  plot3 (x, y, z);
  grid on
***** demo
  clf
  [x, y] = meshgrid (mince (infsup ("[-5, 5]"), 20), ...
                     mince (infsup ("[0.1, 5]"), 10));
  z = log (hypot (x, y));
  blue = [38 139 210]/255; base2 = [238 232 213]/255;
  plot3 (x, y, z, base2, blue);
  view (330, 12)
***** demo
  clf
  [x, y] = meshgrid (midrad (-10 : 0.5 : 10, .25));
  z = sin (hypot (x, y)) .* hypot (x, y);
  plot3 (mid (x), mid (y), z);
  grid on
1 test, 1 passed, 0 known failure, 0 skipped
[inst/@infsup/inf.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/inf.m
***** # from the documentation string
***** assert (inf (infsup (2.5, 3.5)), 2.5);
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.inf;
 for testcase = [testcases]'
   assert (isequaln (...
     inf (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.inf;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (inf (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.inf;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (inf (in1), out));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsup/acosh.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/acosh.m
***** # Empty interval
***** assert (acosh (infsup ()) == infsup ());
***** # Singleton intervals
***** assert (acosh (infsup (0)) == infsup ());
***** assert (acosh (infsup (1)) == infsup (0));
***** test
 x = infsup (1 : 3 : 100);
 assert (min (subset (acosh (x), log (x + sqrt (x + 1) .* sqrt (x - 1)))));
***** # Bounded intervals
***** assert (acosh (infsup (0, 1)) == infsup (0));
***** # Unbounded intervals
***** assert (acosh (infsup (-inf, 0)) == infsup ());
***** assert (acosh (infsup (-inf, 1)) == infsup (0));
***** assert (acosh (infsup (0, inf)) == infsup (0, inf));
***** assert (acosh (infsup (1, inf)) == infsup (0, inf));
***** assert (subset (acosh (infsup (2, inf)), infsup (1, inf)));
***** # from the documentation string
***** assert (acosh (infsup (2)) == "[0x1.5124271980434, 0x1.5124271980435]");
***** # correct use of signed zeros
***** test
 x = acosh (infsup (1));
 assert (signbit (inf (x)));
 assert (not (signbit (sup (x))));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.acosh;
 for testcase = [testcases]'
   assert (isequaln (...
     acosh (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.acosh;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (acosh (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.acosh;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (acosh (in1), out));
15 tests, 15 passed, 0 known failure, 0 skipped
[inst/@infsup/size.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/size.m
***** assert (size (infsup (zeros (3, 4))), [3 4]);
***** assert (size (infsup (zeros (2, 3, 4))), [2, 3, 4]);
***** test
 [x y z] = size (infsup (magic (3)));
 assert (x, 3);
 assert (y, 3);
 assert (z, 1);
3 tests, 3 passed, 0 known failure, 0 skipped
[inst/@infsup/erf.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/erf.m
***** # from the documentation string
***** assert (erf (infsup (1)) == "[0x1.AF767A741088Ap-1, 0x1.AF767A741088Bp-1]");
***** # correct use of signed zeros
***** test
 x = erf (infsup (0));
 assert (signbit (inf (x)));
 assert (not (signbit (sup (x))));
2 tests, 2 passed, 0 known failure, 0 skipped
[inst/@infsup/isempty.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/isempty.m
***** assert (isempty (infsup ()));
***** assert (not (isempty (infsup (1, 2))));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.isEmpty;
 for testcase = [testcases]'
   assert (isequaln (...
     isempty (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.isEmpty;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (isempty (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.isEmpty;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (isempty (in1), out));
5 tests, 5 passed, 0 known failure, 0 skipped
[inst/@infsup/printf.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/printf.m
***** test
 if (compare_versions (OCTAVE_VERSION, "4.2", ">="))
   assert (evalc ("n = printf ('%g', infsup ('pi'));"), "3.14159 3.1416");
   assert (n, 14);
 endif
1 test, 1 passed, 0 known failure, 0 skipped
[inst/@infsup/bisect.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/bisect.m
***** test
 # from the documentation string
 [a, b] = bisect (infsup (2, 32));
 assert (a == infsup (2, 8));
 assert (b == infsup (8, 32));
***** test
 [a, b] = bisect (infsup (-inf, inf));
 assert (a == infsup (-inf, 0));
 assert (b == infsup (0, inf));
***** test
 [a, b] = bisect (infsup (0));
 assert (a == 0);
 assert (b == 0);
***** test
 [a, b] = bisect (infsup ());
 assert (isempty (a));
 assert (isempty (b));
***** test
 [a, b] = bisect (infsup (0, inf));
 assert (a == infsup (0, pow2 (-25)));
 assert (b == infsup (pow2 (-25), inf));
***** test
 [a, b] = bisect (infsup (-inf, 0));
 assert (a == infsup (-inf, -pow2 (-25)));
 assert (b == infsup (-pow2 (-25), 0));
***** # correct use of signed zeros
***** test
 [a, b] = bisect (infsup (0));
 assert (signbit (inf (a)));
 assert (signbit (inf (b)));
 assert (not (signbit (sup (a))));
 assert (not (signbit (sup (b))));
7 tests, 7 passed, 0 known failure, 0 skipped
[inst/@infsup/lt.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/lt.m
***** assert (not (lt (infsup (1, 3), infsup (3))));
***** assert (lt (infsup (1, 3), infsup (3.1)));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.strictLess;
 for testcase = [testcases]'
   assert (isequaln (...
     lt (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.strictLess;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (lt (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.strictLess;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (lt (in1, in2), out));
5 tests, 5 passed, 0 known failure, 0 skipped
[inst/@infsup/cat.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/cat.m
***** assert (size (cat (1, infsup ([]), infsup ([]))), [0 0]);
***** assert (cat (1, infsup (1), infsup (2)) == infsup (cat (1, 1, 2)));
***** assert (cat (2, infsup (1), infsup (2)) == infsup (cat (2, 1, 2)));
***** assert (cat (5, infsup (1), infsup (2)) == infsup (cat (5, 1, 2)));
***** assert (cat (1, infsup (zeros (2, 2, 2)), infsup (ones (2, 2, 2))) == infsup (cat (1, zeros (2, 2, 2), ones (2, 2, 2))));
5 tests, 5 passed, 0 known failure, 0 skipped
[inst/@infsup/disp.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/disp.m
***** assert (disp (infsup([])), "");
***** assert (disp (infsup(zeros (0, 1))), "");
***** assert (disp (infsup(zeros (1, 0))), "");
***** assert (disp (infsup(0)), "[0]\n");
***** assert (disp (infsup(0, 1)), "[0, 1]\n");
***** assert (disp (infsup([0 0])), "   [0]   [0]\n");
***** assert (disp (infsup([0 0; 0 0])), "   [0]   [0]\n   [0]   [0]\n");
***** assert (disp (infsup([0; 0])), "   [0]\n   [0]\n");
***** assert (disp (infsup (zeros (1, 1, 1, 0))), "");
***** assert (disp (infsup(zeros(2, 2, 2))), "ans(:,:,1) =\n\n   [0]   [0]\n   [0]   [0]\n\nans(:,:,2) =\n\n   [0]   [0]\n   [0]   [0]\n")
***** test
 i = infsupdec (reshape (1:24, 2, 3, 4));
 i(1, 1, 2) = entire ();
 i(1, 1, 3) = empty ();
 i(1, 1, 4) = nai ();
 assert (disp (i(1,1,:)), "ans(:,:,1) =   [1]_com\nans(:,:,2) =   [Entire]_dac\nans(:,:,3) =   [Empty]_trv\nans(:,:,4) =   [NaI]\n")
***** test
 x = infsup (zeros ([1 2 2]));
 unwind_protect
   format compact
   compact = disp (x);
   format loose
   loose = disp (x);
 unwind_protect_cleanup
   format
 end_unwind_protect
 assert (compact, "ans(:,:,1) =\n   [0]   [0]\nans(:,:,2) =\n   [0]   [0]\n");
 assert (loose, "ans(:,:,1) =\n\n   [0]   [0]\n\nans(:,:,2) =\n\n   [0]   [0]\n");
***** test
 x = infsup (zeros ([1 1 2]));
 unwind_protect
   format compact
   compact = disp (x);
   format loose
   loose = disp (x);
 unwind_protect_cleanup
   format
 end_unwind_protect
 assert (compact, "ans(:,:,1) =   [0]\nans(:,:,2) =   [0]\n");
 assert (loose,   "ans(:,:,1) =   [0]\nans(:,:,2) =   [0]\n");
13 tests, 13 passed, 0 known failure, 0 skipped
[inst/@infsup/ctranspose.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/ctranspose.m
***** assert (ctranspose (infsup (magic (3))) == infsup (magic (3)'));
1 test, 1 passed, 0 known failure, 0 skipped
[inst/@infsup/fix.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/fix.m
***** # Empty interval
***** assert (fix (infsup ()) == infsup ());
***** # Singleton intervals
***** assert (fix (infsup (0)) == infsup (0));
***** assert (fix (infsup (1)) == infsup (1));
***** assert (fix (infsup (1+eps)) == infsup (1));
***** assert (fix (infsup (-1)) == infsup (-1));
***** assert (fix (infsup (0.5)) == infsup (0));
***** assert (fix (infsup (-0.5)) == infsup (0));
***** # Bounded intervals
***** assert (fix (infsup (-0.5, 0)) == infsup (0));
***** assert (fix (infsup (0, 0.5)) == infsup (0));
***** assert (fix (infsup (0.25, 0.5)) == infsup (0));
***** assert (fix (infsup (-1, 0)) == infsup (-1, 0));
***** assert (fix (infsup (-1, 1)) == infsup (-1, 1));
***** assert (fix (infsup (-realmin, realmin)) == infsup (0));
***** assert (fix (infsup (-realmax, realmax)) == infsup (-realmax, realmax));
***** # Unbounded intervals
***** assert (fix (infsup (-realmin, inf)) == infsup (0, inf));
***** assert (fix (infsup (-realmax, inf)) == infsup (-realmax, inf));
***** assert (fix (infsup (-inf, realmin)) == infsup (-inf, 0));
***** assert (fix (infsup (-inf, realmax)) == infsup (-inf, realmax));
***** assert (fix (infsup (-inf, inf)) == infsup (-inf, inf));
***** # from the documentation string
***** assert (fix (infsup (2.5, 3.5)) == infsup (2, 3));
***** assert (fix (infsup (-0.5, 5)) == infsup (0, 5));
***** # correct use of signed zeros
***** test
 x = fix (infsup (0.5));
 assert (signbit (inf (x)));
 assert (not (signbit (sup (x))));
***** test
 x = fix (infsup (-0.5));
 assert (signbit (inf (x)));
 assert (not (signbit (sup (x))));
***** test
 x = fix (infsup (0));
 assert (signbit (inf (x)));
 assert (not (signbit (sup (x))));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.trunc;
 for testcase = [testcases]'
   assert (isequaln (...
     fix (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.trunc;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (fix (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.trunc;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (fix (in1), out));
27 tests, 27 passed, 0 known failure, 0 skipped
[inst/@infsup/transpose.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/transpose.m
***** assert (transpose (infsup (magic (3))) == infsup (magic (3).'));
***** # from the documentation string
***** assert (transpose (infsup (zeros (1, 3), ones (1, 3))) == infsup (zeros (3, 1), ones (3, 1)));
2 tests, 2 passed, 0 known failure, 0 skipped
[inst/@infsup/triu.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/triu.m
***** assert (triu (infsup (magic (10))) == triu (magic (10)));
***** assert (triu (infsup (magic (10)), 1) == triu (magic (10), 1));
***** assert (triu (infsup (magic (10)), -1) == triu (magic (10), -1));
***** assert (triu (infsup (magic (10)), 0, "pack") == triu (magic (10), 0, "pack"));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsup/sum.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/sum.m
***** # from the documentation string
***** assert (sum ([infsup(1), pow2(-1074), -1]) == infsup (pow2 (-1074)));
***** assert (sum (infsup ([])) == 0);
***** # correct use of signed zeros
***** test
 x = sum (infsup (0));
 assert (signbit (inf (x)));
 assert (not (signbit (sup (x))));
***** # N-dimensional arrays
***** assert (sum (infsup (ones (1, 1, 10))) == infsup (10));
***** assert (sum (infsup (ones (1, 1, 10))) == infsup (10));
5 tests, 5 passed, 0 known failure, 0 skipped
[inst/@infsup/postpad.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/postpad.m
***** assert (postpad (infsup (1:3), 4, 4) == infsup (1:4));
***** assert (postpad (infsup (1:3), 2, 4) == infsup (1:2));
***** test
 if (compare_versions (OCTAVE_VERSION (), "4.0.0", ">="))
   assert (postpad (infsup (0), 10, 0, 3) == infsup (zeros (1, 1, 10)))
 else
   # In Octave 3.8.x it is not possible to increase the number of dimensions.
 endif
***** assert (postpad (infsup (zeros (1, 2, 2)), 3) == infsup (zeros (1, 3, 2)));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsup/overlap.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/overlap.m
***** test
 [s, n] = overlap (infsup (), infsup ());
 assert (s, "bothEmpty");
 assert (n, uint16 (32768));
***** test
 [s, n] = overlap (infsup (), infsup (0));
 assert (s, "firstEmpty");
 assert (n, uint16 (16384));
***** test
 [s, n] = overlap (infsup (0), infsup ());
 assert (s, "secondEmpty");
 assert (n, uint16 (8192));
***** test
 [s, n] = overlap (infsup (1, 2), infsup (3, 4));
 assert (s, "before");
 assert (n, uint16 (4096));
***** test
 [s, n] = overlap (infsup (1, 2), infsup (2, 3));
 assert (s, "meets");
 assert (n, uint16 (2048));
***** test
 [s, n] = overlap (infsup (1, 3), infsup (2, 4));
 assert (s, "overlaps");
 assert (n, uint16 (1024));
***** test
 [s, n] = overlap (infsup (1, 2), infsup (1, 3));
 assert (s, "starts");
 assert (n, uint16 (512));
***** test
 [s, n] = overlap (infsup (2, 3), infsup (1, 4));
 assert (s, "containedBy");
 assert (n, uint16 (256));
***** test
 [s, n] = overlap (infsup (2, 3), infsup (1, 3));
 assert (s, "finishes");
 assert (n, uint16 (128));
***** test
 [s, n] = overlap (infsup (1, 2), infsup (1, 2));
 assert (s, "equals");
 assert (n, uint16 (64));
***** test
 [s, n] = overlap (infsup (1, 3), infsup (2, 3));
 assert (s, "finishedBy");
 assert (n, uint16 (32));
***** test
 [s, n] = overlap (infsup (1, 4), infsup (2, 3));
 assert (s, "contains");
 assert (n, uint16 (16));
***** test
 [s, n] = overlap (infsup (1, 3), infsup (1, 2));
 assert (s, "startedBy");
 assert (n, uint16 (8));
***** test
 [s, n] = overlap (infsup (2, 4), infsup (1, 3));
 assert (s, "overlappedBy");
 assert (n, uint16 (4));
***** test
 [s, n] = overlap (infsup (2, 3), infsup (1, 2));
 assert (s, "metBy");
 assert (n, uint16 (2));
***** test
 [s, n] = overlap (infsup (3, 4), infsup (1, 2));
 assert (s, "after");
 assert (n, uint16 (1));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.overlap;
 for testcase = [testcases]'
   assert (isequaln (...
     overlap (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.overlap;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = {testcases.out}';
 assert (isequaln (overlap (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.overlap;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = {testcases.out}';
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (overlap (in1, in2), out));
19 tests, 19 passed, 0 known failure, 0 skipped
[inst/@infsup/sin.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/sin.m
***** # from the documentation string
***** assert (sin (infsup (1)) == "[0x1.AED548F090CEEp-1, 0x1.AED548F090CEFp-1]");
***** # correct use of signed zeros
***** test
 x = sin (infsup (0));
 assert (signbit (inf (x)));
 assert (not (signbit (sup (x))));
***** # test fix for bug #51283
***** test
 x = sin (infsup ([0, 0]));
 assert (signbit (inf (x)));
 assert (not (signbit (sup (x))));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.sin;
 for testcase = [testcases]'
   assert (isequaln (...
     sin (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.sin;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (sin (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.sin;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (sin (in1), out));
6 tests, 6 passed, 0 known failure, 0 skipped
[inst/@infsup/mldivide.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/mldivide.m
***** # unique solution
***** assert (infsup ([1, 0; 0, 2]) \ [2, 0; 0, 4] == [2, 0; 0 2]);
***** # no solution
***** assert (all (isempty (infsup ([1, 0; 2, 0]) \ [3; 0])));
***** # many solutions
***** assert (infsup ([1, 0; 2, 0]) \ [4; 8] == infsup ([4; -inf], [4; inf]));
***** assert (all (subset (infsup ([2, -1; -1, 2], [4, 1; 1, 4]) \ infsup ([-3; .8], [3; .8]), infsup ([-2.3; -1.1], [2.3; 1.6]))));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsup/mrdivide.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/mrdivide.m
***** # from the documentation string
***** assert (infsup ([1, 2; 3, 4]) / [3, 4; 1, 2] == infsup ([0, 1; 1, 0]));
1 test, 1 passed, 0 known failure, 0 skipped
[inst/@infsup/infsup.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/infsup.m
***** # Empty intervals
***** test
 x = infsup ();
 assert (inf (x), +inf);
 assert (sup (x), -inf);
***** test
 x = infsup ("[]");
 assert (inf (x), +inf);
 assert (sup (x), -inf);
***** test
 x = infsup ("[ ]");
 assert (inf (x), +inf);
 assert (sup (x), -inf);
***** test
 x = infsup ("[\t]");
 assert (inf (x), +inf);
 assert (sup (x), -inf);
***** test
 x = infsup ("[empty]");
 assert (inf (x), +inf);
 assert (sup (x), -inf);
***** test
 x = infsup ("[EMPTY]");
 assert (inf (x), +inf);
 assert (sup (x), -inf);
***** test
 x = infsup ("[ empty ]");
 assert (inf (x), +inf);
 assert (sup (x), -inf);
***** test
 x = infsup ("\t[\t Empty\t]\t");
 assert (inf (x), +inf);
 assert (sup (x), -inf);
***** # Entire interval
***** test
 x = infsup ("[,]");
 assert (inf (x), -inf);
 assert (sup (x), +inf);
***** test
 x = infsup ("[entire]");
 assert (inf (x), -inf);
 assert (sup (x), +inf);
***** test
 x = infsup ("[ENTIRE]");
 assert (inf (x), -inf);
 assert (sup (x), +inf);
***** test
 x = infsup ("[ entire ]");
 assert (inf (x), -inf);
 assert (sup (x), +inf);
***** test
 x = infsup (" [Entire \t] ");
 assert (inf (x), -inf);
 assert (sup (x), +inf);
***** test
 x = infsup ("[-inf,+inf]");
 assert (inf (x), -inf);
 assert (sup (x), +inf);
***** test
 x = infsup ("[-infinity, +infinity]");
 assert (inf (x), -inf);
 assert (sup (x), +inf);
***** test
 x = infsup ("[-INF, +INFinitY]");
 assert (inf (x), -inf);
 assert (sup (x), +inf);
***** # double boundaries
***** test
 x = infsup (0);
 assert (inf (x), 0);
 assert (sup (x), 0);
 assert (signbit (inf (x)));
 assert (not (signbit (sup (x))));
***** test
 x = infsup (2, 3);
 assert (inf (x), 2);
 assert (sup (x), 3);
***** test
 x = infsup (-inf, 0.1);
 assert (inf (x), -inf);
 assert (sup (x), 0.1);
***** test
 x = infsup (-inf, +inf);
 assert (inf (x), -inf);
 assert (sup (x), +inf);
***** # NaN values
***** warning id=interval:UndefinedOperation
 x = infsup (nan);
 assert (inf (x), +inf);
 assert (sup (x), -inf);
***** warning id=interval:UndefinedOperation
 x = infsup (nan, 2);
 assert (inf (x), +inf);
 assert (sup (x), -inf);
***** warning id=interval:UndefinedOperation
 x = infsup (3, nan);
 assert (inf (x), +inf);
 assert (sup (x), -inf);
***** # illegal numeric boundaries
***** warning id=interval:UndefinedOperation
 x = infsup (+inf, -inf);
 assert (inf (x), +inf);
 assert (sup (x), -inf);
***** warning id=interval:UndefinedOperation
 x = infsup (+inf, +inf);
 assert (inf (x), +inf);
 assert (sup (x), -inf);
***** warning id=interval:UndefinedOperation
 x = infsup (-inf, -inf);
 assert (inf (x), +inf);
 assert (sup (x), -inf);
***** warning id=interval:UndefinedOperation
 x = infsup (3, 2);
 assert (inf (x), +inf);
 assert (sup (x), -inf);
***** warning id=interval:UndefinedOperation
 x = infsup (3, -inf);
 assert (inf (x), +inf);
 assert (sup (x), -inf);
***** # double matrix
***** test
 x = infsup (magic (4));
 assert (inf (x), magic (4));
 assert (sup (x), magic (4));
***** test
 x = infsup (magic (3), magic (3) + 1);
 assert (inf (x), magic (3));
 assert (sup (x), magic (3) + 1);
***** warning id=interval:UndefinedOperation
 x = infsup (nan (3));
 assert (inf (x), +inf (3));
 assert (sup (x), -inf (3));
***** test
 x = infsup (-inf (3), +inf (3));
 assert (inf (x), -inf (3));
 assert (sup (x), +inf (3));
***** # decimal boundaries
***** test
 x = infsup ("0.1");
 assert (inf (x), 0.1 - eps / 16);
 assert (sup (x), 0.1);
***** test
 x = infsup ("0.1e1");
 assert (inf (x), 1);
 assert (sup (x), 1);
***** # hexadecimal boundaries
***** test
 x = infsup ("0xff");
 assert (inf (x), 255);
 assert (sup (x), 255);
***** test
 x = infsup ("0xff.1");
 assert (inf (x), 255.0625);
 assert (sup (x), 255.0625);
***** test
 x = infsup ("0xff.1p-1");
 assert (inf (x), 127.53125);
 assert (sup (x), 127.53125);
***** # named constants
***** test
 x = infsup ("pi");
 assert (inf (x), pi);
 assert (sup (x), pi + 2 * eps);
***** test
 x = infsup ("e");
 assert (inf (x), e);
 assert (sup (x), e + eps);
***** # uncertain form
***** test
 x = infsup ("32?");
 assert (inf (x), 31.5);
 assert (sup (x), 32.5);
***** test
 x = infsup ("32?8");
 assert (inf (x), 24);
 assert (sup (x), 40);
***** test
 x = infsup ("32?u");
 assert (inf (x), 32);
 assert (sup (x), 32.5);
***** test
 x = infsup ("32?d");
 assert (inf (x), 31.5);
 assert (sup (x), 32);
***** test
 x = infsup ("32??");
 assert (inf (x), -inf);
 assert (sup (x), +inf);
***** test
 x = infsup ("32??d");
 assert (inf (x), -inf);
 assert (sup (x), 32);
***** test
 x = infsup ("32??u");
 assert (inf (x), 32);
 assert (sup (x), +inf);
***** test
 x = infsup ("32?e5");
 assert (inf (x), 3150000);
 assert (sup (x), 3250000);
***** # rational form
***** test
 x = infsup ("6/9");
 assert (inf (x), 2 / 3);
 assert (sup (x), 2 / 3 + eps / 2);
***** test
 x = infsup ("6e1/9");
 assert (inf (x), 20 / 3 - eps * 2);
 assert (sup (x), 20 / 3);
***** test
 x = infsup ("6/9e1");
 assert (inf (x), 2 / 30);
 assert (sup (x), 2 / 30 + eps / 16);
***** test
 x = infsup ("-6/9");
 assert (inf (x), -(2 / 3 + eps / 2));
 assert (sup (x), -2 / 3);
***** test
 x = infsup ("6/-9");
 assert (inf (x), -(2 / 3 + eps / 2));
 assert (sup (x), -2 / 3);
***** test
 x = infsup ("-6/-9");
 assert (inf (x), 2 / 3);
 assert (sup (x), 2 / 3 + eps / 2);
***** test
 x = infsup ("6.6/9.9");
 assert (inf (x), 2 / 3);
 assert (sup (x), 2 / 3 + eps / 2);
***** # inf-sup interval literal
***** test
 x = infsup ("[2, 3]");
 assert (inf (x), 2);
 assert (sup (x), 3);
***** test
 x = infsup ("[0.1]");
 assert (inf (x), 0.1 - eps / 16);
 assert (sup (x), 0.1);
***** test
 x = infsup ("[0xff, 0xff.1]");
 assert (inf (x), 255);
 assert (sup (x), 255.0625);
***** test
 x = infsup ("[e, pi]");
 assert (inf (x), e);
 assert (sup (x), pi + 2 * eps);
***** test
 x = infsup ("[6/9, 6e1/9]");
 assert (inf (x), 2 / 3);
 assert (sup (x), 20 / 3);
***** # corner cases
***** test
 x = infsup (",");
 assert (inf (x), -inf);
 assert (sup (x), +inf);
***** test
 x = infsup ("[, 3]");
 assert (inf (x), -inf);
 assert (sup (x), 3);
***** test
 x = infsup ("", "3");
 assert (inf (x), -inf);
 assert (sup (x), 3);
***** test
 x = infsup ("[2, ]");
 assert (inf (x), 2);
 assert (sup (x), inf);
***** test
 x = infsup ("2", "");
 assert (inf (x), 2);
 assert (sup (x), inf);
***** # decimal vector
***** test
 x = infsup (["0.1"; "0.2"; "0.3"]);
 assert (inf (x), [0.1 - eps / 16; 0.2 - eps / 8; 0.3]);
 assert (sup (x), [0.1; 0.2; 0.3 + eps / 8]);
***** test
 x = infsup ("0.1; 0.2; 0.3");
 assert (inf (x), [0.1 - eps / 16; 0.2 - eps / 8; 0.3]);
 assert (sup (x), [0.1; 0.2; 0.3 + eps / 8]);
***** test
 x = infsup ("0.1\n0.2\n0.3");
 assert (inf (x), [0.1 - eps / 16; 0.2 - eps / 8; 0.3]);
 assert (sup (x), [0.1; 0.2; 0.3 + eps / 8]);
***** # cell array with mixed boundaries
***** test
 x = infsup ({"0.1", 42; "e", "3.2/8"}, {"0xffp2", "42e1"; "pi", 2});
 assert (inf (x), [0.1 - eps / 16, 42; e, 0.4 - eps / 4]);
 assert (sup (x), [1020, 420; pi + 2 * eps, 2]);
***** test
 x = infsup ({"[2, 3]", "3/4", "[Entire]", "42?3", 1, "0xf"});
 assert (inf (x), [2, 0.75, -inf, 39, 1, 15]);
 assert (sup (x), [3, 0.75, +inf, 45, 1, 15]);
***** # broadcasting
***** test
 x = infsup (magic (3), 10);
 assert (inf (x), magic (3));
 assert (sup (x), 10 .* ones (3));
***** test
 x = infsup (zeros (1, 20), ones (20, 1));
 assert (inf (x), zeros (20, 20));
 assert (sup (x), ones (20, 20));
***** # nai
***** warning id=interval:UndefinedOperation
 x = infsup ("[nai]");
 assert (inf (x), +inf);
 assert (sup (x), -inf);
***** warning id=interval:UndefinedOperation
 x = infsup ("Ausgeschnitzel");
 assert (inf (x), +inf);
 assert (sup (x), -inf);
***** # interval literals vs. two arguments
***** warning id=interval:UndefinedOperation
 x = infsup ("[empty]", 42);
 assert (inf (x), +inf);
 assert (sup (x), -inf);
***** warning id=interval:UndefinedOperation
 x = infsup ("0?", 42);
 assert (inf (x), +inf);
 assert (sup (x), -inf);
***** # extraction of single errors
***** warning id=interval:UndefinedOperation
 x = infsup ("0 1 2 [xxx] 3 4");
 assert (inf (x), [0 1 2 +inf 3 4]);
 assert (sup (x), [0 1 2 -inf 3 4]);
***** warning id=interval:UndefinedOperation
 x = infsup ({1 2; 3 "[xxx]"});
 assert (inf (x), [1 2; 3 +inf]);
 assert (sup (x), [1 2; 3 -inf]);
***** # complex values
***** warning id=interval:InvalidOperand
 x = infsup ([1 2 3+i 4+0i]);
 assert (inf (x), [1 2 +inf 4]);
 assert (sup (x), [1 2 -inf 4]);
***** # inaccurate conversion
***** warning id=interval:PossiblyUndefinedOperation
 x = infsup ("1.000000000000000000002", "1.000000000000000000001");
 assert (inf (x), 1);
 assert (sup (x), 1 + eps);
***** test
 n = uint64(2 ^ 53);
 x = infsup (n, n + 1);
 assert (inf (x), double (n));
 assert (sup (x), double (n + 2));
***** test
 n = uint64(2 ^ 53);
 x = infsup ({n}, n + 1);
 assert (inf (x), double (n));
 assert (sup (x), double (n + 2));
***** test
 n = uint64(2 ^ 53);
 x = infsup (n + 1, n + 1);
 assert (inf (x), double (n));
 assert (sup (x), double (n + 2));
***** test
 n = uint64(2 ^ 54);
 x = infsup (n, n + 1);
 assert (inf (x), double (n));
 assert (sup (x), double (n + 4));
***** warning id=interval:PossiblyUndefinedOperation
 n = uint64(2 ^ 54);
 x = infsup (n + 1, n + 2);
 assert (inf (x), double (n));
 assert (sup (x), double (n + 4));
***** warning id=interval:PossiblyUndefinedOperation
 x = infsup ("pi", "3.141592653589793");
 assert (inf (x), pi);
 assert (sup (x), pi);
***** warning id=interval:PossiblyUndefinedOperation
 x = infsup ("pi", "3.1415926535897932");
 assert (inf (x), pi);
 assert (sup (x), pi + 2 * eps);
***** # isexact flag
***** test
 [~, isexact] = infsup ();
 assert (isexact);
***** test
 [~, isexact] = infsup (0);
 assert (isexact);
***** test
 [~, isexact] = infsup ("1 2 3");
 assert (isexact, true);
***** test
 [~, isexact] = infsup ("1 2 3.1");
 assert (isexact, false);
***** warning
 [~, isexact] = infsup ("[nai]");
 assert (not (isexact));
***** # overflow flag
***** test
 [~, ~, overflow] = infsup ();
 assert (not (overflow));
***** test
 [~, ~, overflow] = infsup (0);
 assert (not (overflow));
***** test
 [~, ~, overflow] = infsup ([1 2 3]);
 assert (overflow, false (1, 3));
***** warning
 [~, ~, overflow] = infsup ("[nai]");
 assert (not (overflow));
***** test
 [~, ~, overflow] = infsup ("1e3000");
 assert (overflow);
***** test
 [~, ~, overflow] = infsup ("[1, inf]");
 assert (not (overflow));
***** # isnai flag
***** test
 [~, ~, ~, isnai] = infsup ();
 assert (not (isnai));
***** test
 [~, ~, ~, isnai] = infsup (0);
 assert (not (isnai));
***** test
 [~, ~, ~, isnai] = infsup ([1 2 3]);
 assert (isnai, false (1, 3));
***** warning
 [~, ~, ~, isnai] = infsup ("[nai]");
 assert (isnai);
***** warning
 [~, ~, ~, isnai] = infsup ("xxx");
 assert (isnai);
***** warning
 [~, ~, ~, isnai] = infsup ("1 2 xxx 4");
 assert (isnai, [false, false, true, false]);
***** warning
 [~, ~, ~, isnai] = infsup ("[-inf, inf] [inf, inf]");
 assert (isnai, [false, true]);
***** # N-dimensional arrays
***** test
 x = infsup (zeros (2, 2, 2));
 assert (x.inf, zeros (2, 2, 2));
 assert (x.sup, zeros (2, 2, 2));
***** test
 x = infsup (zeros (2, 2, 2), ones (2, 2, 2));
 assert (x.inf, zeros (2, 2, 2));
 assert (x.sup, ones (2, 2, 2));
***** test
 x = infsup (zeros (2, 1, 2, 1, 2, 1), ones (1, 3, 1, 3, 1, 3));
 assert (x.inf, zeros (2, 3, 2, 3, 2, 3));
 assert (x.sup, ones (2, 3, 2, 3, 2, 3));
***** test
 c1 = reshape ({1, 2, 3, 4, 5, 6, 7, 8}, 2, 2, 2);
 c2 = reshape ({2, 3, 4, 5, 6, 7, 8, 9}, 2, 2, 2);
 x = infsup (c1, c2);
 assert (x.inf, reshape (1:8, 2, 2, 2));
 assert (x.sup, reshape (2:9, 2, 2, 2));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.("b-numsToInterval");
 for testcase = [testcases]'
   assert (isequaln (...
     infsup (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.("b-numsToInterval");
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (infsup (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.("b-numsToInterval");
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (infsup (in1, in2), out));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.("b-textToInterval");
 for testcase = [testcases]'
   assert (isequaln (...
     infsup (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.("b-textToInterval");
 in1 = vertcat (testcases.in);
 out = vertcat (testcases.out);
 assert (isequaln (infsup (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.("b-numsToInterval");
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (infsup (in1, in2), out));
***** warning
 testcases = testdata.PossiblyUndefinedOperation.infsup.("b-textToInterval");
 for testcase = [testcases]'
   lastwarn ("", "");
   assert (isequaln (...
     infsup (testcase.in{1}), ...
     testcase.out));
   assert (nthargout (2, @lastwarn), "interval:PossiblyUndefinedOperation");
 endfor
***** warning
 testcases = testdata.UndefinedOperation.infsup.("b-textToInterval");
 for testcase = [testcases]'
   lastwarn ("", "");
   assert (isequaln (...
     infsup (testcase.in{1}), ...
     testcase.out));
   assert (nthargout (2, @lastwarn), "interval:UndefinedOperation");
 endfor
***** warning
 testcases = testdata.UndefinedOperation.infsup.("b-numsToInterval");
 for testcase = [testcases]'
   lastwarn ("", "");
   assert (isequaln (...
     infsup (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
   assert (nthargout (2, @lastwarn), "interval:UndefinedOperation");
 endfor
117 tests, 117 passed, 0 known failure, 0 skipped
[inst/@infsup/sumabs.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/sumabs.m
***** # from the documentation string
***** assert (sumabs ([infsup(1), pow2(-1074), -1]) == infsup (2, 2+eps*2));
***** assert (sumabs (infsup ([])) == 0);
***** # correct use of signed zeros
***** test
 x = sumabs (infsup (0));
 assert (signbit (inf (x)));
 assert (not (signbit (sup (x))));
3 tests, 3 passed, 0 known failure, 0 skipped
[inst/@infsup/ismember.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/ismember.m
***** assert (ismember (0, entire ()));
***** assert (ismember (0, intervalpart (entire ())));
***** assert (not (ismember (0, empty ())));
***** assert (not (ismember (0, intervalpart (empty ()))));
***** warning assert (not (ismember (0, infsupdec (2, 1))));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.isMember;
 for testcase = [testcases]'
   assert (isequaln (...
     ismember (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.isMember;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (ismember (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.isMember;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (ismember (in1, in2), out));
***** test
 # Decorated scalar evaluation
 testcases = testdata.NoSignal.infsupdec.isMember;
 for testcase = [testcases]'
   assert (isequaln (...
     ismember (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Decorated vector evaluation
 testcases = testdata.NoSignal.infsupdec.isMember;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (ismember (in1, in2), out));
***** test
 # Decorated N-dimensional array evaluation
 testcases = testdata.NoSignal.infsupdec.isMember;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (ismember (in1, in2), out));
11 tests, 11 passed, 0 known failure, 0 skipped
[inst/@infsup/intervaltoexact.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/intervaltoexact.m
***** assert (intervaltoexact (infsup (1 + eps)), "[0x1.0000000000001p+0]");
1 test, 1 passed, 0 known failure, 0 skipped
[inst/@infsup/nthroot.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/nthroot.m
***** assert (nthroot (infsup (25, 36), 2) == infsup (5, 6));
***** # correct use of signed zeros
***** test
 x = nthroot (infsup (0), 2);
 assert (signbit (inf (x)));
 assert (not (signbit (sup (x))));
***** test
 x = nthroot (infsup (0, inf), -2);
 assert (signbit (inf (x)));
***** test
 x = nthroot (infsup (0, inf), -3);
 assert (signbit (inf (x)));
***** assert (nthroot (infsup (-1, 1), 2) == infsup (0, 1));
***** assert (nthroot (infsup (-1, 1), 3) == infsup (-1, 1));
***** assert (nthroot (infsup (-1, 1), -2) == infsup (1, inf));
***** assert (nthroot (infsup (-1, 1), -3) == infsup (-inf, inf));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.rootn;
 for testcase = [testcases]'
   assert (isequaln (...
     nthroot (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.rootn;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (nthroot (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.rootn;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 if (i > numel (in1))
   i = i - numel (in1);
   in1 = [in1; in1];
   in2 = [in2; in2];
   out = [out; out];
 endif
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (nthroot (in1, in2), out));
11 tests, 11 passed, 0 known failure, 0 skipped
[inst/@infsup/absrev.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/absrev.m
***** # Empty interval
***** assert (absrev (infsup ()) == infsup ());
***** assert (absrev (infsup (0, 1), infsup ()) == infsup ());
***** assert (absrev (infsup (0, 1), infsup (7, 9)) == infsup ());
***** assert (absrev (infsup (), infsup (0, 1)) == infsup ());
***** assert (absrev (infsup (-2, -1)) == infsup ());
***** # Singleton intervals
***** assert (absrev (infsup (1)) == infsup (-1, 1));
***** assert (absrev (infsup (0)) == infsup (0));
***** assert (absrev (infsup (-1)) == infsup ());
***** assert (absrev (infsup (realmax)) == infsup (-realmax, realmax));
***** assert (absrev (infsup (realmin)) == infsup (-realmin, realmin));
***** assert (absrev (infsup (-realmin)) == infsup ());
***** assert (absrev (infsup (-realmax)) == infsup ());
***** # Bound intervals
***** assert (absrev (infsup (1, 2)) == infsup (-2, 2));
***** assert (absrev (infsup (1, 2), infsup (0, 2)) == infsup (1, 2));
***** assert (absrev (infsup (0, 1), infsup (-0.5, 2)) == infsup (-0.5, 1));
***** assert (absrev (infsup (-1, 1)) == infsup (-1, 1));
***** assert (absrev (infsup (-1, 0)) == infsup (0));
***** # Unbound intervals
***** assert (absrev (infsup (0, inf)) == infsup (-inf, inf));
***** assert (absrev (infsup (-inf, inf)) == infsup (-inf, inf));
***** assert (absrev (infsup (-inf, 0)) == infsup (0));
***** assert (absrev (infsup (1, inf), infsup (-inf, 0)) == infsup (-inf, -1));
***** assert (absrev (infsup (-1, inf)) == infsup (-inf, inf));
***** assert (absrev (infsup (-inf, -1)) == infsup ());
***** assert (absrev (infsup (-inf, 1)) == infsup (-1, 1));
***** # from the documentation string
***** assert (absrev (infsup (-2, 1)) == infsup (-1, 1));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation with one argument
 testcases = testdata.NoSignal.infsup.absRev;
 for testcase = [testcases]'
   assert (isequaln (...
     absrev (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation with one argument
 testcases = testdata.NoSignal.infsup.absRev;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (absrev (in1), out));
***** test
 # N-dimensional array evaluation with one argument
 testcases = testdata.NoSignal.infsup.absRev;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (absrev (in1), out));
***** test
 # Scalar evaluation with two arguments
 testcases = testdata.NoSignal.infsup.absRevBin;
 for testcase = [testcases]'
   assert (isequaln (...
     absrev (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation with two arguments
 testcases = testdata.NoSignal.infsup.absRevBin;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (absrev (in1, in2), out));
***** test
 # N-dimensional array evaluation with two arguments
 testcases = testdata.NoSignal.infsup.absRevBin;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (absrev (in1, in2), out));
31 tests, 31 passed, 0 known failure, 0 skipped
[inst/@infsup/plus.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/plus.m
***** # from the documentation string
***** assert (infsup (2, 3) + infsup (1, 2) == infsup (3, 5));
***** # correct use of signed zeros
***** test
 x = plus (infsup (0), infsup (0));
 assert (signbit (inf (x)));
 assert (not (signbit (sup (x))));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.add;
 for testcase = [testcases]'
   assert (isequaln (...
     plus (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.add;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (plus (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.add;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (plus (in1, in2), out));
5 tests, 5 passed, 0 known failure, 0 skipped
[inst/@infsup/norm.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/norm.m
***** test
 A = infsup ("0 [Empty] [0, 1] 1");
 assert (isequal (norm (A, 0, "cols"), infsup ("0 [Empty] [0, 1] 1")));
***** assert (norm (infsup (magic (3)), inf, 1) == 45);
***** assert (norm (infsup (-magic (3), magic (3)), inf, 1) == "[0, 45]");
3 tests, 3 passed, 0 known failure, 0 skipped
[inst/@infsup/atan.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/atan.m
***** # from the documentation string
***** assert (atan (infsup (1)) == "[0x1.921FB54442D18p-1, 0x1.921FB54442D19p-1]");
***** # correct use of signed zeros
***** test
 x = atan (infsup (0));
 assert (signbit (inf (x)));
 assert (not (signbit (sup (x))));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.atan;
 for testcase = [testcases]'
   assert (isequaln (...
     atan (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.atan;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (atan (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.atan;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (atan (in1), out));
5 tests, 5 passed, 0 known failure, 0 skipped
[inst/@infsup/mince.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/mince.m
***** assert (isequal (mince (infsup (0, 10), 10), infsup (0 : 9, 1 : 10)));
1 test, 1 passed, 0 known failure, 0 skipped
[inst/@infsup/sec.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/sec.m
***** # from the documentation string
***** assert (sec (infsup (1)) == "[0x1.D9CF0F125CC29, 0x1.D9CF0F125CC2A]");
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.sec;
 for testcase = [testcases]'
   assert (isequaln (...
     sec (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.sec;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (sec (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.sec;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (sec (in1), out));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsup/pownrev.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/pownrev.m
***** assert (pownrev (infsup (25, 36), infsup (0, inf), 2) == infsup (5, 6));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.pownRev;
 for testcase = [testcases]'
   assert (isequaln (...
     pownrev (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.pownRev;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (pownrev (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.pownRev;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (pownrev (in1, in2), out));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.pownRevBin;
 for testcase = [testcases]'
   assert (isequaln (...
     pownrev (testcase.in{1}, testcase.in{2}, testcase.in{3}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.pownRevBin;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 in3 = vertcat (vertcat (testcases.in){:, 3});
 out = vertcat (testcases.out);
 assert (isequaln (pownrev (in1, in2, in3), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.pownRevBin;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 in3 = vertcat (vertcat (testcases.in){:, 3});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 in3 = reshape ([in3; in3(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (pownrev (in1, in2, in3), out));
7 tests, 7 passed, 0 known failure, 0 skipped
[inst/@infsup/diag.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/diag.m
***** assert (diag (infsup (-inf, inf)) == "[Entire]");
***** assert (diag (infsup ()) == "[Empty]");
***** assert (numel (diag (infsup ([]))), 0);
***** assert (isequal (diag (infsup (magic (3))), infsup ([8; 5; 2])));
***** assert (isequal (diag (infsup ([8 5 3])), infsup ([8 0 0; 0 5 0; 0 0 3])));
***** assert (isequal (diag (infsup (1:2), 2, 3), infsup ([1 0 0; 0 2 0])));
6 tests, 6 passed, 0 known failure, 0 skipped
[inst/@infsup/cbrt.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/cbrt.m
***** # from the documentation string
***** assert (cbrt (infsup (-27, 27)) == infsup (-3, 3));
***** # correct use of signed zeros
***** test
 x = cbrt (infsup (0));
 assert (signbit (inf (x)));
 assert (not (signbit (sup (x))));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.cbrt;
 for testcase = [testcases]'
   assert (isequaln (...
     cbrt (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.cbrt;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (cbrt (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.cbrt;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (cbrt (in1), out));
5 tests, 5 passed, 0 known failure, 0 skipped
[inst/@infsup/sinrev.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/sinrev.m
***** # from the documentation string
***** assert (sinrev (infsup (-1), infsup (0, 6)) == "[0x1.2D97C7F3321D2p2, 0x1.2D97C7F3321D3p2]");
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.sinRev;
 for testcase = [testcases]'
   assert (isequaln (...
     sinrev (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.sinRev;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (sinrev (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.sinRev;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (sinrev (in1), out));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.sinRevBin;
 for testcase = [testcases]'
   assert (isequaln (...
     sinrev (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.sinRevBin;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (sinrev (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.sinRevBin;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (sinrev (in1, in2), out));
7 tests, 7 passed, 0 known failure, 0 skipped
[inst/@infsup/ne.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/ne.m
***** assert (ne (infsup (1, 2), infsup (1, 3)));
1 test, 1 passed, 0 known failure, 0 skipped
[inst/@infsup/csc.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/csc.m
***** # from the documentation string
***** assert (csc (infsup (1)) == "[0x1.303AA9620B223, 0x1.303AA9620B224]");
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.csc;
 for testcase = [testcases]'
   assert (isequaln (...
     csc (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.csc;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (csc (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.csc;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (csc (in1), out));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsup/dot.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/dot.m
***** # matrix × matrix
***** assert (dot (infsup (magic (3)), magic (3)) == [89, 107, 89]);
***** assert (dot (infsup (magic (3)), magic (3), 1) == [89, 107, 89]);
***** assert (dot (infsup (magic (3)), magic (3), 2) == [101; 83; 101]);
***** # matrix × vector
***** assert (dot (infsup (magic (3)), [1, 2, 3]) == [28; 34; 28]);
***** assert (dot (infsup (magic (3)), [1, 2, 3], 1) == [15, 30, 45]);
***** assert (dot (infsup (magic (3)), [1, 2, 3], 2) == [28; 34; 28]);
***** assert (dot (infsup (magic (3)), [1; 2; 3]) == [26, 38, 26]);
***** assert (dot (infsup (magic (3)), [1; 2; 3], 1) == [26, 38, 26]);
***** assert (dot (infsup (magic (3)), [1; 2; 3], 2) == [15; 30; 45]);
***** # matrix × scalar
***** assert (dot (infsup (magic (3)), 42) == [630, 630, 630]);
***** assert (dot (infsup (magic (3)), 42, 1) == [630, 630, 630]);
***** assert (dot (infsup (magic (3)), 42, 2) == [630; 630; 630]);
***** # vector x vector
***** assert (dot (infsup([1, 2, 3]), [4, 5, 6]) == 32);
***** assert (dot (infsup([1, 2, 3]), [4, 5, 6], 1) == [4, 10, 18]);
***** assert (dot (infsup([1, 2, 3]), [4, 5, 6], 2) == 32);
***** assert (dot (infsup([1; 2; 3]), [4; 5; 6]) == 32);
***** assert (dot (infsup([1; 2; 3]), [4; 5; 6], 1) == 32);
***** assert (dot (infsup([1; 2; 3]), [4; 5; 6], 2) == [4; 10; 18]);
***** # vector × scalar
***** assert (dot (infsup ([1, 2, 3]), 42) == 252);
***** assert (dot (infsup ([1, 2, 3]), 42, 1) == [42, 84, 126]);
***** assert (dot (infsup ([1, 2, 3]), 42, 2) == 252);
***** assert (dot (infsup ([1; 2; 3]), 42) == 252);
***** assert (dot (infsup ([1; 2; 3]), 42, 1) == 252);
***** assert (dot (infsup ([1; 2; 3]), 42, 2) == [42; 84; 126]);
***** # N-dimensional arrays
***** test
  x = infsup (reshape (1:24, 2, 3, 4));
  y = infsup (2.*ones (2, 3, 4));
  assert (dot (x, y, 3) == infsup ([80, 96, 112; 88, 104, 120]))
***** test
  x = infsup (ones (2, 2, 2, 2));
  y = infsup (1);
  assert (size (dot (x, y)), [1, 2, 2, 2]);
  assert (size (dot (x, y, 1)), [1, 2, 2, 2]);
  assert (size (dot (x, y, 2)), [2, 1, 2, 2]);
  assert (size (dot (x, y, 3)), [2, 2, 1, 2]);
  assert (size (dot (x, y, 4)), [2, 2, 2]);
  assert (size (dot (x, y, 5)), [2, 2, 2, 2]);
***** # from the documentation string
***** assert (dot ([infsup(1), 2, 3], [infsup(2), 3, 4]) == 20);
***** assert (dot (infsup ([realmax; realmin; realmax]), [1; -1; -1], 1) == -realmin);
28 tests, 28 passed, 0 known failure, 0 skipped
[inst/@infsup/atan2rev1.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/atan2rev1.m
***** # from the documentation string
***** assert (atan2rev1 (infsup (1, 2), infsup ("pi") / 4) == "[0x1.FFFFFFFFFFFFFp-1, 0x1.0000000000001p1]");
1 test, 1 passed, 0 known failure, 0 skipped
[inst/@infsup/pow.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/pow.m
***** # from the documentation string
***** assert (pow (infsup (5, 6), infsup (2, 3)) == infsup (25, 216));
***** # correct use of signed zeros
***** test
 x = pow (infsup (0), infsup (1));
 assert (signbit (inf (x)));
 assert (not (signbit (sup (x))));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.pow;
 for testcase = [testcases]'
   assert (isequaln (...
     pow (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.pow;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (pow (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.pow;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (pow (in1, in2), out));
5 tests, 5 passed, 0 known failure, 0 skipped
[inst/@infsup/ldivide.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/ldivide.m
***** # from the documentation string
***** assert (ldivide (infsup (2, 3), infsup (1, 2)) == "[1/3, 1]");
1 test, 1 passed, 0 known failure, 0 skipped
[inst/@infsup/strictprecedes.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/strictprecedes.m
***** assert (strictprecedes (infsup (1, 1.9), infsup (2.1, 3)));
***** assert (not (strictprecedes (infsup (1, 2), infsup (2, 3))));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.strictPrecedes;
 for testcase = [testcases]'
   assert (isequaln (...
     strictprecedes (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.strictPrecedes;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (strictprecedes (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.strictPrecedes;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (strictprecedes (in1, in2), out));
5 tests, 5 passed, 0 known failure, 0 skipped
[inst/@infsup/gamma.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/gamma.m
***** # from the documentation string
***** assert (gamma (infsup (1.5)) == "[0x1.C5BF891B4EF6Ap-1, 0x1.C5BF891B4EF6Bp-1]");
1 test, 1 passed, 0 known failure, 0 skipped
[inst/@infsup/gt.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/gt.m
***** assert (not (gt (infsup (2, 3), infsup (1, 3))));
***** assert (gt (infsup (2, 3.1), infsup (1, 3)));
2 tests, 2 passed, 0 known failure, 0 skipped
[inst/@infsup/rem.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/rem.m
***** assert (rem (infsup (), infsup ()) == infsup ());
***** assert (rem (infsup (0), infsup ()) == infsup ());
***** assert (rem (infsup (), infsup (0)) == infsup ());
***** assert (rem (infsup (0), infsup (0)) == infsup ());
***** assert (rem (infsup (1), infsup (0)) == infsup ());
***** assert (rem (infsup (0, 1), infsup (0)) == infsup ());
***** assert (rem (infsup (1, 2), infsup (0)) == infsup ());
***** assert (rem (infsup (0, inf), infsup (0)) == infsup ());
***** assert (rem (infsup (1, inf), infsup (0)) == infsup ());
***** assert (rem (infsup (realmax, inf), infsup (0)) == infsup ());
***** assert (rem (infsup (0), infsup (1)) == infsup (0));
***** assert (rem (infsup (0), infsup (0, 1)) == infsup (0));
***** assert (rem (infsup (0), infsup (1, 2)) == infsup (0));
***** assert (rem (infsup (0), infsup (0, inf)) == infsup (0));
***** assert (rem (infsup (0), infsup (1, inf)) == infsup (0));
***** assert (rem (infsup (0), infsup (realmax, inf)) == infsup (0));
***** assert (rem (infsup (1), infsup (1)) == infsup (0));
***** assert (rem (infsup (2), infsup (1)) == infsup (0));
***** assert (rem (infsup (4), infsup (2)) == infsup (0));
***** assert (rem (infsup (6), infsup (3)) == infsup (0));
***** assert (rem (infsup (8), infsup (2)) == infsup (0));
***** assert (rem (infsup (9), infsup (3)) == infsup (0));
***** assert (rem (infsup (realmax), infsup (realmax)) == infsup (0));
***** assert (rem (infsup (realmax), infsup (realmax / 2)) == infsup (0));
***** assert (rem (infsup (realmax), infsup (realmax / 4)) == infsup (0));
***** assert (rem (infsup (realmax), infsup (realmax / 8)) == infsup (0));
***** assert (rem (infsup (realmax), infsup (realmax / 16)) == infsup (0));
***** assert (rem (infsup (realmax), infsup (realmax / 32)) == infsup (0));
***** assert (rem (infsup (0.1), infsup (0.1)) == infsup (0));
***** assert (rem (infsup (0.1 * 2), infsup (0.1)) == infsup (0));
***** assert (rem (infsup (0.1 * 4), infsup (0.1)) == infsup (0));
***** assert (rem (infsup (pi), infsup (pi)) == infsup (0));
***** assert (rem (infsup (pi), infsup (pi / 2)) == infsup (0));
***** assert (rem (infsup (pi), infsup (pi / 4)) == infsup (0));
***** assert (rem (infsup (pow2 (-1074)), infsup (pow2 (-1074))) == infsup (0));
***** assert (rem (infsup (pow2 (-1073)), infsup (pow2 (-1074))) == infsup (0));
***** assert (rem (infsup (pow2 (-1072)), infsup (pow2 (-1074))) == infsup (0));
***** assert (rem (infsup (1), infsup (2)) == infsup (1));
***** assert (rem (infsup (0.5), infsup (1)) == infsup (0.5));
***** assert (rem (infsup (pi), infsup (3.15)) == infsup (pi));
***** assert (rem (infsup (1), infsup (2, 3)) == infsup (1));
***** assert (rem (infsup (1), infsup (2, inf)) == infsup (1));
***** assert (rem (infsup (0.5), infsup (1, 2)) == infsup (0.5));
***** assert (rem (infsup (0.5), infsup (1, inf)) == infsup (0.5));
***** assert (rem (infsup (pi), infsup (3.15)) == infsup (pi));
***** assert (rem (infsup (pi), infsup (3.15, inf)) == infsup (pi));
***** assert (rem (infsup (0, 1), infsup (0, 1)) == infsup (0, 1));
***** assert (rem (infsup (0, 2), infsup (0, 1)) == infsup (0, 1));
***** assert (rem (infsup (0, 1), infsup (0, 2)) == infsup (0, 1));
***** assert (rem (infsup (0, realmax), infsup (0, realmax)) == infsup (0, realmax));
***** assert (rem (infsup (realmax, inf), infsup (realmax, inf)) == infsup (0, inf));
***** assert (rem (infsup (0, inf), infsup (0, inf)) == infsup (0, inf));
***** assert (rem (infsup (0), infsup (1)) == infsup (0));
***** assert (rem (infsup (1), infsup (1)) == infsup (0));
***** assert (rem (infsup (0, 1), infsup (1)) == infsup (0, 1));
***** assert (rem (infsup (1, 2), infsup (1)) == infsup (0, 1));
***** assert (rem (infsup (0, inf), infsup (1)) == infsup (0, 1));
***** assert (rem (infsup (1, inf), infsup (1)) == infsup (0, 1));
***** assert (rem (infsup (realmax, inf), infsup (1)) == infsup (0, 1));
***** assert (rem (infsup (1), infsup (1)) == infsup (0));
***** assert (rem (infsup (1), infsup (0, 1)) == infsup (0, 0.5));
***** assert (rem (infsup (1), infsup (1, 2)) == infsup (0, 1));
***** assert (rem (infsup (1), infsup (0, inf)) == infsup (0, 1));
***** assert (rem (infsup (1), infsup (1, inf)) == infsup (0, 1));
***** assert (rem (infsup (1), infsup (2, inf)) == infsup (1));
***** assert (rem (infsup (1), infsup (realmax, inf)) == infsup (1));
66 tests, 66 passed, 0 known failure, 0 skipped
[inst/@infsup/roundb.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/roundb.m
***** # Empty interval
***** assert (roundb (infsup ()) == infsup ());
***** # Singleton intervals
***** assert (roundb (infsup (0)) == infsup (0));
***** assert (roundb (infsup (0.5)) == infsup (0));
***** assert (roundb (infsup (0.25)) == infsup (0));
***** assert (roundb (infsup (0.75)) == infsup (1));
***** assert (roundb (infsup (1.5)) == infsup (2));
***** assert (roundb (infsup (-0.5)) == infsup (0));
***** assert (roundb (infsup (-1.5)) == infsup (-2));
***** # Bounded intervals
***** assert (roundb (infsup (-0.5, 0)) == infsup (0));
***** assert (roundb (infsup (0, 0.5)) == infsup (0));
***** assert (roundb (infsup (0.25, 0.5)) == infsup (0));
***** assert (roundb (infsup (-1, 0)) == infsup (-1, 0));
***** assert (roundb (infsup (-1, 1)) == infsup (-1, 1));
***** assert (roundb (infsup (-realmin, realmin)) == infsup (0));
***** assert (roundb (infsup (-realmax, realmax)) == infsup (-realmax, realmax));
***** # Unbounded intervals
***** assert (roundb (infsup (-realmin, inf)) == infsup (0, inf));
***** assert (roundb (infsup (-realmax, inf)) == infsup (-realmax, inf));
***** assert (roundb (infsup (-inf, realmin)) == infsup (-inf, 0));
***** assert (roundb (infsup (-inf, realmax)) == infsup (-inf, realmax));
***** assert (roundb (infsup (-inf, inf)) == infsup (-inf, inf));
***** # correct use of signed zeros
***** test
 x = roundb (infsup (0));
 assert (signbit (inf (x)));
 assert (not (signbit (sup (x))));
***** test
 x = roundb (infsup (-0.25, 0.25));
 assert (signbit (inf (x)));
 assert (not (signbit (sup (x))));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.roundTiesToEven;
 for testcase = [testcases]'
   assert (isequaln (...
     roundb (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.roundTiesToEven;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (roundb (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.roundTiesToEven;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (roundb (in1), out));
25 tests, 25 passed, 0 known failure, 0 skipped
[inst/@infsup/times.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/times.m
***** # from the documentation string
***** assert (infsup (2, 3) .* infsup (1, 2) == infsup (2, 6));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.mul;
 for testcase = [testcases]'
   assert (isequaln (...
     times (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.mul;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (times (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.mul;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (times (in1, in2), out));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsup/lu.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/lu.m
***** test
 [l, u] = lu (infsup (magic (3)));
 assert (l == infsup ({1, 0, 0; .375, 1, 0; .5, "68/37", 1}));, ...
 assert (subset (u, infsup ({8, 1, 6; 0, 4.625, 4.75; 0, 0, "-0x1.3759F2298375Bp3"}, ...
                            {8, 1, 6; 0, 4.625, 4.75; 0, 0, "-0x1.3759F22983759p3"})));
***** test
 A = magic (3);
 A([1, 5, 9]) = 0;
 [l, u, p] = lu (infsup (A));
 assert (p, [0, 0, 1; 1, 0, 0; 0, 1, 0]);
 assert (l == infsup ({1, 0, 0; "4/3", 1, 0; 0, "1/9", 1}));
 assert (subset (u, infsup ({3, 0, 7; 0, 9, "-0x1.2AAAAAAAAAAACp3"; 0, 0, "0x1.C25ED097B425Ep2"}, ...
                            {3, 0, 7; 0, 9, "-0x1.2AAAAAAAAAAAAp3"; 0, 0, "0x1.C25ED097B426p2"})));
2 tests, 2 passed, 0 known failure, 0 skipped
[inst/@infsup/intersect.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/intersect.m
***** # Empty interval
***** assert (intersect (infsup (), infsup ()) == infsup ());
***** assert (intersect (infsup (), infsup (1)) == infsup ());
***** assert (intersect (infsup (0), infsup ()) == infsup ());
***** assert (intersect (infsup (-inf, inf), infsup ()) == infsup ());
***** # Singleton intervals
***** assert (intersect (infsup (0), infsup (1)) == infsup ());
***** assert (intersect (infsup (0), infsup (0)) == infsup (0));
***** # Bounded intervals
***** assert (intersect (infsup (1, 2), infsup (3, 4)) == infsup ());
***** assert (intersect (infsup (1, 2), infsup (2, 3)) == infsup (2));
***** assert (intersect (infsup (1, 2), infsup (1.5, 2.5)) == infsup (1.5, 2));
***** assert (intersect (infsup (1, 2), infsup (1, 2)) == infsup (1, 2));
***** # Unbounded intervals
***** assert (intersect (infsup (0, inf), infsup (-inf, 0)) == infsup (0));
***** assert (intersect (infsup (1, inf), infsup (-inf, -1)) == infsup ());
***** assert (intersect (infsup (-1, inf), infsup (-inf, 1)) == infsup (-1, 1));
***** assert (intersect (infsup (-inf, inf), infsup (42)) == infsup (42));
***** assert (intersect (infsup (42), infsup (-inf, inf)) == infsup (42));
***** assert (intersect (infsup (-inf, 0), infsup (-inf, inf)) == infsup (-inf, 0));
***** assert (intersect (infsup (-inf, inf), infsup (-inf, inf)) == infsup (-inf, inf));
***** # from the documentation string
***** assert (intersect (infsup (1, 3), infsup (2, 4)) == infsup (2, 3));
***** # correct use of signed zeros
***** test
 x = intersect (infsup (0), infsup (0));
 assert (signbit (inf (x)));
 assert (not (signbit (sup (x))));
***** test
 x = intersect (infsup (0), infsup (0, 1));
 assert (signbit (inf (x)));
 assert (not (signbit (sup (x))));
***** test
 x = intersect (infsup (0, 1), infsup (0));
 assert (signbit (inf (x)));
 assert (not (signbit (sup (x))));
***** test
 x = intersect (infsup (-1, 0), infsup (0, 1));
 assert (signbit (inf (x)));
 assert (not (signbit (sup (x))));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.intersection;
 for testcase = [testcases]'
   assert (isequaln (...
     intersect (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.intersection;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (intersect (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.intersection;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (intersect (in1, in2), out));
25 tests, 25 passed, 0 known failure, 0 skipped
[inst/@infsup/cos.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/cos.m
***** # from the documentation string
***** assert (cos (infsup (1)) == "[0x1.14A280FB5068Bp-1, 0x1.14A280FB5068Cp-1]");
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.cos;
 for testcase = [testcases]'
   assert (isequaln (...
     cos (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.cos;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (cos (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.cos;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (cos (in1), out));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsup/eq.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/eq.m
***** test "Empty interval";
 assert (eq (infsup (), infsup ()) == true);
 assert (eq (infsup (), infsup (1)) == false);
 assert (eq (infsup (0), infsup ()) == false);
 assert (eq (infsup (-inf, inf), infsup ()) == false);
***** test "Singleton intervals";
 assert (eq (infsup (0), infsup (1)) == false);
 assert (eq (infsup (0), infsup (0)) == true);
***** test "Bounded intervals";
 assert (eq (infsup (1, 2), infsup (3, 4)) == false);
 assert (eq (infsup (1, 2), infsup (2, 3)) == false);
 assert (eq (infsup (1, 2), infsup (1.5, 2.5)) == false);
 assert (eq (infsup (1, 2), infsup (1, 2)) == true);
***** test "Unbounded intervals";
 assert (eq (infsup (0, inf), infsup (-inf, 0)) == false);
 assert (eq (infsup (0, inf), infsup (0, inf)) == true);
 assert (eq (infsup (-inf, 0), infsup (-inf, 0)) == true);
 assert (eq (infsup (-inf, inf), infsup (42)) == false);
 assert (eq (infsup (-inf, 0), infsup (-inf, inf)) == false);
 assert (eq (infsup (-inf, inf), infsup (-inf, inf)) == true);
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.equal;
 for testcase = [testcases]'
   assert (isequaln (...
     eq (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.equal;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (eq (in1, in2), out));
***** test
 # N-dimensional array evaluations
 testcases = testdata.NoSignal.infsup.equal;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (eq (in1, in2), out));
7 tests, 7 passed, 0 known failure, 0 skipped
[inst/@infsup/coth.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/coth.m
***** # from the documentation string
***** assert (coth (infsup (1)) == "[0x1.50231499B6B1D, 0x1.50231499B6B1E]");
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.coth;
 for testcase = [testcases]'
   assert (isequaln (...
     coth (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.coth;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (coth (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.coth;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (coth (in1), out));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsup/iscommoninterval.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/iscommoninterval.m
***** assert (iscommoninterval (infsup (2, 3)));
***** assert (not (iscommoninterval (infsup (2, inf))));
***** assert (not (iscommoninterval (infsup ())));
***** assert (not (iscommoninterval (infsup (-inf, inf))));
***** assert (iscommoninterval (infsupdec (2, 3, "com")));
***** assert (iscommoninterval (infsupdec (2, 3, "trv")));
***** assert (not (iscommoninterval (infsupdec (2, inf, "trv"))));
***** assert (not (iscommoninterval (empty ())));
***** assert (not (iscommoninterval (entire ())));
***** warning assert (not (iscommoninterval (infsupdec (2, 1))));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.isCommonInterval;
 for testcase = [testcases]'
   assert (isequaln (...
     iscommoninterval (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.isCommonInterval;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (iscommoninterval (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.isCommonInterval;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (iscommoninterval (in1), out));
***** test
 # Decorated scalar evaluation
 testcases = testdata.NoSignal.infsupdec.isCommonInterval;
 for testcase = [testcases]'
   assert (isequaln (...
     iscommoninterval (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Decorated vector evaluation
 testcases = testdata.NoSignal.infsupdec.isCommonInterval;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (iscommoninterval (in1), out));
***** test
 # Decorated N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.isCommonInterval;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (iscommoninterval (in1), out));
16 tests, 16 passed, 0 known failure, 0 skipped
[inst/@infsup/sech.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/sech.m
***** # from the documentation string
***** assert (sech (infsup (1)) == "[0x1.4BCDC50ED6BE7p-1, 0x1.4BCDC50ED6BE8p-1]");
***** # correct use of signed zeros
***** test
 x = sech (infsup (0, inf));
 assert (signbit (inf (x)));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.sech;
 for testcase = [testcases]'
   assert (isequaln (...
     sech (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.sech;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (sech (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.sech;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (sech (in1), out));
5 tests, 5 passed, 0 known failure, 0 skipped
[inst/@infsup/nextout.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/nextout.m
***** # from the documentation string
***** test
 x = nextout (infsup (1));
 assert (inf (x), 1 - eps / 2);
 assert (sup (x), 1 + eps);
***** # correct use of signed zeros
***** test
 x = nextout (infsup (pow2 (-1074)));
 assert (signbit (inf (x)));
***** test
 x = nextout (infsup (-pow2 (-1074)));
 assert (not (signbit (sup (x))));
3 tests, 3 passed, 0 known failure, 0 skipped
[inst/@infsup/sdist.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/sdist.m
***** # from the documentation string
***** assert (sdist (infsup (0, 6), infsup (7, 20)), -1);
***** assert (sdist (infsup (3, 5), infsup (0, 1)), 2);
2 tests, 2 passed, 0 known failure, 0 skipped
[inst/@infsup/union.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/union.m
***** # from the documentation string
***** assert (union (infsup (1, 3), infsup (2, 4)) == infsup (1, 4));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.convexHull;
 for testcase = [testcases]'
   assert (isequaln (...
     union (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.convexHull;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (union (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.convexHull;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (union (in1, in2), out));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsup/ismatrix.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/ismatrix.m
***** assert (ismatrix (infsup ([])));
***** assert (ismatrix (infsup (0)));
***** assert (ismatrix (infsup (zeros (3, 1))));
***** assert (ismatrix (infsup (zeros (1, 4))));
***** assert (ismatrix (infsup (zeros (3, 4))));
5 tests, 5 passed, 0 known failure, 0 skipped
[inst/@infsup/pow10.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/pow10.m
***** # from the documentation string
 assert (pow10 (infsup (5)) == infsup (100000));
***** # correct use of signed zeros
***** test
 x = pow10 (infsup (-inf, -realmax));
 assert (signbit (inf (x)));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.exp10;
 for testcase = [testcases]'
   assert (isequaln (...
     pow10 (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.exp10;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (pow10 (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.exp10;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (pow10 (in1), out));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsup/psi.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/psi.m
***** assert (isempty (psi (infsup (0))));
***** assert (isempty (psi (infsup (-1))));
***** assert (isempty (psi (infsup (-2))));
***** assert (isempty (psi (infsup (-3))));
***** assert (isentire (psi (infsup (-inf, -42.23))));
***** assert (isentire (psi (infsup (0, inf))));
***** assert (isentire (psi (infsup (-1, 0))));
***** assert (isentire (psi (infsup (-2, -1))));
***** assert (isentire (psi (infsup (-eps, eps))));
***** assert (isentire (psi (infsup (-1-eps, -1+eps))));
***** assert (isentire (psi (infsup (-4.1, -3.9))));
***** # from the documentation string
***** assert (psi (infsup (1)) == "[-0x1.2788CFC6FB619p-1, -0x1.2788CFC6FB618p-1]");
12 tests, 12 passed, 0 known failure, 0 skipped
[inst/@infsup/power.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/power.m
***** # from the documentation string
***** assert (infsup (-5, 6) .^ infsup (2, 3) == infsup (-125, 216));
***** assert (infsup (-10, 0) .^ infsup (0, 1:8) == infsup ([-1e1, -1e1, -1e3, -1e3, -1e5, -1e5, -1e7, -1e7], [1e0, 1e2, 1e2, 1e4, 1e4, 1e6, 1e6, 1e8]));
***** # correct use of signed zeros
***** test
 x = power (infsup (0), infsup (1));
 assert (signbit (inf (x)));
 assert (not (signbit (sup (x))));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.sqr;
 for testcase = [testcases]'
   assert (isequaln (...
     power (testcase.in{1}, 2), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.sqr;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (power (in1, 2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.sqr;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (power (in1, 2), out));
6 tests, 6 passed, 0 known failure, 0 skipped
[inst/@infsup/issquare.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/issquare.m
***** assert (issquare (infsup ([])));
***** assert (issquare (infsup (0)));
***** assert (not (issquare (infsup (zeros (1, 2)))));
***** assert (not (issquare (infsup (zeros (2, 1)))));
***** assert (issquare (infsup (zeros (5))));
5 tests, 5 passed, 0 known failure, 0 skipped
[inst/@infsup/rsqrt.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/rsqrt.m
***** # from the documentation string
***** assert (rsqrt (infsup (-6, 4)) == infsup (.5, inf));
***** # correct use of signed zeros
***** test
 x = rsqrt (infsup (0, inf));
 assert (signbit (inf (x)));
2 tests, 2 passed, 0 known failure, 0 skipped
[inst/@infsup/atanh.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/atanh.m
***** # from the documentation string
***** assert (atanh (infsup (.5)) == "[0x1.193EA7AAD030Ap-1, 0x1.193EA7AAD030Bp-1]");
***** # correct use of signed zeros
***** test
 x = atanh (infsup (0));
 assert (signbit (inf (x)));
 assert (not (signbit (sup (x))));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.atanh;
 for testcase = [testcases]'
   assert (isequaln (...
     atanh (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.atanh;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (atanh (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.atanh;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (atanh (in1), out));
5 tests, 5 passed, 0 known failure, 0 skipped
[inst/@infsup/sqrrev.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/sqrrev.m
***** # from the documentation string
***** assert (sqrrev (infsup (-2, 1)) == infsup (-1, 1));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.sqrRev;
 for testcase = [testcases]'
   assert (isequaln (...
     sqrrev (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.sqrRev;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (sqrrev (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.sqrRev;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (sqrrev (in1), out));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.sqrRevBin;
 for testcase = [testcases]'
   assert (isequaln (...
     sqrrev (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.sqrRevBin;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (sqrrev (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.sqrRevBin;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (sqrrev (in1, in2), out));
7 tests, 7 passed, 0 known failure, 0 skipped
[inst/@infsup/sign.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/sign.m
***** # from the documentation string
***** assert (sign (infsup (2, 3)) == infsup (1));
***** assert (sign (infsup (0, 5)) == infsup (0, 1));
***** assert (sign (infsup (-17)) == infsup (-1));
***** # correct use of signed zeros
***** test
 x = sign (infsup (0));
 assert (signbit (inf (x)));
 assert (not (signbit (sup (x))));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.sign;
 for testcase = [testcases]'
   assert (isequaln (...
     sign (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.sign;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (sign (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.sign;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (sign (in1), out));
7 tests, 7 passed, 0 known failure, 0 skipped
[inst/@infsup/end.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/end.m
***** assert (infsup (magic (3))(end) == 2);
***** assert (infsup (magic (3))(end, 2) == 9);
***** assert (infsup (magic (3))(2, end) == 7);
***** assert (infsup ([1 2; 3 4; 5 6])(end:-1:1, :) == [5 6; 3 4; 1 2]);
***** assert (reshape (infsup (1:24), 2, 3, 4)(end, end) == 24)
5 tests, 5 passed, 0 known failure, 0 skipped
[inst/@infsup/subsasgn.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/subsasgn.m
***** test
 A = infsup (magic (3));
 A(4, 4) = 42;
 assert (inf (A), [magic(3),[0;0;0];0,0,0,42]);
 assert (sup (A), [magic(3),[0;0;0];0,0,0,42]);
1 test, 1 passed, 0 known failure, 0 skipped
[inst/@infsup/coshrev.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/coshrev.m
***** # from the documentation string
***** assert (coshrev (infsup (-2, 1)) == 0);
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.coshRev;
 for testcase = [testcases]'
   assert (isequaln (...
     coshrev (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.coshRev;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (coshrev (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.coshRev;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (coshrev (in1), out));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.coshRevBin;
 for testcase = [testcases]'
   assert (isequaln (...
     coshrev (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.coshRevBin;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (coshrev (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.coshRevBin;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (coshrev (in1, in2), out));
7 tests, 7 passed, 0 known failure, 0 skipped
[inst/@infsup/tan.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/tan.m
***** # from the documentation string
***** assert (tan (infsup (1)) == "[0x1.8EB245CBEE3A5, 0x1.8EB245CBEE3A6]");
***** # correct use of signed zeros
***** test
 x = tan (infsup (0));
 assert (signbit (inf (x)));
 assert (not (signbit (sup (x))));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.tan;
 for testcase = [testcases]'
   assert (isequaln (...
     tan (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.tan;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (tan (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.tan;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (tan (in1), out));
5 tests, 5 passed, 0 known failure, 0 skipped
[inst/@infsup/isrow.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/isrow.m
***** assert (not (isrow (infsup ([]))));
***** assert (isrow (infsup (0)));
***** assert (isrow (infsup (zeros (1, 2))));
***** assert (not (isrow (infsup (zeros (2, 1)))));
***** assert (not (isrow (infsup (zeros (5)))));
5 tests, 5 passed, 0 known failure, 0 skipped
[inst/@infsup/strictsubset.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/strictsubset.m
***** assert (strictsubset (infsup (1, 2), infsup (1, 3)));
***** assert (strictsubset (infsup (2, 3), infsup (1, 3)));
***** assert (not (strictsubset (infsup (1, 2), infsup (1, 2))));
***** assert (not (strictsubset (infsup (1, 3), infsup (1, 2))));
***** assert (strictsubset (infsup (), infsup (1, 3)));
***** assert (not (strictsubset (infsup (), infsup ())));
***** assert (strictsubset (infsup (), infsup (-inf, inf)));
***** assert (strictsubset (infsup (0, inf), infsup (-inf, inf)));
***** assert (strictsubset (infsup (-inf, 0), infsup (-inf, inf)));
***** assert (not (strictsubset (infsup (-inf, inf), infsup (-inf, inf))));
10 tests, 10 passed, 0 known failure, 0 skipped
[inst/@infsup/subsref.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/subsref.m
***** assert (infsup (magic (3))([1, 2, 3]) == magic (3)([1, 2, 3]));
***** # from the documentation string
***** test
 x = infsup (magic (3), magic (3) + 1);
 assert (x(1) == infsup (8, 9));
 assert (x(:, 2) == infsup ([1; 5; 9], [2; 6; 10]));
 assert (x.inf, magic (3));
***** assert (reshape (infsup (1:16), 2, 2, 2, 2)(2, 7) == infsup (14))
***** assert (reshape (infsup (1:16), 2, 2, 2, 2)(:, 2, 2, 2) == infsup ([15; 16]))
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsup/issingleton.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/issingleton.m
***** assert (issingleton (infsup (0)));
***** assert (issingleton (infsupdec (0)));
***** assert (not (issingleton (entire ())));
***** assert (not (issingleton (intervalpart (entire ()))));
***** assert (not (issingleton (empty ())));
***** assert (not (issingleton (intervalpart (empty ()))));
***** warning assert (not (issingleton (infsupdec (2, 1))));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.isSingleton;
 for testcase = [testcases]'
   assert (isequaln (...
     issingleton (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.isSingleton;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (issingleton (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.isSingleton;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (issingleton (in1), out));
***** test
 # Decorated scalar evaluation
 testcases = testdata.NoSignal.infsupdec.isSingleton;
 for testcase = [testcases]'
   assert (isequaln (...
     issingleton (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Decorated vector evaluation
 testcases = testdata.NoSignal.infsupdec.isSingleton;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (issingleton (in1), out));
***** test
 # Decorated N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.isSingleton;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (issingleton (in1), out));
13 tests, 13 passed, 0 known failure, 0 skipped
[inst/@infsup/precedes.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/precedes.m
***** assert (precedes (infsup (1, 2), infsup (2, 3)));
***** assert (not (precedes (infsup (1, 2.1), infsup (1.9, 3))));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.precedes;
 for testcase = [testcases]'
   assert (isequaln (...
     precedes (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.precedes;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (precedes (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.precedes;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (precedes (in1, in2), out));
5 tests, 5 passed, 0 known failure, 0 skipped
[inst/@infsup/sup.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/sup.m
***** # from the documentation string
***** assert (sup (infsup (2.5, 3.5)), 3.5);
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.sup;
 for testcase = [testcases]'
   assert (isequaln (...
     sup (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.sup;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (sup (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.sup;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (sup (in1), out));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsup/tril.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/tril.m
***** assert (tril (infsup (magic (10))) == tril (magic (10)));
***** assert (tril (infsup (magic (10)), 1) == tril (magic (10), 1));
***** assert (tril (infsup (magic (10)), -1) == tril (magic (10), -1));
***** assert (tril (infsup (magic (10)), 0, "pack") == tril (magic (10), 0, "pack"));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsup/wid.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/wid.m
***** # from the documentation string
***** assert (wid (infsup (2.5, 3.5)), 1);
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.wid;
 for testcase = [testcases]'
   assert (isequaln (...
     wid (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.wid;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (wid (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.wid;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (wid (in1), out));
***** test
 # Decorated scalar evaluation
 testcases = testdata.NoSignal.infsupdec.wid;
 for testcase = [testcases]'
   assert (isequaln (...
     wid (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Decorated vector evaluation
 testcases = testdata.NoSignal.infsupdec.wid;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (wid (in1), out));
***** test
 # Decorated N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.wid;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (wid (in1), out));
7 tests, 7 passed, 0 known failure, 0 skipped
[inst/@infsup/erfc.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/erfc.m
***** # from the documentation string
***** assert (erfc (infsup (1)) == "[0x1.4226162FBDDD4p-3, 0x1.4226162FBDDD5p-3]");
***** # correct use of signed zeros
***** test
 x = erfc (infsup (realmax));
 assert (signbit (inf (x)));
 assert (not (signbit (sup (x))));
2 tests, 2 passed, 0 known failure, 0 skipped
[inst/@infsup/cot.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/cot.m
***** # from the documentation string
***** assert (cot (infsup (1)) == "[0x1.48C05D04E1CFDp-1, 0x1.48C05D04E1CFEp-1]");
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.cot;
 for testcase = [testcases]'
   assert (isequaln (...
     cot (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.cot;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (cot (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.cot;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (cot (in1), out));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsup/log1p.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/log1p.m
***** # from the documentation string
***** assert (log1p (infsup (eps)) == "[0x1.FFFFFFFFFFFFFp-53, 0x1p-52]");
***** # correct use of signed zeros
***** test
 x = log1p (infsup (0));
 assert (signbit (inf (x)));
 assert (not (signbit (sup (x))));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.logp1;
 for testcase = [testcases]'
   assert (isequaln (...
     log1p (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.logp1;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (log1p (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.logp1;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (log1p (in1), out));
5 tests, 5 passed, 0 known failure, 0 skipped
[inst/@infsup/setdiff.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/setdiff.m
***** assert (isempty (setdiff (infsup (), infsup (1, 4))));
***** assert (setdiff (infsup (1, 3), infsup ()) == infsup (1, 3));
***** assert (isempty (setdiff (infsup (1, 3), infsup (-inf, inf))));
***** assert (isempty (setdiff (infsup (1, 3), infsup (1, 4))));
***** assert (setdiff (infsup (-inf, inf), infsup (1, 4)) == infsup (-inf, inf));
***** # from the documentation string
 assert (setdiff (infsup (1, 3), infsup (2, 4)) == infsup (1, 2));
5 tests, 5 passed, 0 known failure, 0 skipped
[inst/@infsup/ndims.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/ndims.m
***** assert (ndims (infsup ([])), 2);
***** assert (ndims (infsup (0)), 2);
***** assert (ndims (infsup (magic (3))), 2);
3 tests, 3 passed, 0 known failure, 0 skipped
[inst/@infsup/linspace.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/linspace.m
***** assert (isequal (linspace (infsup (0), infsup (10), 9), infsup (linspace (0, 10, 9))));
***** # correct use of signed zeros
***** test
 x = linspace (infsup (0), infsup (0));
 assert (all (signbit (inf (x))));
 assert (all (not (signbit (sup (x)))));
2 tests, 2 passed, 0 known failure, 0 skipped
[inst/@infsup/min.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/min.m
***** # from the documentation string
***** assert (min (infsup (2, 3), infsup (1, 2)) == infsup (1, 2));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.min;
 for testcase = [testcases]'
   assert (isequaln (...
     min (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.min;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (min (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.min;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (min (in1, in2), out));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsup/disjoint.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/disjoint.m
***** assert (disjoint (infsup (3, 4), infsup (5, 6)));
***** assert (not (disjoint (infsup (3, 4), infsup (4, 5))));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.disjoint;
 for testcase = [testcases]'
   assert (isequaln (...
     disjoint (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.disjoint;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (disjoint (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.disjoint;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (disjoint (in1, in2), out));
5 tests, 5 passed, 0 known failure, 0 skipped
[inst/@infsup/prod.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/prod.m
***** # from the documentation string
***** assert (prod (infsup (1 : 4)) == 24);
***** assert (prod (infsup ([])) == 1);
***** assert (prod (infsup (magic (3))) == [96, 45, 84]);
***** assert (prod (infsup (magic (3)), 2) == [48; 105; 72]);
***** assert (prod (infsup (magic (3)), 3) == magic (3));
***** assert (prod (prod (reshape (infsup (1:24), 1, 2, 3, 4))) == reshape ([720, 665280, 13366080, 96909120], 1, 1, 1, 4))
6 tests, 6 passed, 0 known failure, 0 skipped
[inst/@infsup/cosh.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/cosh.m
***** # from the documentation string
***** assert (cosh (infsup (1)) == "[0x1.8B07551D9F55, 0x1.8B07551D9F551]");
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.cosh;
 for testcase = [testcases]'
   assert (isequaln (...
     cosh (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.cosh;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (cosh (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.cosh;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (cosh (in1), out));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsup/isentire.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/isentire.m
***** assert (isentire (entire ()));
***** assert (isentire (intervalpart (entire ())));
***** assert (not (isentire (empty ())));
***** assert (not (isentire (intervalpart (empty ()))));
***** warning assert (not (isentire (infsupdec (2, 1))));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.isEntire;
 for testcase = [testcases]'
   assert (isequaln (...
     isentire (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.isEntire;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (isentire (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.isEntire;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (isentire (in1), out));
***** test
 # Decorated scalar evaluation
 testcases = testdata.NoSignal.infsupdec.isEntire;
 for testcase = [testcases]'
   assert (isequaln (...
     isentire (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Decorated vector evaluation
 testcases = testdata.NoSignal.infsupdec.isEntire;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (isentire (in1), out));
***** test
 # Decorated N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.isEntire;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (isentire (in1), out));
11 tests, 11 passed, 0 known failure, 0 skipped
[inst/@infsup/asin.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/asin.m
***** # Empty interval
***** assert (asin (infsup ()) == infsup ());
***** # from the documentation string
***** assert (asin (infsup (.5)) == "[0x1.0C152382D7365p-1, 0x1.0C152382D7366p-1]");
***** # correct use of signed zeros
***** test
 x = asin (infsup (0));
 assert (signbit (inf (x)));
 assert (not (signbit (sup (x))));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.asin;
 for testcase = [testcases]'
   assert (isequaln (...
     asin (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.asin;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (asin (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.asin;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (asin (in1), out));
6 tests, 6 passed, 0 known failure, 0 skipped
[inst/@infsup/resize.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/resize.m
***** assert (resize (infsup (magic (3)), 4, 2) == infsup ([8, 1; 3, 5; 4, 9; 0, 0]));
***** assert (resize (infsup (ones (2, 2, 2)), 4, 1, 2) == infsup (resize (ones (2, 2, 2), 4, 1, 2)))
2 tests, 2 passed, 0 known failure, 0 skipped
[inst/@infsup/acos.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/acos.m
***** # Empty interval
***** assert (acos (infsup ()) == infsup ());
***** # Singleton intervals
***** assert (acos (infsup (-1)) == infsup ("pi"));
***** assert (subset (acos (infsup (-.5)), union ((infsup ("pi") / 2), infsup ("pi"))));
***** assert (acos (infsup (0)) == infsup ("pi") / 2);
***** assert (subset (acos (infsup (.5)), union ((infsup ("pi") / 2), infsup (0))));
***** assert (acos (infsup (1)) == infsup (0));
***** # Bounded intervals
***** assert (acos (infsup (-1, 0)) == union ((infsup ("pi") / 2), infsup ("pi")));
***** assert (acos (infsup (0, 1)) == union ((infsup ("pi") / 2), infsup (0)));
***** assert (acos (infsup (-1, 1)) == infsup (0, "pi"));
***** assert (acos (infsup (-2, 2)) == infsup (0, "pi"));
***** # Unbounded intervals
***** assert (acos (infsup (0, inf)) == union ((infsup ("pi") / 2), infsup (0)));
***** assert (acos (infsup (-inf, 0)) == union ((infsup ("pi") / 2), infsup ("pi")));
***** assert (acos (infsup (-inf, inf)) == infsup (0, "pi"));
***** # from the documentation string
***** assert (acos (infsup (.5)) == "[0x1.0C152382D7365, 0x1.0C152382D7366]");
***** # correct use of signed zeros
***** test
 x = acos (infsup (1));
 assert (signbit (inf (x)));
 assert (not (signbit (sup (x))));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.acos;
 for testcase = [testcases]'
   assert (isequaln (...
     acos (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.acos;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (acos (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.acos;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (acos (in1), out));
18 tests, 18 passed, 0 known failure, 0 skipped
[inst/@infsup/subset.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/subset.m
***** assert (subset (infsup (1, 2), infsup (1, 3)));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.subset;
 for testcase = [testcases]'
   assert (isequaln (...
     subset (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.subset;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (subset (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.subset;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (subset (in1, in2), out));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsup/mid.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/mid.m
***** assert (mid (infsup (-inf, inf)), 0);
***** # from the documentation string
***** assert (mid (infsup (2.5, 3.5)), 3);
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.mid;
 for testcase = [testcases]'
   assert (isequaln (...
     mid (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.mid;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (mid (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.mid;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (mid (in1), out));
***** test
 # Decorated scalar evaluation
 testcases = testdata.NoSignal.infsupdec.mid;
 for testcase = [testcases]'
   assert (isequaln (...
     mid (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Decorated vector evaluation
 testcases = testdata.NoSignal.infsupdec.mid;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (mid (in1), out));
***** test
 # Decorated N-dimensional array evaluation
 testcases = testdata.NoSignal.infsupdec.mid;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (mid (in1), out));
8 tests, 8 passed, 0 known failure, 0 skipped
[inst/@infsup/sqrt.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/sqrt.m
***** # from the documentation string
***** assert (sqrt (infsup (-6, 4)) == infsup (0, 2));
1 test, 1 passed, 0 known failure, 0 skipped
[inst/@infsup/mpower.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/mpower.m
***** # from the documentation string
***** assert (isequal (infsup (magic (3)) ^ 2, infsup (magic (3) ^ 2)));
***** # correct use of signed zeros
***** test
 x = mpower (infsup (eye (2)), 2);
 assert (signbit (inf (x(1, 2))));
 assert (not (signbit (sup (x(1, 2)))));
2 tests, 2 passed, 0 known failure, 0 skipped
[inst/@infsup/rad.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/rad.m
***** test;
 [m, r] = rad (infsup (2.5, 3.5));
 assert (m, 3);
 assert (r, .5);
***** # from the documentation string
***** assert (rad (infsup (2.5, 3.5)), .5);
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.rad;
 for testcase = [testcases]'
   assert (isequaln (...
     rad (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.rad;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (rad (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.rad;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (rad (in1), out));
***** test
 # Decorated scalar evaluation
 testcases = testdata.NoSignal.infsupdec.rad;
 for testcase = [testcases]'
   assert (isequaln (...
     rad (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Decorated vector evaluation
 testcases = testdata.NoSignal.infsupdec.rad;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (rad (in1), out));
***** test
 # Decorated N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.rad;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (rad (in1), out));
8 tests, 8 passed, 0 known failure, 0 skipped
[inst/@infsup/chol.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/chol.m
***** assert (chol (infsup (pascal (10))) == chol (pascal (10)));
***** assert (chol (infsupdec (pascal (10))) == chol (pascal (10)));
***** test
 A = infsup ([2, 1; 1, 1]);
 R = chol (A);
 assert (ismember ([sqrt(2), 1/sqrt(2); 0, 1/sqrt(2)], R));
 assert (wid (R) < 1e-15);
3 tests, 3 passed, 0 known failure, 0 skipped
[inst/@infsup/length.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/length.m
***** assert (length (infsup ([])), 0);
***** assert (length (infsup (0)), 1);
***** assert (length (infsup (zeros (3, 1))), 3);
***** assert (length (infsup (zeros (1, 4))), 4);
***** assert (length (infsup (zeros (3, 4))), 4);
5 tests, 5 passed, 0 known failure, 0 skipped
[inst/@infsup/setxor.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/setxor.m
***** test
 [z, z1, z2] = setxor (infsup (), infsup ());
 assert (isempty (z));
 assert (isempty (z1));
 assert (isempty (z2));
***** test
 [z, z1, z2] = setxor (infsup (-inf, inf), infsup ());
 assert (isentire (z));
 assert (isentire (z1));
 assert (isempty (z2));
***** test
 [z, z1, z2] = setxor (infsup (-inf, inf), infsup (2));
 assert (isentire (z));
 assert (z1 == infsup (-inf, 2));
 assert (z2 == infsup (2, inf));
***** test
 [z, z1, z2] = setxor (infsup (2, 3), infsup (2));
 assert (z == infsup (2, 3));
 assert (z1 == infsup ());
 assert (z2 == infsup (2, 3));
***** test
 [z, z1, z2] = setxor (infsup (2, 3), infsup (2, 2.5));
 assert (z == infsup (2.5, 3));
 assert (z1 == infsup ());
 assert (z2 == infsup (2.5, 3));
***** # from the documentation string
***** test
 [z, z1, z2] = setxor (infsup (1, 3), infsup (2, 4));
 assert (z == infsup (1, 4));
 assert (z1 == infsup (1, 2));
 assert (z2 == infsup (3, 4));
6 tests, 6 passed, 0 known failure, 0 skipped
[inst/@infsup/fzero.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/fzero.m
***** test "from the documentation string";
 f = @(x) cos (x);
 df = @(x) -sin (x);
 zeros = fzero (f, infsup ("[-10, 10]"), df);
 assert (all (subset (pi * (-2.5:1:2.5)', zeros)));
 assert (max (rad (zeros)) < 8 * eps);
 sqr = @(x) x .^ 2;
 zeros = fzero (sqr, infsup ("[Entire]"));
 assert (all (subset (0, zeros)));
 assert (max (rad (zeros)) < eps);
1 test, 1 passed, 0 known failure, 0 skipped
[inst/@infsup/asinh.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/asinh.m
***** # from the documentation string
***** assert (asinh (infsup (1)) == "[0x1.C34366179D426p-1, 0x1.C34366179D427p-1]");
***** # correct use of signed zeros
***** test
 x = asinh (infsup (0));
 assert (signbit (inf (x)));
 assert (not (signbit (sup (x))));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.asinh;
 for testcase = [testcases]'
   assert (isequaln (...
     asinh (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.asinh;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (asinh (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.asinh;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (asinh (in1), out));
5 tests, 5 passed, 0 known failure, 0 skipped
[inst/@infsup/round.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/round.m
***** # Empty interval
***** assert (round (infsup ()) == infsup ());
***** # Singleton intervals
***** assert (round (infsup (0)) == infsup (0));
***** assert (round (infsup (0.5)) == infsup (1));
***** assert (round (infsup (0.25)) == infsup (0));
***** assert (round (infsup (0.75)) == infsup (1));
***** assert (round (infsup (-0.5)) == infsup (-1));
***** # Bounded intervals
***** assert (round (infsup (-0.5, 0)) == infsup (-1, 0));
***** assert (round (infsup (0, 0.5)) == infsup (0, 1));
***** assert (round (infsup (0.25, 0.5)) == infsup (0, 1));
***** assert (round (infsup (-1, 0)) == infsup (-1, 0));
***** assert (round (infsup (-1, 1)) == infsup (-1, 1));
***** assert (round (infsup (-realmin, realmin)) == infsup (0));
***** assert (round (infsup (-realmax, realmax)) == infsup (-realmax, realmax));
***** # Unbounded intervals
***** assert (round (infsup (-realmin, inf)) == infsup (0, inf));
***** assert (round (infsup (-realmax, inf)) == infsup (-realmax, inf));
***** assert (round (infsup (-inf, realmin)) == infsup (-inf, 0));
***** assert (round (infsup (-inf, realmax)) == infsup (-inf, realmax));
***** assert (round (infsup (-inf, inf)) == infsup (-inf, inf));
***** # correct use of signed zeros
***** test
 x = round (infsup (0));
 assert (signbit (inf (x)));
 assert (not (signbit (sup (x))));
***** test
 x = round (infsup (-0.25, 0.25));
 assert (signbit (inf (x)));
 assert (not (signbit (sup (x))));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.roundTiesToAway;
 for testcase = [testcases]'
   assert (isequaln (...
     round (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.roundTiesToAway;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (round (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.roundTiesToAway;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (round (in1), out));
23 tests, 23 passed, 0 known failure, 0 skipped
[inst/@infsup/powrev2.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/powrev2.m
***** # from the documentation string
***** assert (powrev2 (infsup (2, 5), infsup (3, 6)) == "[0x1.5D7E8F22BA886p-1, 0x1.4AE00D1CFDEB5p1]");
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.powRev2;
 for testcase = [testcases]'
   assert (isequaln (...
     powrev2 (testcase.in{1}, testcase.in{2}, testcase.in{3}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.powRev2;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 in3 = vertcat (vertcat (testcases.in){:, 3});
 out = vertcat (testcases.out);
 assert (isequaln (powrev2 (in1, in2, in3), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.powRev2;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 in3 = vertcat (vertcat (testcases.in){:, 3});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 in3 = reshape ([in3; in3(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (powrev2 (in1, in2, in3), out));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsup/exp.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/exp.m
***** # from the documentation string
***** assert (exp (infsup (1)) == infsup ("e"));
***** # correct use of signed zeros
***** test
 x = exp (infsup (-realmax));
 assert (signbit (inf (x)));
 assert (not (signbit (sup (x))));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.exp;
 for testcase = [testcases]'
   assert (isequaln (...
     exp (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.exp;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (exp (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.exp;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (exp (in1), out));
5 tests, 5 passed, 0 known failure, 0 skipped
[inst/@infsup/qr.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/qr.m
***** test
 A = infsup ([1 2 3; 4 5 6]);
 [Q, R] = qr (A);
 assert (all (all (subset (A, Q * R))));
 assert (all (all (subset (eye (length (Q)), Q' * Q))));
 assert (max (max (wid (Q))) < 1e-14);
***** test
 A = infsup ([1 2; 3 4; 5 6]);
 [Q, R] = qr (A);
 assert (all (all (subset (A, Q * R))));
 assert (all (all (subset (eye (length (Q)), Q' * Q))));
 assert (max (max (wid (Q (:, [1 2])))) < 1e-14);
***** test
 A = infsup ([1 2 3; 4 9 6; 9 8 7]);
 [Q, R] = qr (A);
 assert (all (all (subset (A, Q * R))));
 assert (all (all (subset (eye (length (Q)), Q' * Q))));
 assert (max (max (wid (Q))) < 1e-13);
***** test
 for n = 3 : 2 : 10
   A = infsup (magic (n));
   [Q, R] = qr (A);
   assert (all (all (subset (A, Q * R))));
   assert (all (all (subset (eye (length (Q)), Q' * Q))));
   assert (max (max (wid (Q))) < 1e-10);
 endfor
***** test
 A = infsup (magic (3)) + "[2, 2.2]";
 [Q, R] = qr (A);
 assert (all (all (subset (A, Q * R))));
 assert (all (all (subset (eye (length (Q)), Q' * Q))));
 assert (max (max (wid (Q))) < 1.5);
***** function result = is_permutation_matrix (P)
 result = isequal (P, eye (length (P))) || ...
          isequal (typeinfo (P), "permutation matrix");
***** endfunction
***** test
 A = infsup ([1 2 3; 4 5 6]);
 [Q, R, P] = qr (A);
 assert (all (all (subset (A, Q * R * P))));
 assert (all (all (subset (eye (length (Q)), Q' * Q))));
 assert (max (max (wid (Q))) < 1e-14);
 assert (is_permutation_matrix (P));
***** test
 A = infsup ([1 2; 3 4; 5 6]);
 [Q, R, P] = qr (A);
 assert (all (all (subset (A, Q * R * P))));
 assert (all (all (subset (eye (length (Q)), Q' * Q))));
 assert (max (max (wid (Q (:, [1 2])))) < 1e-14);
 assert (is_permutation_matrix (P));
***** test
 A = infsup ([1 2 3; 4 9 6; 9 8 7]);
 [Q, R, P] = qr (A);
 assert (all (all (subset (A, Q * R * P))));
 assert (all (all (subset (eye (length (Q)), Q' * Q))));
 assert (max (max (wid (Q))) < 1e-13);
 assert (is_permutation_matrix (P));
***** test
 for n = 3 : 2 : 10
   A = infsup (magic (n));
   [Q, R, P] = qr (A);
   assert (all (all (subset (A, Q * R * P))));
   assert (all (all (subset (eye (length (Q)), Q' * Q))));
   assert (max (max (wid (Q))) < 1e-10);
   assert (is_permutation_matrix (P));
 endfor
***** test
 A = infsup (magic (3)) + "[2, 2.2]";
 [Q, R, P] = qr (A);
 assert (all (all (subset (A, Q * R * P))));
 assert (all (all (subset (eye (length (Q)), Q' * Q))));
 assert (max (max (wid (Q))) < 1.5);
 assert (is_permutation_matrix (P));
10 tests, 10 passed, 0 known failure, 0 skipped
[inst/@infsup/log2.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/log2.m
***** # from the documentation string
***** assert (log2 (infsup (2)) == 1);
***** # correct use of signed zeros
***** test
 x = log2 (infsup (1));
 assert (signbit (inf (x)));
 assert (not (signbit (sup (x))));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.log2;
 for testcase = [testcases]'
   assert (isequaln (...
     log2 (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.log2;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (log2 (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.log2;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (log2 (in1), out));
5 tests, 5 passed, 0 known failure, 0 skipped
[inst/@infsup/bitunpack.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/bitunpack.m
***** test;
  littleendian = bitunpack (uint16 (1))(1);
  b = zeros (1, 128);
  if (littleendian)
    b([52, 63, 117, 127]) = 1;
  else
    b([7, 12, 71, 77]) = 1;
  endif
  assert (bitunpack (infsup (3, 4)), logical (b));
1 test, 1 passed, 0 known failure, 0 skipped
[inst/@infsup/uplus.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/uplus.m
***** # from the documentation string
***** assert (+infsup (2, 3) == infsup (2, 3));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.pos;
 for testcase = [testcases]'
   assert (isequaln (...
     uplus (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.pos;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (uplus (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.pos;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (uplus (in1), out));
***** test
 # Decorated scalar evaluation
 testcases = testdata.NoSignal.infsupdec.pos;
 for testcase = [testcases]'
   assert (isequaln (...
     uplus (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Decorated vector evaluation
 testcases = testdata.NoSignal.infsupdec.pos;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (uplus (in1), out));
***** test
 # Decorated N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.pos;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (uplus (in1), out));
7 tests, 7 passed, 0 known failure, 0 skipped
[inst/@infsup/isscalar.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/isscalar.m
***** assert (not (isscalar (infsup ([]))));
***** assert (isscalar (infsup (0)));
***** assert (not (isscalar (infsup (zeros (1, 2)))));
***** assert (not (isscalar (infsup (zeros (2, 1)))));
***** assert (not (isscalar (infsup (zeros (5)))));
5 tests, 5 passed, 0 known failure, 0 skipped
[inst/@infsup/minus.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/minus.m
***** # from the documentation string
***** assert (infsup (2, 3) - infsup (1, 2) == infsup (0, 2));
***** # correct use of signed zeros
***** test
 x = minus (infsup (0), infsup (0));
 assert (signbit (inf (x)));
 assert (not (signbit (sup (x))));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.sub;
 for testcase = [testcases]'
   assert (isequaln (...
     minus (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.sub;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (minus (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.sub;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (minus (in1, in2), out));
5 tests, 5 passed, 0 known failure, 0 skipped
[inst/@infsup/mig.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/mig.m
***** assert (mig (infsup (-1, 2)), 0);
***** assert (mig (infsup (-42, -23)), 23);
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.mig;
 for testcase = [testcases]'
   assert (isequaln (...
     mig (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.mig;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (mig (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.mig;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (mig (in1), out));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.mig;
 for testcase = [testcases]'
   assert (isequaln (...
     mig (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.mig;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (mig (in1), out));
***** test
 # Decorated N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.mig;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (mig (in1), out));
8 tests, 8 passed, 0 known failure, 0 skipped
[inst/@infsup/expm1.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/expm1.m
***** # from the documentation string
***** assert (expm1 (infsup (eps)) == "[0x1p-52, 0x1.0000000000001p-52]");
***** # correct use of signed zeros
***** test
 x = expm1 (infsup (0));
 assert (signbit (inf (x)));
 assert (not (signbit (sup (x))));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.expm1;
 for testcase = [testcases]'
   assert (isequaln (...
     expm1 (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.expm1;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (expm1 (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.expm1;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (expm1 (in1), out));
5 tests, 5 passed, 0 known failure, 0 skipped
[inst/@infsup/interior.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/interior.m
***** assert (interior (infsup (1, 2), infsup (0, 3)));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.interior;
 for testcase = [testcases]'
   assert (isequaln (...
     interior (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.interior;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (interior (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.interior;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (interior (in1, in2), out));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsup/tanh.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/tanh.m
***** # from the documentation string
***** assert (tanh (infsup (1)) == "[0x1.85EFAB514F394p-1, 0x1.85EFAB514F395p-1]");
***** # correct use of signed zeros
***** test
 x = tanh (infsup (0));
 assert (signbit (inf (x)));
 assert (not (signbit (sup (x))));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.tanh;
 for testcase = [testcases]'
   assert (isequaln (...
     tanh (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.tanh;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (tanh (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.tanh;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (tanh (in1), out));
5 tests, 5 passed, 0 known failure, 0 skipped
[inst/@infsup/log.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsup/log.m
***** # from the documentation string
***** assert (log (infsup (2)) == "[0x1.62E42FEFA39EFp-1, 0x1.62E42FEFA39Fp-1]");
***** # correct use of signed zeros
***** test
 x = log (infsup (1));
 assert (signbit (inf (x)));
 assert (not (signbit (sup (x))));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.log;
 for testcase = [testcases]'
   assert (isequaln (...
     log (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.log;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (log (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.log;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (log (in1), out));
5 tests, 5 passed, 0 known failure, 0 skipped
[inst/ctc_union.m]
>>>>> /<<PKGBUILDDIR>>/inst/ctc_union.m
***** function [fval, cx] = ctc_sin (y, x)
  fval = sin (x);
  y = intersect (y, fval);
  cx = sinrev (y, x);
***** endfunction
***** function [fval, cx] = ctc_cos (y, x)
  fval = cos (x);
  y = intersect (y, fval);
  cx = cosrev (y, x);
***** endfunction
***** shared c
  c = ctc_union (@ctc_sin, 0, @ctc_cos, 0);
***** test
  x = infsup (0);
  y = infsup (0);
  [fval, cx] = c (y, x);
  assert (fval == 0);
  assert (cx == 0)
***** test
  x = infsup ("pi") / 2;
  y = infsup (0);
  [fval, cx] = c (y, x);
  assert (fval == "[0, 1]");
  assert (cx == x);
***** test
  x = infsup ("pi") / 4;
  y = infsup (0);
  [fval, cx] = c (y, x);
  assert (fval > 0);
  assert (isempty (cx));
***** test
  x = infsup (0, eps);
  y = infsup (0);
  [fval, cx] = c (y, x);
  assert (fval == "[0, 1]");
  assert (cx == 0);
***** test
  x = infsup ("[0, pi]") / 2;
  y = infsup (0);
  [fval, cx] = c (y, x);
  assert (fval == "[0, 1]");
  assert (cx == x);
5 tests, 5 passed, 0 known failure, 0 skipped
[inst/interval_bitpack.m]
>>>>> /<<PKGBUILDDIR>>/inst/interval_bitpack.m
***** test "bare";
  littleendian = bitunpack (uint16 (1))(1);
  b = zeros (1, 128);
  if (littleendian)
    b([52, 63, 117, 127]) = 1;
  else
    b([7, 12, 71, 77]) = 1;
  endif
  decoded = interval_bitpack (logical (b));
  assert (eq (decoded, infsup (3, 4)));
***** test "decorated";
  littleendian = bitunpack (uint16 (1))(1);
  b = zeros (1, 136);
  if (littleendian)
    b([52, 63, 117, 127, 133]) = 1;
  else
    b([7, 12, 71, 77, 133]) = 1;
  endif
  decoded = interval_bitpack (logical (b));
  assert (eq (decoded, infsupdec (3, 4)));
2 tests, 2 passed, 0 known failure, 0 skipped
[inst/__split_interval_literals__.m]
>>>>> /<<PKGBUILDDIR>>/inst/__split_interval_literals__.m
***** assert (__split_interval_literals__ (""), {""});
***** assert (__split_interval_literals__ (","), {""});
***** assert (__split_interval_literals__ ("1"), {"1"});
***** assert (__split_interval_literals__ ("1?"), {"1?"});
***** assert (__split_interval_literals__ ("1?u"), {"1?u"});
***** assert (__split_interval_literals__ ("1?u3"), {"1?u3"});
***** assert (__split_interval_literals__ ("[Empty]"), {"[Empty]"});
***** assert (__split_interval_literals__ ("[Entire]"), {"[Entire]"});
***** assert (__split_interval_literals__ ("[]"), {"[]"});
***** assert (__split_interval_literals__ ("[,]"), {"[,]"});
***** assert (__split_interval_literals__ ("[1]"), {"[1]"});
***** assert (__split_interval_literals__ ("[1,2]"), {"[1,2]"});
***** assert (__split_interval_literals__ ("1             2"), {"1", "2"});
***** assert (__split_interval_literals__ ("1, , , , , , ,2"), {"1", "2"});
***** assert (__split_interval_literals__ ("1;;2"), {"1"; ""; "2"});
***** assert (__split_interval_literals__ ("1; ;2"), {"1"; ""; "2"});
***** assert (__split_interval_literals__ ("[1,2] [3,4]"), {"[1,2]", "[3,4]"});
***** assert (__split_interval_literals__ ("[1,2],[3,4]"), {"[1,2]", "[3,4]"});
***** assert (__split_interval_literals__ ("[1,2], [3,4]"), {"[1,2]", "[3,4]"});
***** assert (__split_interval_literals__ ("[1,2]\n[3,4]"), {"[1,2]"; "[3,4]"});
***** assert (__split_interval_literals__ ("[1,2];[3,4]"), {"[1,2]"; "[3,4]"});
***** assert (__split_interval_literals__ ("[1,2]; [3,4]"), {"[1,2]"; "[3,4]"});
***** assert (__split_interval_literals__ (["[1,2]"; "[3,4]"]), {"[1,2]"; "[3,4]"});
***** assert (__split_interval_literals__ ("1 [3,4]"), {"1", "[3,4]"});
***** assert (__split_interval_literals__ ("1,[3,4]"), {"1", "[3,4]"});
***** assert (__split_interval_literals__ ("1, [3,4]"), {"1", "[3,4]"});
***** assert (__split_interval_literals__ ("1\n[3,4]"), {"1"; "[3,4]"});
***** assert (__split_interval_literals__ ("1;[3,4]"), {"1"; "[3,4]"});
***** assert (__split_interval_literals__ ("1; [3,4]"), {"1"; "[3,4]"});
***** assert (__split_interval_literals__ (["1"; "[3,4]"]), {"1"; "[3,4]"});
***** assert (__split_interval_literals__ ("[1,2] 3"), {"[1,2]", "3"});
***** assert (__split_interval_literals__ ("[1,2],3"), {"[1,2]", "3"});
***** assert (__split_interval_literals__ ("[1,2], 3"), {"[1,2]", "3"});
***** assert (__split_interval_literals__ ("[1,2]\n3"), {"[1,2]"; "3"});
***** assert (__split_interval_literals__ ("[1,2];3"), {"[1,2]"; "3"});
***** assert (__split_interval_literals__ ("[1,2]; 3"), {"[1,2]"; "3"});
***** assert (__split_interval_literals__ (["[1,2]"; "3"]), {"[1,2]"; "3"});
***** assert (__split_interval_literals__ ("1 3"), {"1", "3"});
***** assert (__split_interval_literals__ ("1,3"), {"1", "3"});
***** assert (__split_interval_literals__ ("1, 3"), {"1", "3"});
***** assert (__split_interval_literals__ ("1\n3"), {"1"; "3"});
***** assert (__split_interval_literals__ ("1;3"), {"1"; "3"});
***** assert (__split_interval_literals__ ("1; 3"), {"1"; "3"});
***** assert (__split_interval_literals__ (["1"; "3"]), {"1"; "3"});
***** assert (__split_interval_literals__ ("[1,2] [3,4] [5,6]"), {"[1,2]", "[3,4]", "[5,6]"});
***** assert (__split_interval_literals__ ("[1,2],[3,4],[5,6]"), {"[1,2]", "[3,4]", "[5,6]"});
***** assert (__split_interval_literals__ ("[1,2], [3,4], [5,6]"), {"[1,2]", "[3,4]", "[5,6]"});
***** assert (__split_interval_literals__ ("[1,2]\n[3,4];[5,6]"), {"[1,2]"; "[3,4]"; "[5,6]"});
***** assert (__split_interval_literals__ ("[1,2];[3,4] [5,6]"), {"[1,2]", "[Empty]"; "[3,4]", "[5,6]"});
***** assert (__split_interval_literals__ ("[1,2] [3,4];[5,6]"), {"[1,2]", "[3,4]"; "[5,6]", "[Empty]"});
***** assert (__split_interval_literals__ ("1 [3,4] [5,6]"), {"1", "[3,4]", "[5,6]"});
***** assert (__split_interval_literals__ ("1,[3,4],[5,6]"), {"1", "[3,4]", "[5,6]"});
***** assert (__split_interval_literals__ ("1, [3,4], [5,6]"), {"1", "[3,4]", "[5,6]"});
***** assert (__split_interval_literals__ ("1\n[3,4];[5,6]"), {"1"; "[3,4]"; "[5,6]"});
***** assert (__split_interval_literals__ ("1;[3,4] [5,6]"), {"1", "[Empty]"; "[3,4]", "[5,6]"});
***** assert (__split_interval_literals__ ("1 [3,4];[5,6]"), {"1", "[3,4]"; "[5,6]", "[Empty]"});
***** assert (__split_interval_literals__ ("[1,2] 3 [5,6]"), {"[1,2]", "3", "[5,6]"});
***** assert (__split_interval_literals__ ("[1,2],3,[5,6]"), {"[1,2]", "3", "[5,6]"});
***** assert (__split_interval_literals__ ("[1,2], 3, [5,6]"), {"[1,2]", "3", "[5,6]"});
***** assert (__split_interval_literals__ ("[1,2]\n3;[5,6]"), {"[1,2]"; "3"; "[5,6]"});
***** assert (__split_interval_literals__ ("[1,2];3 [5,6]"), {"[1,2]", "[Empty]"; "3", "[5,6]"});
***** assert (__split_interval_literals__ ("[1,2] 3;[5,6]"), {"[1,2]", "3"; "[5,6]", "[Empty]"});
***** assert (__split_interval_literals__ ("[1,2] [3,4] 5"), {"[1,2]", "[3,4]", "5"});
***** assert (__split_interval_literals__ ("[1,2],[3,4],5"), {"[1,2]", "[3,4]", "5"});
***** assert (__split_interval_literals__ ("[1,2], [3,4], 5"), {"[1,2]", "[3,4]", "5"});
***** assert (__split_interval_literals__ ("[1,2]\n[3,4];5"), {"[1,2]"; "[3,4]"; "5"});
***** assert (__split_interval_literals__ ("[1,2];[3,4] 5"), {"[1,2]", "[Empty]"; "[3,4]", "5"});
***** assert (__split_interval_literals__ ("[1,2] [3,4];5"), {"[1,2]", "[3,4]"; "5", "[Empty]"});
***** assert (__split_interval_literals__ ("1 [3,4] 5"), {"1", "[3,4]", "5"});
***** assert (__split_interval_literals__ ("1,[3,4],5"), {"1", "[3,4]", "5"});
***** assert (__split_interval_literals__ ("1, [3,4], 5"), {"1", "[3,4]", "5"});
***** assert (__split_interval_literals__ ("1\n[3,4];5"), {"1"; "[3,4]"; "5"});
***** assert (__split_interval_literals__ ("1;[3,4] 5"), {"1", "[Empty]"; "[3,4]", "5"});
***** assert (__split_interval_literals__ ("1 [3,4];5"), {"1", "[3,4]"; "5", "[Empty]"});
***** assert (__split_interval_literals__ ("1 3 [5,6]"), {"1", "3", "[5,6]"});
***** assert (__split_interval_literals__ ("1,3,[5,6]"), {"1", "3", "[5,6]"});
***** assert (__split_interval_literals__ ("1, 3, [5,6]"), {"1", "3", "[5,6]"});
***** assert (__split_interval_literals__ ("1\n3;[5,6]"), {"1"; "3"; "[5,6]"});
***** assert (__split_interval_literals__ ("1;3 [5,6]"), {"1", "[Empty]"; "3", "[5,6]"});
***** assert (__split_interval_literals__ ("1 3;[5,6]"), {"1", "3"; "[5,6]", "[Empty]"});
***** assert (__split_interval_literals__ ("[1,2] 3 5"), {"[1,2]", "3", "5"});
***** assert (__split_interval_literals__ ("[1,2],3,5"), {"[1,2]", "3", "5"});
***** assert (__split_interval_literals__ ("[1,2], 3, 5"), {"[1,2]", "3", "5"});
***** assert (__split_interval_literals__ ("[1,2]\n3;5"), {"[1,2]"; "3"; "5"});
***** assert (__split_interval_literals__ ("[1,2];3 5"), {"[1,2]", "[Empty]"; "3", "5"});
***** assert (__split_interval_literals__ ("[1,2] 3;5"), {"[1,2]", "3"; "5", "[Empty]"});
***** assert (__split_interval_literals__ ("1 3 5"), {"1", "3", "5"});
***** assert (__split_interval_literals__ ("1,3,5"), {"1", "3", "5"});
***** assert (__split_interval_literals__ ("1, 3, 5"), {"1", "3", "5"});
***** assert (__split_interval_literals__ ("1\n3;5"), {"1"; "3"; "5"});
***** assert (__split_interval_literals__ ("1;3 5"), {"1", "[Empty]"; "3", "5"});
***** assert (__split_interval_literals__ ("1 3;5"), {"1", "3"; "5", "[Empty]"});
92 tests, 92 passed, 0 known failure, 0 skipped
[inst/hull.m]
>>>>> /<<PKGBUILDDIR>>/inst/hull.m
***** assert (isnai (hull (nai)));
***** assert (isempty (hull (nan)));
***** assert (isequal (hull (2, nan, 3, 5), infsupdec (2, 5, "trv")));
***** assert (isequal (hull ([1, 2, 3], [5; 0; 2]), infsupdec ([1, 2, 3; 0, 0, 0; 1, 2, 2], [5, 5, 5; 1, 2, 3; 2, 2, 3], "com")));
***** assert (isequal (hull (magic (3), 10), infsupdec (magic (3), 10 (ones (3)), "com")));
***** assert (isequal (hull (2, magic (3), [nan, 2, 3; nan, 1, 1; 99, 100, nan]), infsupdec ([2, 1, 2; 2, 1, 1; 2, 2, 2], [8, 2, 6; 3, 5, 7; 99, 100, 2], {"trv", "com", "com"; "trv", "com", "com"; "com", "com", "trv"})));
***** assert (isnai (hull ([nai, 2])), logical ([1 0]));
***** assert (isnai (hull ([nai, 2], [nai, 3])), logical ([1 0]));
***** assert (isnai (hull ([nai, 2], nai)), logical ([1 1]));
***** assert (isnai (hull ([nai, 2], [2, nai])), logical ([1 1]));
***** assert (isequal (hull (zeros (2, 2, 2, 2), ones (2, 2, 2, 2)), infsupdec (zeros (2, 2, 2, 2), ones (2, 2, 2, 2))))
***** assert (isequal (hull (zeros (2, 1, 4, 1), ones (1, 3, 1, 5), -1), infsupdec (-ones (2, 3, 4, 5), ones (2, 3, 4, 5))))
***** assert (isnai (hull (zeros (2, 2, 2, 2), ones (2, 2, 2, 2), nai)), logical (ones (2, 2, 2, 2)))
***** error <dimensions mismatch> hull (1:2, 1:3);
***** error <dimensions mismatch> hull ((1:2)', (1:3)');
***** error <dimensions mismatch> hull (ones (2, 2, 2), ones (2, 2, 3));
***** test "from the documentation string";
 assert (isequal (hull (1, 2, 3, 4), infsupdec (1, 4, "com")));
 assert (isequal (hull (empty, entire), infsupdec (-inf, inf, "trv")));
 assert (isequal (hull ("0.1", "pi", "e"), infsupdec (0.1 - eps / 16, pi + eps * 2, "com")));
 assert (isequal (hull ("[0, 3]", "[4, 7]"), infsupdec ("[0, 7]_com")));
17 tests, 17 passed, 0 known failure, 0 skipped
[inst/ctc_intersect.m]
>>>>> /<<PKGBUILDDIR>>/inst/ctc_intersect.m
***** function [fval, x] = ctc_abs (y, x)
    fval = abs (x);
    x = absrev (intersect (fval, y), x);
***** endfunction
***** shared c
  c = ctc_intersect (@ctc_abs, "[0, 2]", @ctc_abs, "[1, 3]");
***** test
 [fval, x] = c (infsup (0), infsup ("[1, 3]"));
 assert (ismember (0, fval) && 0 != fval);
 assert (x == infsup ("[1, 2]"));
***** test
 [fval, x] = c (infsup (0), infsup ("[1, 2]"));
 assert (0 == fval);
 assert (x == infsup ("[1, 2]"));
***** test
 [fval, x] = c (infsup (0), infsup ("[entire]"));
 assert (ismember (0, fval) && 0 != fval);
 assert (x == infsup ("[-2, 2]"));
***** test
 [fval, x] = c (infsup (0), infsup ("[0, inf]"));
 assert (ismember (0, fval) && 0 != fval);
 assert (x == infsup ("[1, 2]"));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/verlinprog.m]
>>>>> /<<PKGBUILDDIR>>/inst/verlinprog.m
***** test
 A = [-2, -3; -2, -1];
 b = [-1500, -1000];
 c = [1; 1];
 [flag, x, y, h] = verlinprog (A, b, c);
 assert (flag, "verified optimum");
 assert (ismember ([375; 250], x));
 assert (wid (x) < 1e-12);
 assert (ismember ([-0.25; -0.25], y));
 assert (wid (y) < 1e-16);
 assert (ismember (625, h));
 assert (wid (h) < 1e-12);
1 test, 1 passed, 0 known failure, 0 skipped
[inst/exacttointerval.m]
>>>>> /<<PKGBUILDDIR>>/inst/exacttointerval.m
***** assert (isempty (exacttointerval ("[Empty]")));
***** assert (isentire (exacttointerval ("[Entire]")));
***** test "common interval";
 y = exacttointerval ("[0, 1]");
 assert (inf (y), 0);
 assert (sup (y), 1);
***** test "point interval";
 y = exacttointerval ("[42]");
 assert (inf (y), 42);
 assert (sup (y), 42);
***** test "unbound interval";
 y = exacttointerval ("[-4, Infinity]");
 assert (inf (y), -4);
 assert (sup (y), inf);
***** error exacttointerval ("[0, 0.1]");
***** error exacttointerval ("[1, 0]");
***** test "N-dimensional array";
 i = infsup (reshape (1:24, 2, 3, 4));
 assert (exacttointerval (intervaltoexact (i)) == i);
8 tests, 8 passed, 0 known failure, 0 skipped
[inst/vereigback.m]
>>>>> /<<PKGBUILDDIR>>/inst/vereigback.m
***** test
 [lambda, X, ep] = vereigback (eye (2));
 assert (lambda, [1; 1]);
 assert (X, eye (2));
 assert (ep, zeros (2, 1));
***** test
 [lambda, X, ep] = vereigback ([2 1; 1 2]);
 assert (lambda, [1; 3]);
 assert (X, [-1 1; 1 1] ./ sqrt (2), eps);
 assert (ep, zeros (2, 1));
***** test
 [lambda, X, ep] = vereigback ([2 0 0; 0 3 4; 0 4 9]);
 assert (lambda, [1; 2; 11]);
 assert (ep, zeros (3, 1));
***** test
 [lambda, X, ep] = vereigback ([1 2 3; 0 1 2; 1 1 1]);
 assert (max (ep) < 1e-14);
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/__check_crlibm__.m]
>>>>> /<<PKGBUILDDIR>>/inst/__check_crlibm__.m
***** assert (__check_crlibm__ ());
!!!!! test failed
assert (__check_crlibm__ ()) failed
1 test, 0 passed, 0 known failure, 0 skipped
[inst/entire.m]
>>>>> /<<PKGBUILDDIR>>/inst/entire.m
***** assert (inf (entire ()), -inf);
***** assert (sup (entire ()), inf);
***** assert (decorationpart (entire ()), {"dac"});
***** assert (inf (entire (5)), -inf (5));
***** assert (sup (entire (5)), inf (5));
***** assert (strcmp (decorationpart (entire (5)), "dac"), true (5));
***** assert (inf (entire (5, 6)), -inf (5, 6));
***** assert (sup (entire (5, 6)), inf (5, 6));
***** assert (strcmp (decorationpart (entire (5, 6)), "dac"), true (5, 6));
***** assert (inf (entire (5, 6, 7)), -inf (5, 6, 7));
***** assert (sup (entire (5, 6, 7)), inf (5, 6, 7));
***** assert (strcmp (decorationpart (entire (5, 6, 7)), "dac"), true (5, 6, 7));
12 tests, 12 passed, 0 known failure, 0 skipped
[inst/verintlinineqs.m]
>>>>> /<<PKGBUILDDIR>>/inst/verintlinineqs.m
***** test
 A = [-2, -3; -2, -1];
 b = [-1500; -1000];
 [x, As] = verintlinineqs (A, b);
 assert (x, [375; 250], 1e-9);
 assert (all (x >= [375; 250]));
 assert (all (all (isempty (As))));
1 test, 1 passed, 0 known failure, 0 skipped
[inst/@infsupdec/mulrev.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/mulrev.m
***** # IEEE Std 1788-2015 mulRevToPair examples
***** test
  [u, v] = mulrev (infsupdec (0), infsupdec (1, 2));
  assert (isempty (u) & isempty (v));
***** test
  [u, v] = mulrev (infsupdec (0), infsupdec (0, 1));
  assert (isentire (u) & isempty (v));
***** test
  [u, v] = mulrev (infsupdec (1), infsupdec (1, 2));
  assert (isequal (u, infsupdec (1, 2)) & isempty (v));
***** test
  [u, v] = mulrev (infsupdec (1, inf), infsupdec (1));
  assert (isequal (u, infsupdec (0, 1, "dac")) & isempty (v));
***** test
  [u, v] = mulrev (infsupdec (-1, 1), infsupdec (1, 2));
  assert (isequal (u, infsupdec (-inf, -1, "trv")) & isequal (v, infsupdec (1, inf, "trv")));
***** test
  [u, v] = mulrev (infsupdec (-inf, inf), infsupdec (1));
  assert (isequal (u, infsupdec (-inf, 0, "trv")) & isequal (v, infsupdec (0, inf, "trv")));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.mulRevToPair1;
 for testcase = [testcases]'
   assert (isequaln (...
     nthargout (1, 2, @mulrev, testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.mulRevToPair1;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (nthargout (1, 2, @mulrev, in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsupdec.mulRevToPair1;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (nthargout (1, 2, @mulrev, in1, in2), out));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.mulRevToPair2;
 for testcase = [testcases]'
   assert (isequaln (...
     nthargout (2, @mulrev, testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.mulRevToPair2;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (nthargout (2, @mulrev, in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsupdec.mulRevToPair2;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (nthargout (2, @mulrev, in1, in2), out));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.mulRev;
 for testcase = [testcases]'
   assert (isequaln (...
     mulrev (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.mulRev;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (mulrev (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsupdec.mulRev;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (mulrev (in1, in2), out));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.mulRevTen;
 for testcase = [testcases]'
   assert (isequaln (...
     mulrev (testcase.in{1}, testcase.in{2}, testcase.in{3}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.mulRevTen;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 in3 = vertcat (vertcat (testcases.in){:, 3});
 out = vertcat (testcases.out);
 assert (isequaln (mulrev (in1, in2, in3), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsupdec.mulRevTen;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 in3 = vertcat (vertcat (testcases.in){:, 3});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 in3 = reshape ([in3; in3(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (mulrev (in1, in2, in3), out));
18 tests, 18 passed, 0 known failure, 0 skipped
[inst/@infsupdec/prepad.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/prepad.m
***** assert (isequal (prepad (infsupdec (2:4), 4, 1), infsupdec (1:4)));
***** assert (isequal (prepad (infsupdec (0:2), 2, 1), infsupdec (1:2)));
***** test
 if (compare_versions (OCTAVE_VERSION (), "4.0.0", ">="))
   assert (isequal (prepad (infsupdec (0), 10, 0, 3), infsupdec (zeros (1, 1, 10))));
 else
   # In Octave 3.8.x it is not possible to increase the number of dimensions.
 endif
***** assert (isequal (prepad (infsupdec (zeros (1, 2, 2)), 3), infsupdec (zeros (1, 3, 2))));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsupdec/factorial.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/factorial.m
***** # from the documentation string
***** assert (isequal (factorial (infsupdec (6)), infsupdec (720)));
***** assert (isequal (factorial (infsupdec (0)), infsupdec (1)));
***** assert (isequal (factorial (infsupdec ("[0, 1.99]")), infsupdec (1, "trv")));
***** assert (isequal (factorial (infsupdec ("[0, 2]")), infsupdec (1, 2, "trv")));
***** assert (isequal (factorial (infsupdec ("[1.4, 1.6]")), empty ()));
***** assert (isequal (factorial (infsupdec (23)), infsupdec ("[0x1.5e5c335f8a4cdp+74, 0x1.5e5c335f8a4cep+74]_com")));
***** assert (isequal (factorial (infsupdec (171)), infsupdec ("[0x1.fffffffffffffp+1023, Inf]_dac")));
7 tests, 7 passed, 0 known failure, 0 skipped
[inst/@infsupdec/pow2.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/pow2.m
***** # from the documentation string
***** assert (isequal (pow2 (infsupdec (5)), infsupdec (32)));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.exp2;
 for testcase = [testcases]'
   assert (isequaln (...
     pow2 (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.exp2;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (pow2 (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsupdec.exp2;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2 | i == numel (in1))
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (pow2 (in1), out));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsupdec/ceil.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/ceil.m
***** # from the documentation string
***** assert (isequal (ceil (infsupdec (2.5, 3.5)), infsupdec (3, 4, "def")));
***** assert (isequal (ceil (infsupdec (-.5, 5)), infsupdec (0, 5, "def")));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.ceil;
 for testcase = [testcases]'
   assert (isequaln (...
     ceil (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.ceil;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (ceil (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.ceil;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (ceil (in1), out));
5 tests, 5 passed, 0 known failure, 0 skipped
[inst/@infsupdec/mtimes.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/mtimes.m
***** assert (isequal (infsupdec ([1, 2; 7, 15], [2, 2; 7.5, 15], {"com", "def"; "dac", "com"}) * infsupdec ([3, 3; 0, 1], [3, 3.25; 0, 2]), infsupdec ([3, 5; 21, 36], [6, 10.5; 22.5, 54.375], {"def", "def"; "dac", "dac"})));
***** # from the documentation string
***** assert (isequal (infsupdec ([1, 2; 7, 15], [2, 2; 7.5, 15]) * infsupdec ([3, 3; 0, 1], [3, 3.25; 0, 2]), infsupdec ([3, 5; 21, 36], [6, 10.5; 22.5, 54.375])));
2 tests, 2 passed, 0 known failure, 0 skipped
[inst/@infsupdec/cosrev.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/cosrev.m
***** # from the documentation string
***** assert (isequal (cosrev (0, infsupdec (6, 9)), infsupdec ("[0x1.F6A7A2955385Ep2, 0x1.F6A7A2955386p2]_trv")));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.cosRev;
 for testcase = [testcases]'
   assert (isequaln (...
     cosrev (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.cosRev;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (cosrev (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsupdec.cosRev;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (cosrev (in1), out));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.cosRevBin;
 for testcase = [testcases]'
   assert (isequaln (...
     cosrev (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.cosRevBin;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (cosrev (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsupdec.cosRevBin;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (cosrev (in1, in2), out));
7 tests, 7 passed, 0 known failure, 0 skipped
[inst/@infsupdec/tanrev.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/tanrev.m
***** # from the documentation string
***** assert (isequal (tanrev (infsupdec (0), infsupdec (2, 4)), infsupdec ("pi", "trv")));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.tanRev;
 for testcase = [testcases]'
   assert (isequaln (...
     tanrev (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.tanRev;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (tanrev (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsupdec.tanRev;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (tanrev (in1), out));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.tanRevBin;
 for testcase = [testcases]'
   assert (isequaln (...
     tanrev (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.tanRevBin;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (tanrev (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsupdec.tanRevBin;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (tanrev (in1, in2), out));
7 tests, 7 passed, 0 known failure, 0 skipped
[inst/@infsupdec/isnai.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/isnai.m
***** assert (isnai (infsupdec ("[nai]")));
***** assert (not (isnai (infsupdec (2, 3))));
***** warning assert (isnai (infsupdec ("happy 42 hacking")), logical ([1 0 1]));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.isNaI;
 for testcase = [testcases]'
   assert (isequaln (...
     isnai (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.isNaI;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (isnai (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsupdec.isNaI;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (isnai (in1), out));
6 tests, 6 passed, 0 known failure, 0 skipped
[inst/@infsupdec/dilog.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/dilog.m
***** assert (isequal (dilog (infsupdec (-inf, inf)), infsupdec ("[-Inf, +0x1.3BD3CC9BE45DFp1]_dac")));
***** # from the documentation string
***** assert (isequal (dilog (infsupdec (1)), infsupdec ("[0x1.A51A6625307D3, 0x1.A51A6625307D4]_com")));
2 tests, 2 passed, 0 known failure, 0 skipped
[inst/@infsupdec/gauss.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/gauss.m
***** # from the documentation string
***** assert (isequal (gauss (infsupdec ([1, 0; 0, 2]), [2, 0; 0, 4]), infsupdec ([2, 0; 0, 2], "trv")));
1 test, 1 passed, 0 known failure, 0 skipped
[inst/@infsupdec/polyval.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/polyval.m
***** assert (isequal (polyval (infsupdec (3, "trv"), 0), infsupdec (3, "trv")));
1 test, 1 passed, 0 known failure, 0 skipped
[inst/@infsupdec/rdivide.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/rdivide.m
***** # from the documentation string
***** assert (isequal (infsupdec (2, 3) ./ infsupdec (1, 2), infsupdec (1, 3)));
***** assert (1 ./ infsupdec (1, 4) == infsupdec (0.25, 1));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.div;
 for testcase = [testcases]'
   assert (isequaln (...
     rdivide (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.div;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (rdivide (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsupdec.div;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (rdivide (in1, in2), out));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.recip;
 for testcase = [testcases]'
   assert (isequaln (...
     rdivide (1, testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.recip;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (rdivide (1, in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsupdec.recip;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (rdivide (1, in1), out));
8 tests, 8 passed, 0 known failure, 0 skipped
[inst/@infsupdec/infsupdec.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/infsupdec.m
***** # [NaI]s
***** assert (isnai (infsupdec ("[nai]"))); # quiet [NaI]
***** assert (isnai (infsupdec (" [ nai ] "))); # quiet [NaI]
***** assert (isnai (infsupdec ({0, "[nai]"})), [false, true]); # quiet [NaI]
***** warning id=interval:UndefinedOperation
 assert (isnai (infsupdec (3, 2))); # illegal boundaries
***** warning id=interval:UndefinedOperation
 assert (isnai (infsupdec (inf, -inf))); # illegal boundaries
***** warning id=interval:UndefinedOperation
 assert (isnai (infsupdec ("Flugeldufel"))); # illegal literal
***** warning id=interval:UndefinedOperation
 assert (isnai (infsupdec ("[1, Inf]_com"))); # illegal decorated literal
***** warning id=interval:UndefinedOperation
 assert (isnai (infsupdec ("[Empty]_def"))); # illegal decorated literal
***** # decoration adjustments, setDec function
***** test
 x = infsupdec (42, inf, "com");
 assert (inf (x), 42);
 assert (sup (x), inf);
 assert (decorationpart (x), {"dac"});
***** test
 x = infsupdec (-inf, inf, {"com"});
 assert (inf (x), -inf);
 assert (sup (x), inf);
 assert (decorationpart (x), {"dac"});
***** test
 x = infsupdec ("def");
 assert (inf (x), inf);
 assert (sup (x), -inf);
 assert (decorationpart (x), {"trv"});
***** # overflow
***** test
 x = infsupdec ("[1, 1e999]_com");
 assert (inf (x), 1);
 assert (sup (x), inf);
 assert (decorationpart (x), {"dac"});
***** # decorated interval literal
***** test
 x = infsupdec ("[2, 3]_def");
 assert (inf (x), 2);
 assert (sup (x), 3);
 assert (decorationpart (x), {"def"});
***** test
 x = infsupdec ("[1, 5]_dac");
 assert (inf (x), 1);
 assert (sup (x), 5);
 assert (decorationpart (x), {"dac"});
***** test
 x = infsupdec ("[1, Infinity]_dac");
 assert (inf (x), 1);
 assert (sup (x), inf);
 assert (decorationpart (x), {"dac"});
***** test
 x = infsupdec ("[Empty]_trv");
 assert (inf (x), inf);
 assert (sup (x), -inf);
 assert (decorationpart (x), {"trv"});
***** # automatic decoration / undecorated interval literal / newDec function
***** test
 x = infsupdec ("[2, 3]");
 assert (inf (x), 2);
 assert (sup (x), 3);
 assert (decorationpart (x), {"com"});
***** test
 x = infsupdec ("[Empty]");
 assert (inf (x), inf);
 assert (sup (x), -inf);
 assert (decorationpart (x), {"trv"});
***** test
 x = infsupdec ("[Entire]");
 assert (inf (x), -inf);
 assert (sup (x), inf);
 assert (decorationpart (x), {"dac"});
***** test
 x = infsupdec ("");
 assert (inf (x), -inf);
 assert (sup (x), inf);
 assert (decorationpart (x), {"dac"});
***** # separate decoration information
***** test
 x = infsupdec ("[2, 3]", "def");
 assert (inf (x), 2);
 assert (sup (x), 3);
 assert (decorationpart (x), {"def"});
***** # cell array with decorated interval literals
***** test
 x = infsupdec ({"[2, 3]_def", "[4, 5]_dac"});
 assert (inf (x), [2, 4]);
 assert (sup (x), [3, 5]);
 assert (decorationpart (x), {"def", "dac"});
***** #cell array with separate decoration cell array
***** test
 x = infsupdec ({"[2, 3]", "[4, 5]"}, {"def", "dac"});
 assert (inf (x), [2, 4]);
 assert (sup (x), [3, 5]);
 assert (decorationpart (x), {"def", "dac"});
***** # cell array with separate decoration vector
***** test
 x = infsupdec ({"[2, 3]"; "[4, 5]"}, ["def"; "dac"]);
 assert (inf (x), [2; 4]);
 assert (sup (x), [3; 5]);
 assert (decorationpart (x), {"def"; "dac"});
***** # cell array with broadcasting decoration
***** test
 x = infsupdec ({"[2, 3]", "[4, 5]"}, "def");
 assert (inf (x), [2, 4]);
 assert (sup (x), [3, 5]);
 assert (decorationpart (x), {"def", "def"});
***** test
 x = infsupdec ({"[2, 3]", "[4, 5]"}, "def; dac");
 assert (inf (x), [2, 4; 2, 4]);
 assert (sup (x), [3, 5; 3, 5]);
 assert (decorationpart (x), {"def", "def"; "dac", "dac"});
***** # separate boundaries with decoration
***** test
 x = infsupdec (2, 3, "def");
 assert (inf (x), 2);
 assert (sup (x), 3);
 assert (decorationpart (x), {"def"});
***** # matrix boundaries with decoration
***** test
 x = infsupdec ([3, 16], {"def", "trv"});
 assert (inf (x), [3, 16]);
 assert (sup (x), [3, 16]);
 assert (decorationpart (x), {"def", "trv"});
***** # separate matrix boundaries with broadcasting decoration
***** test
 x = infsupdec (magic (3), magic (3) + 1, "def");
 assert (inf (x), magic (3));
 assert (sup (x), magic (3) + 1);
 assert (decorationpart (x), {"def", "def", "def"; "def", "def", "def"; "def", "def", "def"});
***** # N-dimensional arrays
***** test
 x = infsupdec (zeros (2, 2, 2));
 assert (x.inf, zeros (2, 2, 2));
 assert (x.sup, zeros (2, 2, 2));
 assert (decorationpart (x), repmat ({"com"}, [2, 2, 2]));
***** test
 x = infsupdec (zeros (2, 2, 2), ones (2, 2, 2), repmat ({"trv"}, [2, 2, 2]));
 assert (x.inf, zeros (2, 2, 2));
 assert (x.sup, ones (2, 2, 2));
 assert (decorationpart (x), repmat ({"trv"}, [2, 2, 2]));
***** test
 x = infsupdec (zeros (1, 1, 2), ones (1, 2, 1), {"trv"; "trv"});
 assert (x.inf, zeros (2, 2, 2));
 assert (x.sup, ones (2, 2, 2));
 assert (decorationpart (x), repmat ({"trv"}, [2, 2, 2]));
***** test
 c1 = reshape ({1, 2, 3, 4, 5, 6, 7, 8}, 2, 2, 2);
 c2 = reshape ({2, 3, 4, 5, 6, 7, 8, 9}, 2, 2, 2);
 decpart = reshape ({"trv", "def", "dac", "com", "trv", "def", "dac", "com"}, 2, 2, 2);
 x = infsupdec (c1, c2, decpart);
 assert (x.inf, reshape (1:8, 2, 2, 2));
 assert (x.sup, reshape (2:9, 2, 2, 2));
 assert (decorationpart (x), decpart)
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsup.setDec;
 for testcase = [testcases]'
   assert (isequaln (...
     infsupdec (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsup.setDec;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (infsupdec (in1, in2), out));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.("d-numsToInterval");
 for testcase = [testcases]'
   assert (isequaln (...
     infsupdec (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.("d-numsToInterval");
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (infsupdec (in1, in2), out));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.("d-textToInterval");
 for testcase = [testcases]'
   assert (isequaln (...
     infsupdec (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.("d-textToInterval");
 in1 = vertcat (testcases.in);
 out = vertcat (testcases.out);
 assert (isequaln (infsupdec (in1), out));
***** warning
 testcases = testdata.PossiblyUndefinedOperation.infsupdec.("d-textToInterval");
 for testcase = [testcases]'
   lastwarn ("", "");
   assert (isequaln (...
     infsupdec (testcase.in{1}), ...
     testcase.out));
   assert (nthargout (2, @lastwarn), "interval:PossiblyUndefinedOperation");
 endfor
***** warning
 testcases = testdata.UndefinedOperation.infsupdec.("d-textToInterval");
 for testcase = [testcases]'
   lastwarn ("", "");
   assert (isequaln (...
     infsupdec (testcase.in{1}), ...
     testcase.out));
   assert (nthargout (2, @lastwarn), "interval:UndefinedOperation");
 endfor
***** warning
 testcases = testdata.UndefinedOperation.infsupdec.("d-numsToInterval");
 for testcase = [testcases]'
   lastwarn ("", "");
   assert (isequaln (...
     infsupdec (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
   assert (nthargout (2, @lastwarn), "interval:UndefinedOperation");
 endfor
***** warning
 testcases = testdata.UndefinedOperation.infsup.setDec;
 for testcase = [testcases]'
   lastwarn ("", "");
   assert (isequaln (...
     infsupdec (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
   assert (nthargout (2, @lastwarn), "interval:UndefinedOperation");
 endfor
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsupdec.("d-numsToInterval");
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (infsupdec (in1, in2), out));
44 tests, 44 passed, 0 known failure, 0 skipped
[inst/@infsupdec/realsqrt.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/realsqrt.m
***** # from the documentation string
***** assert (isequal (realsqrt (infsupdec (-6, 4)), infsupdec (0, 2, "trv")));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.sqrt;
 for testcase = [testcases]'
   assert (isequaln (...
     realsqrt (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.sqrt;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (realsqrt (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.sqrt;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (realsqrt (in1), out));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsupdec/gammaln.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/gammaln.m
***** assert (isequal (gammaln (infsupdec (-inf, inf)), infsupdec ("[-0x1.F19B9BCC38A42p-4, +Inf]_trv")));
***** # from the documentation string
***** assert (isequal (gammaln (infsupdec (1.5)), infsupdec ("[-0x1.EEB95B094C192p-4, -0x1.EEB95B094C191p-4]_com")));
2 tests, 2 passed, 0 known failure, 0 skipped
[inst/@infsupdec/floor.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/floor.m
***** # from the documentation string
***** assert (isequal (floor (infsupdec (2.5, 3.5)), infsupdec (2, 3, "def")));
***** assert (isequal (floor (infsupdec (-0.5, 5)), infsupdec (-1, 5, "def")));
***** warning
 _ = @infsupdec;
 assert (isequal (...
   floor (_ ("jansen")), nai)) #ghtwish
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.floor;
 for testcase = [testcases]'
   assert (isequaln (...
     floor (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.floor;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (floor (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.floor;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (floor (in1), out));
6 tests, 6 passed, 0 known failure, 0 skipped
[inst/@infsupdec/sinh.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/sinh.m
***** # from the documentation string
***** assert (isequal (sinh (infsupdec (1)), infsupdec ("[0x1.2CD9FC44EB982, 0x1.2CD9FC44EB983]")));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.sinh;
 for testcase = [testcases]'
   assert (isequaln (...
     sinh (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.sinh;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (sinh (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsupdec.sinh;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (sinh (in1), out));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsupdec/reshape.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/reshape.m
***** assert (isequal (reshape (infsupdec (1 : 6), 2, 3), infsupdec (reshape (1 : 6, 2, 3))));
***** assert (isequal (reshape (infsupdec (1 : 24), 2, [], 4), infsupdec (reshape (1 : 24, 2, 3, 4))));
2 tests, 2 passed, 0 known failure, 0 skipped
[inst/@infsupdec/powrev1.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/powrev1.m
***** # from the documentation string
***** assert (isequal (powrev1 (infsupdec (2, 5), infsupdec (3, 6)), infsupdec ("[0x1.3EE8390D43955, 0x1.3988E1409212Fp1]_trv")));
1 test, 1 passed, 0 known failure, 0 skipped
[inst/@infsupdec/log10.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/log10.m
***** # from the documentation string
***** assert (isequal (log10 (infsupdec (2)), infsupdec ("[0x1.34413509F79FEp-2, 0x1.34413509F79FFp-2]")));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.log10;
 for testcase = [testcases]'
   assert (isequaln (...
     log10 (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.log10;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (log10 (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.log10;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (log10 (in1), out));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsupdec/pown.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/pown.m
***** # from the documentation string
***** assert (isequal (pown (infsupdec (5, 6), 2), infsupdec (25, 36)));
***** assert (pown (infsupdec (-2, 1), 2) == infsupdec (0, 4));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.sqr;
 for testcase = [testcases]'
   assert (isequaln (...
     pown (testcase.in{1}, 2), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.sqr;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (pown (in1, 2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsupdec.sqr;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (pown (in1, 2), out));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.pown;
 for testcase = [testcases]'
   assert (isequaln (...
     pown (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.pown;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (pown (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsupdec.pown;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (pown (in1, in2), out));
8 tests, 8 passed, 0 known failure, 0 skipped
[inst/@infsupdec/le.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/le.m
***** assert (le (infsupdec (1, 3), infsupdec (3)));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.less;
 for testcase = [testcases]'
   assert (isequaln (...
     le (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.less;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (le (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsupdec.less;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (le (in1, in2), out));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsupdec/ei.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/ei.m
***** assert (isempty (ei (infsupdec (0))));
***** assert (isempty (ei (infsupdec (-inf, -2))));
***** assert (isequal (ei (infsupdec (0, inf)), infsupdec ("[Entire]_trv")));
***** assert (isequal (ei (infsupdec (1, inf)), infsupdec ("[0x1.E52670F350D08, Inf]_dac")));
***** # from the documentation string
***** assert (isequal (ei (infsupdec (1)), infsupdec ("[0x1.E52670F350D08, 0x1.E52670F350D09]_com")));
5 tests, 5 passed, 0 known failure, 0 skipped
[inst/@infsupdec/uminus.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/uminus.m
***** # from the documentation string
***** assert (isequal (-infsupdec (2, 3), infsupdec (-3, -2)));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.neg;
 for testcase = [testcases]'
   assert (isequaln (...
     uminus (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.neg;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (uminus (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.neg;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (uminus (in1), out));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsupdec/cancelminus.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/cancelminus.m
***** # from the documentation string
***** assert (isequal (cancelminus (infsupdec (2, 3), infsupdec (1, 1.5)), infsupdec (1, 1.5, "trv")));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.cancelMinus;
 for testcase = [testcases]'
   assert (isequaln (...
     cancelminus (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.cancelMinus;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (cancelminus (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsupdec.cancelMinus;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (cancelminus (in1, in2), out));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsupdec/fma.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/fma.m
***** # from the documentation string
***** assert (isequal (fma (infsupdec (1+eps), infsupdec (7), infsupdec ("0.1")), infsupdec ("[0x1.C666666666668p2, 0x1.C666666666669p2]")));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.fma;
 for testcase = [testcases]'
   assert (isequaln (...
     fma (testcase.in{1}, testcase.in{2}, testcase.in{3}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.fma;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 in3 = vertcat (vertcat (testcases.in){:, 3});
 out = vertcat (testcases.out);
 assert (isequaln (fma (in1, in2, in3), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsupdec.fma;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 in3 = vertcat (vertcat (testcases.in){:, 3});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2 | i == numel (in1))
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 in3 = reshape ([in3; in3(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (fma (in1, in2, in3), out));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsupdec/decorationpart.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/decorationpart.m
***** assert (decorationpart (infsupdec (3, 4)), {"com"});
***** assert (decorationpart (infsupdec (3, inf)), {"dac"});
***** assert (decorationpart (infsupdec ("[3, 4]_def")), {"def"});
***** assert (decorationpart (infsupdec ()), {"trv"});
***** assert (decorationpart (nai), {"ill"});
***** assert (decorationpart (nai, "uint8") ...
      < decorationpart (infsupdec ("[3, 4]_trv"), "uint8"));
***** assert (decorationpart (infsupdec ("[3, 4]_trv"), "uint8") ...
      < decorationpart (infsupdec ("[3, 4]_def"), "uint8"));
***** assert (decorationpart (infsupdec ("[3, 4]_def"), "uint8") ...
      < decorationpart (infsupdec ("[3, 4]_dac"), "uint8"));
***** assert (decorationpart (infsupdec ("[3, 4]_dac"), "uint8") ...
      < decorationpart (infsupdec ("[3, 4]_com"), "uint8"));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.decorationPart;
 for testcase = [testcases]'
   assert (isequaln (...
     decorationpart (testcase.in{1}), ...
     {testcase.out}));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.decorationPart;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = {testcases.out}';
 assert (isequaln (decorationpart (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsupdec.decorationPart;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = {testcases.out}';
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (decorationpart (in1), out));
12 tests, 12 passed, 0 known failure, 0 skipped
[inst/@infsupdec/atan2rev2.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/atan2rev2.m
***** # from the documentation string
***** assert (isequal (atan2rev2 (infsupdec (1, 2), infsupdec ("pi") / 4), infsupdec ("[0x1.FFFFFFFFFFFFEp-1, 0x1.0000000000001p1]_trv")));
1 test, 1 passed, 0 known failure, 0 skipped
[inst/@infsupdec/det.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/det.m
***** # from the documentation string
***** assert (det (infsupdec (magic (3))) == -360);
1 test, 1 passed, 0 known failure, 0 skipped
[inst/@infsupdec/max.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/max.m
***** # from the documentation string
***** assert (isequal (max (infsupdec (2, 3), infsupdec (1, 2)), infsupdec (2, 3)));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.max;
 for testcase = [testcases]'
   assert (isequaln (...
     max (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.max;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (max (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsupdec.max;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (max (in1, in2), out));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsupdec/abs.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/abs.m
***** # Empty interval
***** assert (isequal (abs (infsupdec ()), infsupdec ()));
***** # Singleton intervals
***** assert (isequal (abs (infsupdec (1)), infsupdec (1)));
***** assert (isequal (abs (infsupdec (0)), infsupdec (0)));
***** assert (isequal (abs (infsupdec (-1)), infsupdec (1)));
***** assert (isequal (abs (infsupdec (realmax)), infsupdec (realmax)));
***** assert (isequal (abs (infsupdec (realmin)), infsupdec (realmin)));
***** assert (isequal (abs (infsupdec (-realmin)), infsupdec (realmin)));
***** assert (isequal (abs (infsupdec (-realmax)), infsupdec (realmax)));
***** # Bounded intervals
***** assert (isequal (abs (infsupdec (1, 2)), infsupdec (1, 2)));
***** assert (isequal (abs (infsupdec (0, 1)), infsupdec (0, 1)));
***** assert (isequal (abs (infsupdec (-1, 1)), infsupdec (0, 1)));
***** assert (isequal (abs (infsupdec (-1, 0)), infsupdec (0, 1)));
***** assert (isequal (abs (infsupdec (-2, -1)), infsupdec (1, 2)));
***** # Unbounded intervals
***** assert (isequal (abs (infsupdec (0, inf)), infsupdec (0, inf)));
***** assert (isequal (abs (infsupdec (-inf, inf)), infsupdec (0, inf)));
***** assert (isequal (abs (infsupdec (-inf, 0)), infsupdec (0, inf)));
***** assert (isequal (abs (infsupdec (1, inf)), infsupdec (1, inf)));
***** assert (isequal (abs (infsupdec (-1, inf)), infsupdec (0, inf)));
***** assert (isequal (abs (infsupdec (-inf, -1)), infsupdec (1, inf)));
***** assert (isequal (abs (infsupdec (-inf, 1)), infsupdec (0, inf)));
***** # from the documentation string
***** assert (isequal (abs (infsupdec (2.5, 3.5)), infsupdec (2.5, 3.5)));
***** assert (isequal (abs (infsupdec (-0.5, 5.5)), infsupdec (0, 5.5)));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.abs;
 for testcase = [testcases]'
   assert (isequaln (...
     abs (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.abs;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (abs (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.abs;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (abs (in1), out));
25 tests, 25 passed, 0 known failure, 0 skipped
[inst/@infsupdec/csch.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/csch.m
***** # from the documentation string
***** assert (isequal (csch (infsupdec (1)), infsupdec ("[0x1.B3AB8A78B90Cp-1, 0x1.B3AB8A78B90C1p-1]_com")));
1 test, 1 passed, 0 known failure, 0 skipped
[inst/@infsupdec/hypot.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/hypot.m
***** # from the documentation string
***** assert (isequal (hypot (infsupdec (2, 3), infsupdec (1, 2)), infsupdec ("[0x1.1E3779B97F4A7p1, 0x1.CD82B446159F4p1]")));
1 test, 1 passed, 0 known failure, 0 skipped
[inst/@infsupdec/mod.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/mod.m
***** assert (isequal (mod (infsupdec (), infsupdec ()), infsupdec ()));
***** assert (isequal (mod (infsupdec (0), infsupdec ()), infsupdec ()));
***** assert (isequal (mod (infsupdec (), infsupdec (0)), infsupdec ()));
***** assert (isequal (mod (infsupdec (0), infsupdec (0)), infsupdec ()));
***** assert (isequal (mod (infsupdec (1), infsupdec (0)), infsupdec ()));
***** assert (isequal (mod (infsupdec (0, 1), infsupdec (0)), infsupdec ()));
***** assert (isequal (mod (infsupdec (1, 2), infsupdec (0)), infsupdec ()));
***** assert (isequal (mod (infsupdec (0, inf), infsupdec (0)), infsupdec ()));
***** assert (isequal (mod (infsupdec (1, inf), infsupdec (0)), infsupdec ()));
***** assert (isequal (mod (infsupdec (realmax, inf), infsupdec (0)), infsupdec ()));
***** assert (isequal (mod (infsupdec (0), infsupdec (1)), infsupdec (0, "dac")));
***** assert (isequal (mod (infsupdec (0), infsupdec (0, 1)), infsupdec (0, "trv")));
***** assert (isequal (mod (infsupdec (0), infsupdec (1, 2)), infsupdec (0, "dac")));
***** assert (isequal (mod (infsupdec (0), infsupdec (0, inf)), infsupdec (0, "trv")));
***** assert (isequal (mod (infsupdec (0), infsupdec (1, inf)), infsupdec (0, "dac")));
***** assert (isequal (mod (infsupdec (0), infsupdec (realmax, inf)), infsupdec (0, "dac")));
***** assert (isequal (mod (infsupdec (1), infsupdec (1)), infsupdec (0, "dac")));
***** assert (isequal (mod (infsupdec (2), infsupdec (1)), infsupdec (0, "dac")));
***** assert (isequal (mod (infsupdec (4), infsupdec (2)), infsupdec (0, "dac")));
***** assert (isequal (mod (infsupdec (6), infsupdec (3)), infsupdec (0, "dac")));
***** assert (isequal (mod (infsupdec (8), infsupdec (2)), infsupdec (0, "dac")));
***** assert (isequal (mod (infsupdec (9), infsupdec (3)), infsupdec (0, "dac")));
***** assert (isequal (mod (infsupdec (realmax), infsupdec (realmax)), infsupdec (0, "dac")));
***** assert (isequal (mod (infsupdec (realmax), infsupdec (realmax / 2)), infsupdec (0, "dac")));
***** assert (isequal (mod (infsupdec (realmax), infsupdec (realmax / 4)), infsupdec (0, "dac")));
***** assert (isequal (mod (infsupdec (realmax), infsupdec (realmax / 8)), infsupdec (0, "dac")));
***** assert (isequal (mod (infsupdec (realmax), infsupdec (realmax / 16)), infsupdec (0, "dac")));
***** assert (isequal (mod (infsupdec (realmax), infsupdec (realmax / 32)), infsupdec (0, "dac")));
***** assert (isequal (mod (infsupdec (0.1), infsupdec (0.1)), infsupdec (0, "dac")));
***** assert (isequal (mod (infsupdec (0.1 * 2), infsupdec (0.1)), infsupdec (0, "dac")));
***** assert (isequal (mod (infsupdec (0.1 * 4), infsupdec (0.1)), infsupdec (0, "dac")));
***** assert (isequal (mod (infsupdec (pi), infsupdec (pi)), infsupdec (0, "dac")));
***** assert (isequal (mod (infsupdec (pi), infsupdec (pi / 2)), infsupdec (0, "dac")));
***** assert (isequal (mod (infsupdec (pi), infsupdec (pi / 4)), infsupdec (0, "dac")));
***** assert (isequal (mod (infsupdec (pow2 (-1074)), infsupdec (pow2 (-1074))), infsupdec (0, "dac")));
***** assert (isequal (mod (infsupdec (pow2 (-1073)), infsupdec (pow2 (-1074))), infsupdec (0, "dac")));
***** assert (isequal (mod (infsupdec (pow2 (-1072)), infsupdec (pow2 (-1074))), infsupdec (0, "dac")));
***** assert (isequal (mod (infsupdec (1), infsupdec (2)), infsupdec (1)));
***** assert (isequal (mod (infsupdec (0.5), infsupdec (1)), infsupdec (0.5)));
***** assert (isequal (mod (infsupdec (pi), infsupdec (3.15)), infsupdec (pi)));
***** assert (isequal (mod (infsupdec (1), infsupdec (2, 3)), infsupdec (1)));
***** assert (isequal (mod (infsupdec (1), infsupdec (2, inf)), infsupdec (1, "dac")));
***** assert (isequal (mod (infsupdec (0.5), infsupdec (1, 2)), infsupdec (0.5)));
***** assert (isequal (mod (infsupdec (0.5), infsupdec (1, inf)), infsupdec (0.5, "dac")));
***** assert (isequal (mod (infsupdec (pi), infsupdec (3.15)), infsupdec (pi)));
***** assert (isequal (mod (infsupdec (pi), infsupdec (3.15, inf)), infsupdec (pi, "dac")));
***** assert (isequal (mod (infsupdec (0, 1), infsupdec (0, 1)), infsupdec (0, 1, "trv")));
***** assert (isequal (mod (infsupdec (0, 2), infsupdec (0, 1)), infsupdec (0, 1, "trv")));
***** assert (isequal (mod (infsupdec (0, 1), infsupdec (0, 2)), infsupdec (0, 1, "trv")));
***** assert (isequal (mod (infsupdec (0, realmax), infsupdec (0, realmax)), infsupdec (0, realmax, "trv")));
***** assert (isequal (mod (infsupdec (realmax, inf), infsupdec (realmax, inf)), infsupdec (0, inf, "def")));
***** assert (isequal (mod (infsupdec (0, inf), infsupdec (0, inf)), infsupdec (0, inf, "trv")));
***** assert (isequal (mod (infsupdec (0), infsupdec (1)), infsupdec (0, "dac")));
***** assert (isequal (mod (infsupdec (1), infsupdec (1)), infsupdec (0, "dac")));
***** assert (isequal (mod (infsupdec (0, 1), infsupdec (1)), infsupdec (0, 1, "def")));
***** assert (isequal (mod (infsupdec (1, 2), infsupdec (1)), infsupdec (0, 1, "def")));
***** assert (isequal (mod (infsupdec (0, inf), infsupdec (1)), infsupdec (0, 1, "def")));
***** assert (isequal (mod (infsupdec (1, inf), infsupdec (1)), infsupdec (0, 1, "def")));
***** assert (isequal (mod (infsupdec (realmax, inf), infsupdec (1)), infsupdec (0, 1, "def")));
***** assert (isequal (mod (infsupdec (1), infsupdec (1)), infsupdec (0, "dac")));
***** assert (isequal (mod (infsupdec (1), infsupdec (0, 1)), infsupdec (0, 0.5, "trv")));
***** assert (isequal (mod (infsupdec (1), infsupdec (1, 2)), infsupdec (0, 1, "def")));
***** assert (isequal (mod (infsupdec (1), infsupdec (0, inf)), infsupdec (0, 1, "trv")));
***** assert (isequal (mod (infsupdec (1), infsupdec (1, inf)), infsupdec (0, 1, "def")));
***** assert (isequal (mod (infsupdec (1), infsupdec (2, inf)), infsupdec (1, "dac")));
***** assert (isequal (mod (infsupdec (1), infsupdec (realmax, inf)), infsupdec (1, "dac")));
66 tests, 66 passed, 0 known failure, 0 skipped
[inst/@infsupdec/atan2.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/atan2.m
***** # from the documentation string
***** assert (isequal (atan2 (infsupdec (1), infsupdec (-1)), infsupdec ("[0x1.2D97C7F3321D2p1, 0x1.2D97C7F3321D3p1]")));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.atan2;
 for testcase = [testcases]'
   assert (isequaln (...
     atan2 (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.atan2;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (atan2 (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsupdec.atan2;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (atan2 (in1, in2), out));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsupdec/inf.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/inf.m
***** assert (inf (infsupdec (2.5, 3.5)), 2.5);
***** assert (inf (infsupdec ()), +inf);
***** assert (inf (infsupdec ("[nai]")), nan);
***** warning id=interval:UndefinedOperation
 assert (inf (infsupdec (2, 1)), nan);
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.inf;
 for testcase = [testcases]'
   assert (isequaln (...
     inf (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.inf;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (inf (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.inf;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (inf (in1), out));
7 tests, 7 passed, 0 known failure, 0 skipped
[inst/@infsupdec/acosh.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/acosh.m
***** # from the documentation string
***** assert (isequal (acosh (infsupdec (2)), infsupdec ("[0x1.5124271980434, 0x1.5124271980435]")));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.acosh;
 for testcase = [testcases]'
   assert (isequaln (...
     acosh (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.acosh;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (acosh (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.acosh;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (acosh (in1), out));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsupdec/erf.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/erf.m
***** # from the documentation string
***** assert (erf (infsupdec (1)) == "[0x1.AF767A741088Ap-1, 0x1.AF767A741088Bp-1]");
1 test, 1 passed, 0 known failure, 0 skipped
[inst/@infsupdec/isempty.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/isempty.m
***** assert (isempty (infsupdec ()));
***** assert (not (isempty (infsupdec (1, 2))));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.isEmpty;
 for testcase = [testcases]'
   assert (isequaln (...
     isempty (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.isEmpty;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (isempty (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.isEmpty;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (isempty (in1), out));
5 tests, 5 passed, 0 known failure, 0 skipped
[inst/@infsupdec/bisect.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/bisect.m
***** # from the documentation string
***** test
 [a, b] = bisect (infsupdec (2, 32));
 assert (a == infsupdec (2, 8, "trv"));
 assert (b == infsupdec (8, 32, "trv"));
1 test, 1 passed, 0 known failure, 0 skipped
[inst/@infsupdec/lt.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/lt.m
***** assert (not (lt (infsupdec (1, 3), infsupdec (3))));
***** assert (lt (infsupdec (1, 3), infsupdec (3.1)));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.strictLess;
 for testcase = [testcases]'
   assert (isequaln (...
     lt (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.strictLess;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (lt (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsupdec.strictLess;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (lt (in1, in2), out));
5 tests, 5 passed, 0 known failure, 0 skipped
[inst/@infsupdec/cat.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/cat.m
***** assert (size (cat (1, infsupdec ([]), infsupdec ([]))), [0 0]);
***** assert (isequal (cat (1, infsupdec (1), infsupdec (2)), infsupdec (cat (1, 1, 2))));
***** assert (isequal (cat (2, infsupdec (1), infsupdec (2)), infsupdec (cat (2, 1, 2))));
***** assert (isequal (horzcat (infsupdec (1), infsupdec (2)), infsupdec (horzcat (1, 2))));
***** test
 a = infsupdec (2, 5);
 assert (isequal (horzcat (a, a, a), infsupdec ([2, 2, 2], [5, 5, 5])));
***** assert (isequal (vertcat (infsupdec (1), infsupdec (2)), infsupdec (vertcat (1, 2))));
***** test
 a = infsupdec (2, 5);
 assert (isequal (vertcat (a, a, a), infsupdec ([2; 2; 2], [5; 5; 5])));
***** assert (isequal (cat (5, infsupdec (1), infsupdec (2)), infsupdec (cat (5, 1, 2))));
***** assert (isequal (cat (1, infsupdec (zeros (2, 2, 2)), infsupdec (ones (2, 2, 2))), infsupdec (cat (1, zeros (2, 2, 2), ones (2, 2, 2)))));
9 tests, 9 passed, 0 known failure, 0 skipped
[inst/@infsupdec/fix.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/fix.m
***** # from the documentation string
***** assert (isequal (fix (infsupdec (2.5, 3.5)), infsupdec (2, 3, "def")));
***** assert (isequal (fix (infsupdec (-0.5, 5)), infsupdec (0, 5, "def")));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.trunc;
 for testcase = [testcases]'
   assert (isequaln (...
     fix (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.trunc;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (fix (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsupdec.trunc;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (fix (in1), out));
5 tests, 5 passed, 0 known failure, 0 skipped
[inst/@infsupdec/transpose.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/transpose.m
***** assert (isequal (transpose (infsupdec (magic (3))), infsupdec (magic (3).')));
***** # from the documentation string
***** assert (isequal (transpose (infsupdec (zeros (1, 3), ones (1, 3))), infsupdec (zeros (3, 1), ones (3, 1))));
2 tests, 2 passed, 0 known failure, 0 skipped
[inst/@infsupdec/triu.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/triu.m
***** assert (triu (infsupdec (magic (10))) == triu (magic (10)));
***** assert (triu (infsupdec (magic (10)), 1) == triu (magic (10), 1));
***** assert (triu (infsupdec (magic (10)), -1) == triu (magic (10), -1));
***** assert (triu (infsupdec (magic (10)), 0, "pack") == triu (magic (10), 0, "pack"));
***** test
 A = infsupdec (zeros (3), "trv");
 assert (decorationpart (triu (A)), {"trv", "trv", "trv"; "com", "trv", "trv"; "com", "com", "trv"});
5 tests, 5 passed, 0 known failure, 0 skipped
[inst/@infsupdec/sum.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/sum.m
***** # from the documentation string
***** assert (isequal (sum ([infsupdec(1), pow2(-1074), -1]), infsupdec (pow2 (-1074))));
1 test, 1 passed, 0 known failure, 0 skipped
[inst/@infsupdec/postpad.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/postpad.m
***** assert (isequal (postpad (infsupdec (1:3), 4, 4), infsupdec (1:4)));
***** assert (isequal (postpad (infsupdec (1:3), 2, 4), infsupdec (1:2)));
***** test
 if (compare_versions (OCTAVE_VERSION (), "4.0.0", ">="))
   assert (isequal (postpad (infsupdec (0), 10, 0, 3), infsupdec (zeros (1, 1, 10))));
 else
   # In Octave 3.8.x it is not possible to increase the number of dimensions.
 endif
***** assert (isequal (postpad (infsupdec (zeros (1, 2, 2)), 3), infsupdec (zeros (1, 3, 2))));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsupdec/overlap.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/overlap.m
***** assert (overlap (infsupdec (1, 2), infsupdec (3, 4)), "before");
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.overlap;
 for testcase = [testcases]'
   assert (isequaln (...
     overlap (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.overlap;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = {testcases.out}';
 assert (isequaln (overlap (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsupdec.overlap;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = {testcases.out}';
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (overlap (in1, in2), out));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsupdec/sin.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/sin.m
***** # from the documentation string
***** assert (isequal (sin (infsupdec (1)), infsupdec ("[0x1.AED548F090CEEp-1, 0x1.AED548F090CEFp-1]")));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.sin;
 for testcase = [testcases]'
   assert (isequaln (...
     sin (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.sin;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (sin (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.sin;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (sin (in1), out));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsupdec/mldivide.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/mldivide.m
***** # unique solution
***** assert (isequal (infsupdec ([1, 0; 0, 2]) \ [2, 0; 0, 4], infsupdec ([2, 0; 0 2], "trv")));
***** # no solution
***** assert (all (isempty (infsupdec ([1, 0; 2, 0]) \ [3; 0])));
***** # many solutions
***** assert (isequal (infsupdec ([1, 0; 2, 0]) \ [4; 8], infsupdec ([4; -inf], [4; inf], "trv")));
3 tests, 3 passed, 0 known failure, 0 skipped
[inst/@infsupdec/nthroot.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/nthroot.m
***** assert (isequal (nthroot (infsupdec (25, 36), 2), infsupdec (5, 6)));
***** assert (isequal (nthroot (infsupdec (-1, 1), 2), infsupdec (0, 1, "trv")));
***** assert (isequal (nthroot (infsupdec (-1, 1), 3), infsupdec (-1, 1)));
***** assert (isequal (nthroot (infsupdec (-1, 1), -2), infsupdec (1, inf, "trv")));
***** assert (isequal (nthroot (infsupdec (-1, 1), -3), infsupdec (-inf, inf, "trv")));
5 tests, 5 passed, 0 known failure, 0 skipped
[inst/@infsupdec/absrev.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/absrev.m
***** # Empty interval
***** assert (isequal (absrev (infsupdec ()), infsupdec ()));
***** assert (isequal (absrev (infsupdec (0, 1), infsupdec ()), infsupdec ()));
***** assert (isequal (absrev (infsupdec (0, 1), infsupdec (7, 9)), infsupdec ()));
***** assert (isequal (absrev (infsupdec (), infsupdec (0, 1)), infsupdec ()));
***** assert (isequal (absrev (infsupdec (-2, -1)), infsupdec ()));
***** # Singleton intervals
***** assert (isequal (absrev (infsupdec (1)), infsupdec (-1, 1, "trv")));
***** assert (isequal (absrev (infsupdec (0)), infsupdec (0, "trv")));
***** assert (isequal (absrev (infsupdec (-1)), infsupdec ()));
***** assert (isequal (absrev (infsupdec (realmax)), infsupdec (-realmax, realmax, "trv")));
***** assert (isequal (absrev (infsupdec (realmin)), infsupdec (-realmin, realmin, "trv")));
***** assert (isequal (absrev (infsupdec (-realmin)), infsupdec ()));
***** assert (isequal (absrev (infsupdec (-realmax)), infsupdec ()));
***** # Bound intervals
***** assert (isequal (absrev (infsupdec (1, 2)), infsupdec (-2, 2, "trv")));
***** assert (isequal (absrev (infsupdec (1, 2), infsupdec (0, 2)), infsupdec (1, 2, "trv")));
***** assert (isequal (absrev (infsupdec (0, 1), infsupdec (-0.5, 2)), infsupdec (-0.5, 1, "trv")));
***** assert (isequal (absrev (infsupdec (-1, 1)), infsupdec (-1, 1, "trv")));
***** assert (isequal (absrev (infsupdec (-1, 0)), infsupdec (0, "trv")));
***** # Unbound intervals
***** assert (isequal (absrev (infsupdec (0, inf)), infsupdec (-inf, inf, "trv")));
***** assert (isequal (absrev (infsupdec (-inf, inf)), infsupdec (-inf, inf, "trv")));
***** assert (isequal (absrev (infsupdec (-inf, 0)), infsupdec (0, "trv")));
***** assert (isequal (absrev (infsupdec (1, inf), infsupdec (-inf, 0)), infsupdec (-inf, -1, "trv")));
***** assert (isequal (absrev (infsupdec (-1, inf)), infsupdec (-inf, inf, "trv")));
***** assert (isequal (absrev (infsupdec (-inf, -1)), infsupdec ()));
***** assert (isequal (absrev (infsupdec (-inf, 1)), infsupdec (-1, 1, "trv")));
***** # from the documentation string
***** assert (isequal (absrev (infsupdec (-2, 1)), infsupdec (-1, 1, "trv")));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation with one argument
 testcases = testdata.NoSignal.infsupdec.absRev;
 for testcase = [testcases]'
   assert (isequaln (...
     absrev (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation with one argument
 testcases = testdata.NoSignal.infsupdec.absRev;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (absrev (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsupdec.absRev;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (absrev (in1), out));
***** test
 # Scalar evaluation with two arguments
 testcases = testdata.NoSignal.infsupdec.absRevBin;
 for testcase = [testcases]'
   assert (isequaln (...
     absrev (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation with two arguments
 testcases = testdata.NoSignal.infsupdec.absRevBin;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (absrev (in1, in2), out));
***** test
 # N-dimensional array evaluation with two arguments
 testcases = testdata.NoSignal.infsupdec.absRevBin;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (absrev (in1, in2), out));
31 tests, 31 passed, 0 known failure, 0 skipped
[inst/@infsupdec/plus.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/plus.m
***** # from the documentation string
***** assert (isequal (infsupdec (2, 3) + infsupdec (1, 2), infsupdec (3, 5)));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.add;
 for testcase = [testcases]'
   assert (isequaln (...
     plus (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.add;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (plus (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsupdec.add;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (plus (in1, in2), out));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsupdec/atan.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/atan.m
***** # from the documentation string
***** assert (isequal (atan (infsupdec (1)), infsupdec ("[0x1.921FB54442D18p-1, 0x1.921FB54442D19p-1]")));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.atan;
 for testcase = [testcases]'
   assert (isequaln (...
     atan (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.atan;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (atan (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.atan;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (atan (in1), out));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsupdec/mince.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/mince.m
***** assert (isequal (mince (infsupdec (0, 10), 10), infsupdec (0 : 9, 1 : 10, "trv")));
1 test, 1 passed, 0 known failure, 0 skipped
[inst/@infsupdec/sec.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/sec.m
***** # from the documentation string
***** assert (isequal (sec (infsupdec (1)), infsupdec ("[0x1.D9CF0F125CC29, 0x1.D9CF0F125CC2A]_com")));
1 test, 1 passed, 0 known failure, 0 skipped
[inst/@infsupdec/pownrev.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/pownrev.m
***** assert (isequal (pownrev (infsupdec (25, 36), infsupdec (0, inf), 2), infsupdec (5, 6, "trv")));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.pownRev;
 for testcase = [testcases]'
   assert (isequaln (...
     pownrev (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.pownRev;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (pownrev (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsupdec.pownRev;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (pownrev (in1, in2), out));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.pownRevBin;
 for testcase = [testcases]'
   assert (isequaln (...
     pownrev (testcase.in{1}, testcase.in{2}, testcase.in{3}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.pownRevBin;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 in3 = vertcat (vertcat (testcases.in){:, 3});
 out = vertcat (testcases.out);
 assert (isequaln (pownrev (in1, in2, in3), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsupdec.pownRevBin;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 in3 = vertcat (vertcat (testcases.in){:, 3});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 in3 = reshape ([in3; in3(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (pownrev (in1, in2, in3), out));
7 tests, 7 passed, 0 known failure, 0 skipped
[inst/@infsupdec/diag.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/diag.m
***** assert (diag (infsupdec (-inf, inf)) == "[Entire]");
***** assert (diag (infsupdec ()) == "[Empty]");
***** assert (numel (diag (infsupdec ([]))), 0);
***** assert (isequal (diag (infsupdec (magic (3))), infsupdec ([8; 5; 2])));
***** assert (isequal (diag (infsupdec ([8 5 3])), infsupdec ([8 0 0; 0 5 0; 0 0 3])));
5 tests, 5 passed, 0 known failure, 0 skipped
[inst/@infsupdec/cbrt.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/cbrt.m
***** # from the documentation string
***** assert (isequal (cbrt (infsupdec (-27, 27)), infsupdec (-3, 3)));
1 test, 1 passed, 0 known failure, 0 skipped
[inst/@infsupdec/sinrev.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/sinrev.m
***** # from the documentation string
***** assert (isequal (sinrev (infsupdec (-1), infsupdec (0, 6)), infsupdec ("[0x1.2D97C7F3321D2p2, 0x1.2D97C7F3321D3p2]_trv")));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.sinRev;
 for testcase = [testcases]'
   assert (isequaln (...
     sinrev (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.sinRev;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (sinrev (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsupdec.sinRev;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (sinrev (in1), out));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.sinRevBin;
 for testcase = [testcases]'
   assert (isequaln (...
     sinrev (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.sinRevBin;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (sinrev (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsupdec.sinRevBin;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (sinrev (in1, in2), out));
7 tests, 7 passed, 0 known failure, 0 skipped
[inst/@infsupdec/csc.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/csc.m
***** # from the documentation string
***** assert (isequal (csc (infsupdec (1)), infsupdec ("[0x1.303AA9620B223, 0x1.303AA9620B224]_com")));
1 test, 1 passed, 0 known failure, 0 skipped
[inst/@infsupdec/dot.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/dot.m
***** # matrix × matrix
***** assert (isequal (dot (infsupdec (magic (3)), magic (3)), infsupdec([89, 107, 89])));
***** assert (isequal (dot (infsupdec (magic (3)), magic (3), 1), infsupdec([89, 107, 89])));
***** assert (isequal (dot (infsupdec (magic (3)), magic (3), 2), infsupdec([101; 83; 101])));
***** # matrix × vector
***** assert (isequal (dot (infsupdec (magic (3)), [1, 2, 3]), infsupdec([28; 34; 28])));
***** assert (isequal (dot (infsupdec (magic (3)), [1, 2, 3], 1), infsupdec([15, 30, 45])));
***** assert (isequal (dot (infsupdec (magic (3)), [1, 2, 3], 2), infsupdec([28; 34; 28])));
***** assert (isequal (dot (infsupdec (magic (3)), [1; 2; 3]), infsupdec([26, 38, 26])));
***** assert (isequal (dot (infsupdec (magic (3)), [1; 2; 3], 1), infsupdec([26, 38, 26])));
***** assert (isequal (dot (infsupdec (magic (3)), [1; 2; 3], 2), infsupdec([15; 30; 45])));
***** # matrix × scalar
***** assert (isequal (dot (infsupdec (magic (3)), 42), infsupdec([630, 630, 630])));
***** assert (isequal (dot (infsupdec (magic (3)), 42, 1), infsupdec([630, 630, 630])));
***** assert (isequal (dot (infsupdec (magic (3)), 42, 2), infsupdec([630; 630; 630])));
***** # vector x vector
***** assert (isequal (dot (infsupdec([1, 2, 3]), [4, 5, 6]), infsupdec(32)));
***** assert (isequal (dot (infsupdec([1, 2, 3]), [4, 5, 6], 1), infsupdec([4, 10, 18])));
***** assert (isequal (dot (infsupdec([1, 2, 3]), [4, 5, 6], 2), infsupdec(32)));
***** assert (isequal (dot (infsupdec([1; 2; 3]), [4; 5; 6]), infsupdec(32)));
***** assert (isequal (dot (infsupdec([1; 2; 3]), [4; 5; 6], 1), infsupdec(32)));
***** assert (isequal (dot (infsupdec([1; 2; 3]), [4; 5; 6], 2), infsupdec([4; 10; 18])));
***** # vector × scalar
***** assert (isequal (dot (infsupdec ([1, 2, 3]), 42), infsupdec(252)));
***** assert (isequal (dot (infsupdec ([1, 2, 3]), 42, 1), infsupdec([42, 84, 126])));
***** assert (isequal (dot (infsupdec ([1, 2, 3]), 42, 2), infsupdec(252)));
***** assert (isequal (dot (infsupdec ([1; 2; 3]), 42), infsupdec(252)));
***** assert (isequal (dot (infsupdec ([1; 2; 3]), 42, 1), infsupdec(252)));
***** assert (isequal (dot (infsupdec ([1; 2; 3]), 42, 2), infsupdec([42; 84; 126])));
***** # empty matrix x empty matrix
***** assert (isequal (dot (infsupdec (ones (0, 2)), infsupdec (ones (0, 2))), infsupdec ([0, 0])));
***** # N-dimensional arrays
***** test
  x = infsupdec (reshape (1:24, 2, 3, 4));
  y = infsupdec (2.*ones (2, 3, 4));
  assert (isequal (dot (x, y, 3), infsupdec ([80, 96, 112; 88, 104, 120])))
***** test
  x = infsupdec (ones (2, 2, 2, 2));
  y = infsupdec (1);
  assert (size (dot (x, y)), [1, 2, 2, 2]);
  assert (size (dot (x, y, 1)), [1, 2, 2, 2]);
  assert (size (dot (x, y, 2)), [2, 1, 2, 2]);
  assert (size (dot (x, y, 3)), [2, 2, 1, 2]);
  assert (size (dot (x, y, 4)), [2, 2, 2]);
  assert (size (dot (x, y, 5)), [2, 2, 2, 2]);
***** # from the documentation string
***** assert (isequal (dot ([infsupdec(1), 2, 3], [infsupdec(2), 3, 4]), infsupdec (20)));
***** assert (isequal (dot (infsupdec ([realmax; realmin; realmax]), [1; -1; -1], 1), infsupdec (-realmin)));
29 tests, 29 passed, 0 known failure, 0 skipped
[inst/@infsupdec/atan2rev1.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/atan2rev1.m
***** # from the documentation string
***** assert (isequal (atan2rev1 (infsupdec (1, 2), infsupdec ("pi") / 4), infsupdec ("[0x1.FFFFFFFFFFFFFp-1, 0x1.0000000000001p1]_trv")));
1 test, 1 passed, 0 known failure, 0 skipped
[inst/@infsupdec/pow.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/pow.m
***** # from the documentation string
***** assert (isequal (pow (infsupdec (5, 6), infsupdec (2, 3)), infsupdec (25, 216)));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.pow;
 for testcase = [testcases]'
   assert (isequaln (...
     pow (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.pow;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (pow (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsupdec.pow;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (pow (in1, in2), out));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsupdec/strictprecedes.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/strictprecedes.m
***** assert (strictprecedes (infsupdec (1, 1.9), infsupdec (2.1, 3)));
***** assert (not (strictprecedes (infsupdec (1, 2), infsupdec (2, 3))));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.strictPrecedes;
 for testcase = [testcases]'
   assert (isequaln (...
     strictprecedes (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.strictPrecedes;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (strictprecedes (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsupdec.strictPrecedes;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (strictprecedes (in1, in2), out));
5 tests, 5 passed, 0 known failure, 0 skipped
[inst/@infsupdec/gamma.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/gamma.m
***** # from the documentation string
***** assert (isequal (gamma (infsupdec (1.5)), infsupdec ("[0x1.C5BF891B4EF6Ap-1, 0x1.C5BF891B4EF6Bp-1]_com")));
1 test, 1 passed, 0 known failure, 0 skipped
[inst/@infsupdec/rem.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/rem.m
***** assert (isequal (rem (infsupdec (), infsupdec ()), infsupdec ()));
***** assert (isequal (rem (infsupdec (0), infsupdec ()), infsupdec ()));
***** assert (isequal (rem (infsupdec (), infsupdec (0)), infsupdec ()));
***** assert (isequal (rem (infsupdec (0), infsupdec (0)), infsupdec ()));
***** assert (isequal (rem (infsupdec (1), infsupdec (0)), infsupdec ()));
***** assert (isequal (rem (infsupdec (0, 1), infsupdec (0)), infsupdec ()));
***** assert (isequal (rem (infsupdec (1, 2), infsupdec (0)), infsupdec ()));
***** assert (isequal (rem (infsupdec (0, inf), infsupdec (0)), infsupdec ()));
***** assert (isequal (rem (infsupdec (1, inf), infsupdec (0)), infsupdec ()));
***** assert (isequal (rem (infsupdec (realmax, inf), infsupdec (0)), infsupdec ()));
***** assert (isequal (rem (infsupdec (0), infsupdec (1)), infsupdec (0)));
***** assert (isequal (rem (infsupdec (0), infsupdec (0, 1)), infsupdec (0, "trv")));
***** assert (isequal (rem (infsupdec (0), infsupdec (1, 2)), infsupdec (0)));
***** assert (isequal (rem (infsupdec (0), infsupdec (0, inf)), infsupdec (0, "trv")));
***** assert (isequal (rem (infsupdec (0), infsupdec (1, inf)), infsupdec (0, "dac")));
***** assert (isequal (rem (infsupdec (0), infsupdec (realmax, inf)), infsupdec (0, "dac")));
***** assert (isequal (rem (infsupdec (1), infsupdec (1)), infsupdec (0, "dac")));
***** assert (isequal (rem (infsupdec (2), infsupdec (1)), infsupdec (0, "dac")));
***** assert (isequal (rem (infsupdec (4), infsupdec (2)), infsupdec (0, "dac")));
***** assert (isequal (rem (infsupdec (6), infsupdec (3)), infsupdec (0, "dac")));
***** assert (isequal (rem (infsupdec (8), infsupdec (2)), infsupdec (0, "dac")));
***** assert (isequal (rem (infsupdec (9), infsupdec (3)), infsupdec (0, "dac")));
***** assert (isequal (rem (infsupdec (realmax), infsupdec (realmax)), infsupdec (0, "dac")));
***** assert (isequal (rem (infsupdec (realmax), infsupdec (realmax / 2)), infsupdec (0, "dac")));
***** assert (isequal (rem (infsupdec (realmax), infsupdec (realmax / 4)), infsupdec (0, "dac")));
***** assert (isequal (rem (infsupdec (realmax), infsupdec (realmax / 8)), infsupdec (0, "dac")));
***** assert (isequal (rem (infsupdec (realmax), infsupdec (realmax / 16)), infsupdec (0, "dac")));
***** assert (isequal (rem (infsupdec (realmax), infsupdec (realmax / 32)), infsupdec (0, "dac")));
***** assert (isequal (rem (infsupdec (0.1), infsupdec (0.1)), infsupdec (0, "dac")));
***** assert (isequal (rem (infsupdec (0.1 * 2), infsupdec (0.1)), infsupdec (0, "dac")));
***** assert (isequal (rem (infsupdec (0.1 * 4), infsupdec (0.1)), infsupdec (0, "dac")));
***** assert (isequal (rem (infsupdec (pi), infsupdec (pi)), infsupdec (0, "dac")));
***** assert (isequal (rem (infsupdec (pi), infsupdec (pi / 2)), infsupdec (0, "dac")));
***** assert (isequal (rem (infsupdec (pi), infsupdec (pi / 4)), infsupdec (0, "dac")));
***** assert (isequal (rem (infsupdec (pow2 (-1074)), infsupdec (pow2 (-1074))), infsupdec (0, "dac")));
***** assert (isequal (rem (infsupdec (pow2 (-1073)), infsupdec (pow2 (-1074))), infsupdec (0, "dac")));
***** assert (isequal (rem (infsupdec (pow2 (-1072)), infsupdec (pow2 (-1074))), infsupdec (0, "dac")));
***** assert (isequal (rem (infsupdec (1), infsupdec (2)), infsupdec (1)));
***** assert (isequal (rem (infsupdec (0.5), infsupdec (1)), infsupdec (0.5)));
***** assert (isequal (rem (infsupdec (pi), infsupdec (3.15)), infsupdec (pi)));
***** assert (isequal (rem (infsupdec (1), infsupdec (2, 3)), infsupdec (1)));
***** assert (isequal (rem (infsupdec (1), infsupdec (2, inf)), infsupdec (1, "dac")));
***** assert (isequal (rem (infsupdec (0.5), infsupdec (1, 2)), infsupdec (0.5)));
***** assert (isequal (rem (infsupdec (0.5), infsupdec (1, inf)), infsupdec (0.5, "dac")));
***** assert (isequal (rem (infsupdec (pi), infsupdec (3.15)), infsupdec (pi)));
***** assert (isequal (rem (infsupdec (pi), infsupdec (3.15, inf)), infsupdec (pi, "dac")));
***** assert (isequal (rem (infsupdec (0, 1), infsupdec (0, 1)), infsupdec (0, 1, "trv")));
***** assert (isequal (rem (infsupdec (0, 2), infsupdec (0, 1)), infsupdec (0, 1, "trv")));
***** assert (isequal (rem (infsupdec (0, 1), infsupdec (0, 2)), infsupdec (0, 1, "trv")));
***** assert (isequal (rem (infsupdec (0, realmax), infsupdec (0, realmax)), infsupdec (0, realmax, "trv")));
***** assert (isequal (rem (infsupdec (realmax, inf), infsupdec (realmax, inf)), infsupdec (0, inf, "def")));
***** assert (isequal (rem (infsupdec (0, inf), infsupdec (0, inf)), infsupdec (0, inf, "trv")));
***** assert (isequal (rem (infsupdec (0), infsupdec (1)), infsupdec (0)));
***** assert (isequal (rem (infsupdec (1), infsupdec (1)), infsupdec (0, "dac")));
***** assert (isequal (rem (infsupdec (0, 1), infsupdec (1)), infsupdec (0, 1, "def")));
***** assert (isequal (rem (infsupdec (1, 2), infsupdec (1)), infsupdec (0, 1, "def")));
***** assert (isequal (rem (infsupdec (0, inf), infsupdec (1)), infsupdec (0, 1, "def")));
***** assert (isequal (rem (infsupdec (1, inf), infsupdec (1)), infsupdec (0, 1, "def")));
***** assert (isequal (rem (infsupdec (realmax, inf), infsupdec (1)), infsupdec (0, 1, "def")));
***** assert (isequal (rem (infsupdec (1), infsupdec (1)), infsupdec (0, "dac")));
***** assert (isequal (rem (infsupdec (1), infsupdec (0, 1)), infsupdec (0, 0.5, "trv")));
***** assert (isequal (rem (infsupdec (1), infsupdec (1, 2)), infsupdec (0, 1, "def")));
***** assert (isequal (rem (infsupdec (1), infsupdec (0, inf)), infsupdec (0, 1, "trv")));
***** assert (isequal (rem (infsupdec (1), infsupdec (1, inf)), infsupdec (0, 1, "def")));
***** assert (isequal (rem (infsupdec (1), infsupdec (2, inf)), infsupdec (1, "dac")));
***** assert (isequal (rem (infsupdec (1), infsupdec (realmax, inf)), infsupdec (1, "dac")));
66 tests, 66 passed, 0 known failure, 0 skipped
[inst/@infsupdec/roundb.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/roundb.m
***** # Empty interval
***** assert (isequal (roundb (infsupdec ()), infsupdec ()));
***** # Singleton intervals
***** assert (isequal (roundb (infsupdec (0)), infsupdec (0)));
***** assert (isequal (roundb (infsupdec (0.5)), infsupdec (0, "dac")));
***** assert (isequal (roundb (infsupdec (0.25)), infsupdec (0)));
***** assert (isequal (roundb (infsupdec (0.75)), infsupdec (1)));
***** assert (isequal (roundb (infsupdec (1.5)), infsupdec (2, "dac")));
***** assert (isequal (roundb (infsupdec (-0.5)), infsupdec (0, "dac")));
***** assert (isequal (roundb (infsupdec (-1.5)), infsupdec (-2, "dac")));
***** # Bounded intervals
***** assert (isequal (roundb (infsupdec (-0.5, 0)), infsupdec (0, "dac")));
***** assert (isequal (roundb (infsupdec (0, 0.5)), infsupdec (0, "dac")));
***** assert (isequal (roundb (infsupdec (0.25, 0.5)), infsupdec (0, "dac")));
***** assert (isequal (roundb (infsupdec (-1, 0)), infsupdec (-1, 0, "def")));
***** assert (isequal (roundb (infsupdec (-1, 1)), infsupdec (-1, 1, "def")));
***** assert (isequal (roundb (infsupdec (-realmin, realmin)), infsupdec (0)));
***** assert (isequal (roundb (infsupdec (-realmax, realmax)), infsupdec (-realmax, realmax, "def")));
***** # Unbounded intervals
***** assert (isequal (roundb (infsupdec (-realmin, inf)), infsupdec (0, inf, "def")));
***** assert (isequal (roundb (infsupdec (-realmax, inf)), infsupdec (-realmax, inf, "def")));
***** assert (isequal (roundb (infsupdec (-inf, realmin)), infsupdec (-inf, 0, "def")));
***** assert (isequal (roundb (infsupdec (-inf, realmax)), infsupdec (-inf, realmax, "def")));
***** assert (isequal (roundb (infsupdec (-inf, inf)), infsupdec (-inf, inf, "def")));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.roundTiesToEven;
 for testcase = [testcases]'
   assert (isequaln (...
     roundb (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.roundTiesToEven;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (roundb (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.roundTiesToEven;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (roundb (in1), out));
23 tests, 23 passed, 0 known failure, 0 skipped
[inst/@infsupdec/times.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/times.m
***** # from the documentation string
***** assert (isequal (infsupdec (2, 3) .* infsupdec (1, 2), infsupdec (2, 6)));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.mul;
 for testcase = [testcases]'
   assert (isequaln (...
     times (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.mul;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (times (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsupdec.mul;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (times (in1, in2), out));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsupdec/lu.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/lu.m
***** test
 [l, u] = lu (infsupdec (magic (3)));
 assert (isequal (l, infsupdec ({1, 0, 0; .375, 1, 0; .5, "68/37", 1}, "trv")));, ...
 assert (subset (u, infsupdec ({8, 1, 6; 0, 4.625, 4.75; 0, 0, "-0x1.3759F2298375Bp3"}, ...
                               {8, 1, 6; 0, 4.625, 4.75; 0, 0, "-0x1.3759F22983759p3"})));
 A = magic (3);
 A ([1, 5, 9]) = 0;
 [l, u, p] = lu (infsupdec (A));
 assert (p, [0, 0, 1; 1, 0, 0; 0, 1, 0]);
 assert (isequal (l, infsupdec ({1, 0, 0; "4/3", 1, 0; 0, "1/9", 1}, "trv")));
 assert (subset (u, infsupdec ({3, 0, 7; 0, 9, "-0x1.2AAAAAAAAAAACp3"; 0, 0, "0x1.C25ED097B425Ep2"}, ...
                               {3, 0, 7; 0, 9, "-0x1.2AAAAAAAAAAAAp3"; 0, 0, "0x1.C25ED097B426p2"})));
1 test, 1 passed, 0 known failure, 0 skipped
[inst/@infsupdec/intersect.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/intersect.m
***** # from the documentation string
***** assert (isequal (intersect (infsupdec (1, 3), infsupdec (2, 4)), infsupdec (2, 3, "trv")));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.intersection;
 for testcase = [testcases]'
   assert (isequaln (...
     intersect (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.intersection;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (intersect (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsupdec.intersection;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (intersect (in1, in2), out));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsupdec/cos.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/cos.m
***** # from the documentation string
***** assert (isequal (cos (infsupdec (1)), infsupdec ("[0x1.14A280FB5068Bp-1, 0x1.14A280FB5068Cp-1]")));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.cos;
 for testcase = [testcases]'
   assert (isequaln (...
     cos (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.cos;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (cos (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.cos;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (cos (in1), out));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsupdec/eq.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/eq.m
***** # Empty interval
***** assert (eq (infsupdec (), infsupdec ()) == true);
***** assert (eq (infsupdec (), infsupdec (1)) == false);
***** assert (eq (infsupdec (0), infsupdec ()) == false);
***** assert (eq (infsupdec (-inf, inf), infsupdec ()) == false);
***** # Singleton intervals
***** assert (eq (infsupdec (0), infsupdec (1)) == false);
***** assert (eq (infsupdec (0), infsupdec (0)) == true);
***** # Bounded intervals
***** assert (eq (infsupdec (1, 2), infsupdec (3, 4)) == false);
***** assert (eq (infsupdec (1, 2), infsupdec (2, 3)) == false);
***** assert (eq (infsupdec (1, 2), infsupdec (1.5, 2.5)) == false);
***** assert (eq (infsupdec (1, 2), infsupdec (1, 2)) == true);
***** # Unbounded intervals
***** assert (eq (infsupdec (0, inf), infsupdec (-inf, 0)) == false);
***** assert (eq (infsupdec (0, inf), infsupdec (0, inf)) == true);
***** assert (eq (infsupdec (-inf, 0), infsupdec (-inf, 0)) == true);
***** assert (eq (infsupdec (-inf, inf), infsupdec (42)) == false);
***** assert (eq (infsupdec (-inf, 0), infsupdec (-inf, inf)) == false);
***** assert (eq (infsupdec (-inf, inf), infsupdec (-inf, inf)) == true);
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.equal;
 for testcase = [testcases]'
   assert (isequaln (...
     eq (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.equal;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (eq (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsupdec.equal;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (eq (in1, in2), out));
19 tests, 19 passed, 0 known failure, 0 skipped
[inst/@infsupdec/intervalpart.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/intervalpart.m
***** warning id=interval:IntvlPartOfNaI
 assert (intervalpart (nai ()) == infsup ());
***** assert (intervalpart (infsupdec (2, 3)) == infsup (2, 3));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.intervalPart;
 for testcase = [testcases]'
   assert (isequaln (...
     intervalpart (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.intervalPart;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (intervalpart (in1), out));
***** warning
 testcases = testdata.IntvlPartOfNaI.infsupdec.intervalPart;
 for testcase = [testcases]'
   lastwarn ("", "");
   assert (isequaln (...
     intervalpart (testcase.in{1}), ...
     testcase.out));
   assert (nthargout (2, @lastwarn), "interval:IntvlPartOfNaI");
 endfor
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsupdec.intervalPart;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (intervalpart (in1), out));
6 tests, 6 passed, 0 known failure, 0 skipped
[inst/@infsupdec/coth.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/coth.m
***** # from the documentation string
***** assert (isequal (coth (infsupdec (1)), infsupdec ("[0x1.50231499B6B1D, 0x1.50231499B6B1E]_com")));
1 test, 1 passed, 0 known failure, 0 skipped
[inst/@infsupdec/sech.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/sech.m
***** # from the documentation string
***** assert (isequal (sech (infsupdec (1)), infsupdec ("[0x1.4BCDC50ED6BE7p-1, 0x1.4BCDC50ED6BE8p-1]_com")));
1 test, 1 passed, 0 known failure, 0 skipped
[inst/@infsupdec/nextout.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/nextout.m
***** # from the documentation string
***** test
 x = nextout (infsupdec (1));
 assert (inf (x), 1 - eps / 2);
 assert (sup (x), 1 + eps);
 assert (decorationpart (x), {"trv"});
1 test, 1 passed, 0 known failure, 0 skipped
[inst/@infsupdec/union.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/union.m
***** # from the documentation string
***** assert (isequal (union (infsupdec (1, 3), infsupdec (2, 4)), infsupdec (1, 4, "trv")));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.convexHull;
 for testcase = [testcases]'
   assert (isequaln (...
     union (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.convexHull;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (union (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsupdec.convexHull;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (union (in1, in2), out));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsupdec/pow10.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/pow10.m
***** # from the documentation string
***** assert (isequal (pow10 (infsupdec (5)), infsupdec (100000)));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.exp10;
 for testcase = [testcases]'
   assert (isequaln (...
     pow10 (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.exp10;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (pow10 (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsupdec.exp10;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2 || i == numel (in1))
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (pow10 (in1), out));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsupdec/psi.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/psi.m
***** assert (isempty (psi (infsupdec (0))));
***** assert (isempty (psi (infsupdec (-1))));
***** assert (isempty (psi (infsupdec (-2))));
***** assert (isempty (psi (infsupdec (-3))));
***** assert (isequal (psi (infsupdec (pow2 (-1074), inf)), infsupdec ("[Entire]_dac")));
***** assert (isequal (psi (infsupdec (0, inf)), infsupdec ("[Entire]_trv")));
***** assert (isequal (psi (infsupdec (-inf, -43.23)), infsupdec ("[Entire]_trv")));
***** assert (isequal (psi (infsupdec (-1, 0)), infsupdec ("[Entire]_trv")));
***** assert (isequal (psi (infsupdec (-2, -1)), infsupdec ("[Entire]_trv")));
***** assert (isequal (psi (infsupdec (-eps, eps)), infsupdec ("[Entire]_trv")));
***** assert (isequal (psi (infsupdec (-1-eps, -1+eps)), infsupdec ("[Entire]_trv")));
***** assert (isequal (psi (infsupdec (-4.1, -3.9)), infsupdec ("[Entire]_trv")));
***** # from the documentation string
***** assert (isequal (psi (infsupdec (1)), infsupdec ("[-0x1.2788CFC6FB619p-1, -0x1.2788CFC6FB618p-1]_com")));
13 tests, 13 passed, 0 known failure, 0 skipped
[inst/@infsupdec/power.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/power.m
***** # from the documentation string
***** assert (isequal (infsupdec (-5, 6) .^ infsupdec (2, 3), infsupdec (-125, 216, "trv")));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.sqr;
 for testcase = [testcases]'
   assert (isequaln (...
     power (testcase.in{1}, 2), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.sqr;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (power (in1, 2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.sqr;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (power (in1, 2), out));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsupdec/rsqrt.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/rsqrt.m
***** # from the documentation string
***** assert (isequal (rsqrt (infsupdec (-6, 4)), infsupdec (.5, inf, "trv")));
1 test, 1 passed, 0 known failure, 0 skipped
[inst/@infsupdec/atanh.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/atanh.m
***** # from the documentation string
***** assert (isequal (atanh (infsupdec (.5)), infsupdec ("[0x1.193EA7AAD030Ap-1, 0x1.193EA7AAD030Bp-1]")));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.atanh;
 for testcase = [testcases]'
   assert (isequaln (...
     atanh (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.atanh;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (atanh (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.atanh;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (atanh (in1), out));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsupdec/sqrrev.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/sqrrev.m
***** # from the documentation string
***** assert (isequal (sqrrev (infsupdec (-2, 1)), infsupdec (-1, 1, "trv")));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.sqrRev;
 for testcase = [testcases]'
   assert (isequaln (...
     sqrrev (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.sqrRev;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (sqrrev (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsupdec.sqrRev;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (sqrrev (in1), out));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.sqrRevBin;
 for testcase = [testcases]'
   assert (isequaln (...
     sqrrev (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.sqrRevBin;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (sqrrev (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsupdec.sqrRevBin;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (sqrrev (in1, in2), out));
7 tests, 7 passed, 0 known failure, 0 skipped
[inst/@infsupdec/sign.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/sign.m
***** # from the documentation string
***** assert (isequal (sign (infsupdec (2, 3)), infsupdec (1)));
***** assert (isequal (sign (infsupdec (0)), infsupdec (0, "dac")));
***** assert (isequal (sign (infsupdec (0, 5)), infsupdec (0, 1, "def")));
***** assert (isequal (sign (infsupdec (-17)), infsupdec (-1)));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.sign;
 for testcase = [testcases]'
   assert (isequaln (...
     sign (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.sign;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (sign (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.sign;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (sign (in1), out));
7 tests, 7 passed, 0 known failure, 0 skipped
[inst/@infsupdec/subsasgn.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/subsasgn.m
***** test
 A = infsupdec (magic (3));
 A(4, 4) = 42;
 assert (inf (A), [magic(3),[0;0;0];0,0,0,42]);
 assert (sup (A), [magic(3),[0;0;0];0,0,0,42]);
 assert (decorationpart (A), {"com", "com", "com", "com"; "com", "com", "com", "com"; "com", "com", "com", "com"; "com", "com", "com", "com"});
1 test, 1 passed, 0 known failure, 0 skipped
[inst/@infsupdec/coshrev.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/coshrev.m
***** # from the documentation string
***** assert (isequal (coshrev (infsupdec (-2, 1)), infsupdec (0, "trv")));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.coshRev;
 for testcase = [testcases]'
   assert (isequaln (...
     coshrev (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.coshRev;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (coshrev (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsupdec.coshRev;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (coshrev (in1), out));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.coshRevBin;
 for testcase = [testcases]'
   assert (isequaln (...
     coshrev (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.coshRevBin;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (coshrev (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsupdec.coshRevBin;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (coshrev (in1, in2), out));
7 tests, 7 passed, 0 known failure, 0 skipped
[inst/@infsupdec/tan.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/tan.m
***** # from the documentation string
***** assert (isequal (tan (infsupdec (1)), infsupdec ("[0x1.8EB245CBEE3A5, 0x1.8EB245CBEE3A6]")));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.tan;
 for testcase = [testcases]'
   assert (isequaln (...
     tan (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.tan;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (tan (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.tan;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (tan (in1), out));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsupdec/strictsubset.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/strictsubset.m
***** assert (strictsubset (infsupdec (1, 2), infsupdec (1, 3)));
***** assert (strictsubset (infsupdec (2, 3), infsupdec (1, 3)));
***** assert (not (strictsubset (infsupdec (1, 2), infsupdec (1, 2))));
***** assert (not (strictsubset (infsupdec (1, 3), infsupdec (1, 2))));
***** assert (strictsubset (infsupdec (), infsupdec (1, 3)));
***** assert (not (strictsubset (infsupdec (), infsupdec ())));
***** assert (strictsubset (infsupdec (), infsupdec (-inf, inf)));
***** assert (strictsubset (infsupdec (0, inf), infsupdec (-inf, inf)));
***** assert (strictsubset (infsupdec (-inf, 0), infsupdec (-inf, inf)));
***** assert (not (strictsubset (infsupdec (-inf, inf), infsupdec (-inf, inf))));
10 tests, 10 passed, 0 known failure, 0 skipped
[inst/@infsupdec/subsref.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/subsref.m
***** assert (isequal (infsupdec (magic (3))([1, 2, 3]), infsupdec (magic (3)([1, 2, 3]))));
***** # from the documentation string
***** test
 x = infsupdec (magic (3), magic (3) + 1);
 assert (x(1) == infsupdec (8, 9));
 assert (x(:, 2) == infsupdec ([1; 5; 9], [2; 6; 10]));
 assert (x.inf, magic (3));
***** assert (isequal (reshape (infsupdec (1:16), 2, 2, 2, 2)(2, 7), infsupdec (14)))
***** assert (isequal (reshape (infsupdec (1:16), 2, 2, 2, 2)(:, 2, 2, 2), infsupdec ([15; 16])))
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsupdec/precedes.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/precedes.m
***** assert (precedes (infsupdec (1, 2), infsupdec (2, 3)));
***** assert (not (precedes (infsupdec (1, 2.1), infsupdec (1.9, 3))));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.precedes;
 for testcase = [testcases]'
   assert (isequaln (...
     precedes (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.precedes;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (precedes (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsupdec.precedes;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (precedes (in1, in2), out));
5 tests, 5 passed, 0 known failure, 0 skipped
[inst/@infsupdec/sup.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/sup.m
***** assert (sup (infsupdec (2.5, 3.5)), 3.5);
***** assert (sup (infsupdec ()), -inf);
***** assert (sup (infsupdec ("[nai]")), nan);
***** warning id=interval:UndefinedOperation
 assert (sup (infsupdec (3, 2)), nan);
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.sup;
 for testcase = [testcases]'
   assert (isequaln (...
     sup (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.sup;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (sup (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.sup;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (sup (in1), out));
7 tests, 7 passed, 0 known failure, 0 skipped
[inst/@infsupdec/tril.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/tril.m
***** assert (tril (infsupdec (magic (10))) == tril (magic (10)));
***** assert (tril (infsupdec (magic (10)), 1) == tril (magic (10), 1));
***** assert (tril (infsupdec (magic (10)), -1) == tril (magic (10), -1));
***** assert (tril (infsupdec (magic (10)), 0, "pack") == tril (magic (10), 0, "pack"));
***** test
 A = infsupdec (zeros (3), "trv");
 assert (decorationpart (tril (A)), {"trv", "com", "com"; "trv", "trv", "com"; "trv", "trv", "trv"});
5 tests, 5 passed, 0 known failure, 0 skipped
[inst/@infsupdec/erfc.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/erfc.m
***** # from the documentation string
***** assert (erfc (infsupdec (1)) == "[0x1.4226162FBDDD4p-3, 0x1.4226162FBDDD5p-3]");
1 test, 1 passed, 0 known failure, 0 skipped
[inst/@infsupdec/cot.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/cot.m
***** # from the documentation string
***** assert (isequal (cot (infsupdec (1)), infsupdec ("[0x1.48C05D04E1CFDp-1, 0x1.48C05D04E1CFEp-1]")));
1 test, 1 passed, 0 known failure, 0 skipped
[inst/@infsupdec/log1p.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/log1p.m
***** # from the documentation string
***** assert (isequal (log1p (infsupdec (eps)), infsupdec ("[0x1.FFFFFFFFFFFFFp-53, 0x1p-52]")));
1 test, 1 passed, 0 known failure, 0 skipped
[inst/@infsupdec/setdiff.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/setdiff.m
***** assert (isempty (setdiff (infsupdec (), infsupdec (1, 4))));
***** assert (setdiff (infsupdec (1, 3), infsupdec ()) == infsupdec (1, 3));
***** assert (isempty (setdiff (infsupdec (1, 3), infsupdec (-inf, inf))));
***** assert (isempty (setdiff (infsupdec (1, 3), infsupdec (1, 4))));
***** assert (setdiff (infsupdec (-inf, inf), infsupdec (1, 4)) == infsupdec (-inf, inf));
***** # from the documentation string
***** assert (setdiff (infsupdec (1, 3), infsupdec (2, 4)) == infsupdec (1, 2));
6 tests, 6 passed, 0 known failure, 0 skipped
[inst/@infsupdec/linspace.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/linspace.m
***** assert (isequal (linspace (infsupdec (0), infsupdec (10), 9), infsupdec (linspace (0, 10, 9))));
1 test, 1 passed, 0 known failure, 0 skipped
[inst/@infsupdec/min.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/min.m
***** # from the documentation string
***** assert (isequal (min (infsupdec (2, 3), infsupdec (1, 2)), infsupdec (1, 2)));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.min;
 for testcase = [testcases]'
   assert (isequaln (...
     min (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.min;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (min (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsupdec.min;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (min (in1, in2), out));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsupdec/disjoint.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/disjoint.m
***** assert (disjoint (infsupdec (3, 4), infsupdec (5, 6)));
***** assert (not (disjoint (infsupdec (3, 4), infsupdec (4, 5))));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.disjoint;
 for testcase = [testcases]'
   assert (isequaln (...
     disjoint (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.disjoint;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (disjoint (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsupdec.disjoint;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (disjoint (in1, in2), out));
5 tests, 5 passed, 0 known failure, 0 skipped
[inst/@infsupdec/prod.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/prod.m
***** # from the documentation string
***** assert (prod (infsupdec (1 : 4)) == 24);
***** assert (prod (infsupdec ([])) == 1);
***** assert (isequal (prod (infsupdec (magic (3))), infsupdec ([96, 45, 84])));
***** assert (isequal (prod (infsupdec (magic (3)), 2), infsupdec ([48; 105; 72])));
***** assert (isequal (prod (infsupdec (magic (3)), 3), infsupdec (magic (3))));
***** assert (isequal (prod (prod (reshape (infsup (1:24), 1, 2, 3, 4))), infsup (reshape ([720, 665280, 13366080, 96909120], 1, 1, 1, 4))));
6 tests, 6 passed, 0 known failure, 0 skipped
[inst/@infsupdec/cosh.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/cosh.m
***** # from the documentation string
***** assert (isequal (cosh (infsupdec (1)), infsupdec ("[0x1.8B07551D9F55, 0x1.8B07551D9F551]")));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.cosh;
 for testcase = [testcases]'
   assert (isequaln (...
     cosh (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.cosh;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (cosh (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.cosh;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (cosh (in1), out));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsupdec/asin.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/asin.m
***** # from the documentation string
***** assert (isequal (asin (infsupdec (.5)), infsupdec ("[0x1.0C152382D7365p-1, 0x1.0C152382D7366p-1]")));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.asin;
 for testcase = [testcases]'
   assert (isequaln (...
     asin (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.asin;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (asin (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.asin;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (asin (in1), out));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsupdec/resize.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/resize.m
***** assert (isequal (resize (infsupdec (magic (3)), 4, 2), infsupdec([8, 1; 3, 5; 4, 9; 0, 0])));
***** assert (isequal (resize (infsupdec (ones (2, 2, 2)), 4, 1, 2), infsupdec (resize (ones (2, 2, 2), 4, 1, 2))))
2 tests, 2 passed, 0 known failure, 0 skipped
[inst/@infsupdec/acos.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/acos.m
***** # from the documentation string
***** assert (isequal (acos (infsupdec (.5)), infsupdec ("[0x1.0C152382D7365, 0x1.0C152382D7366]")));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.acos;
 for testcase = [testcases]'
   assert (isequaln (...
     acos (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.acos;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (acos (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.acos;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (acos (in1), out));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsupdec/subset.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/subset.m
***** assert (subset (infsupdec (1, 2), infsupdec (1, 3)));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.subset;
 for testcase = [testcases]'
   assert (isequaln (...
     subset (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.subset;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (subset (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsupdec.subset;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (subset (in1, in2), out));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsupdec/mpower.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/mpower.m
***** # from the documentation string
***** assert (isequal (infsupdec (magic (3)) ^ 2, infsupdec (magic (3) ^ 2)));
1 test, 1 passed, 0 known failure, 0 skipped
[inst/@infsupdec/setxor.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/setxor.m
***** test
 [z, z1, z2] = setxor (infsupdec (), infsupdec ());
 assert (isempty (z));
 assert (isempty (z1));
 assert (isempty (z2));
***** test
 [z, z1, z2] = setxor (infsupdec (-inf, inf), infsupdec ());
 assert (isentire (z));
 assert (isentire (z1));
 assert (isempty (z2));
***** test
 [z, z1, z2] = setxor (infsupdec (-inf, inf), infsupdec (2));
 assert (isentire (z));
 assert (z1 == infsupdec (-inf, 2));
 assert (z2 == infsupdec (2, inf));
***** test
 [z, z1, z2] = setxor (infsupdec (2, 3), infsupdec (2));
 assert (z == infsupdec (2, 3));
 assert (z1 == infsupdec ());
 assert (z2 == infsupdec (2, 3));
***** test
 [z, z1, z2] = setxor (infsupdec (2, 3), infsupdec (2, 2.5));
 assert (z == infsupdec (2.5, 3));
 assert (z1 == infsupdec ());
 assert (z2 == infsupdec (2.5, 3));
***** test
 # from the documentation string
 [z, z1, z2] = setxor (infsupdec (1, 3), infsupdec (2, 4));
 assert (z == infsupdec (1, 4));
 assert (z1 == infsupdec (1, 2));
 assert (z2 == infsupdec (3, 4));
6 tests, 6 passed, 0 known failure, 0 skipped
[inst/@infsupdec/asinh.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/asinh.m
***** # from the documentation string
***** assert (isequal (asinh (infsupdec (1)), infsupdec ("[0x1.C34366179D426p-1, 0x1.C34366179D427p-1]")));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.asinh;
 for testcase = [testcases]'
   assert (isequaln (...
     asinh (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.asinh;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (asinh (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.asinh;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (asinh (in1), out));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsupdec/round.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/round.m
***** # Empty interval
***** assert (isequal (round (infsupdec ()), infsupdec ()));
***** # Singleton intervals
***** assert (isequal (round (infsupdec (0)), infsupdec (0)));
***** assert (isequal (round (infsupdec (0.5)), infsupdec (1, "dac")));
***** assert (isequal (round (infsupdec (0.25)), infsupdec (0)));
***** assert (isequal (round (infsupdec (0.75)), infsupdec (1)));
***** assert (isequal (round (infsupdec (-0.5)), infsupdec (-1, "dac")));
***** # Bounded intervals
***** assert (isequal (round (infsupdec (-0.5, 0)), infsupdec (-1, 0, "def")));
***** assert (isequal (round (infsupdec (0, 0.5)), infsupdec (0, 1, "def")));
***** assert (isequal (round (infsupdec (0.25, 0.5)), infsupdec (0, 1, "def")));
***** assert (isequal (round (infsupdec (-1, 0)), infsupdec (-1, 0, "def")));
***** assert (isequal (round (infsupdec (-1, 1)), infsupdec (-1, 1, "def")));
***** assert (isequal (round (infsupdec (-realmin, realmin)), infsupdec (0)));
***** assert (isequal (round (infsupdec (-realmax, realmax)), infsupdec (-realmax, realmax, "def")));
***** # Unbounded intervals
***** assert (isequal (round (infsupdec (-realmin, inf)), infsupdec (0, inf, "def")));
***** assert (isequal (round (infsupdec (-realmax, inf)), infsupdec (-realmax, inf, "def")));
***** assert (isequal (round (infsupdec (-inf, realmin)), infsupdec (-inf, 0, "def")));
***** assert (isequal (round (infsupdec (-inf, realmax)), infsupdec (-inf, realmax, "def")));
***** assert (isequal (round (infsupdec (-inf, inf)), infsupdec (-inf, inf, "def")));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.roundTiesToAway;
 for testcase = [testcases]'
   assert (isequaln (...
     round (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.roundTiesToAway;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (round (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.roundTiesToAway;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (round (in1), out));
21 tests, 21 passed, 0 known failure, 0 skipped
[inst/@infsupdec/powrev2.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/powrev2.m
***** # from the documentation string
***** assert (isequal (powrev2 (infsupdec (2, 5), infsupdec (3, 6)), infsupdec ("[0x1.5D7E8F22BA886p-1, 0x1.4AE00D1CFDEB5p1]_trv")));
1 test, 1 passed, 0 known failure, 0 skipped
[inst/@infsupdec/exp.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/exp.m
***** # from the documentation string
***** assert (isequal (exp (infsupdec (1)), infsupdec ("e")));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.exp;
 for testcase = [testcases]'
   assert (isequaln (...
     exp (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.exp;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (exp (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.exp;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (exp (in1), out));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsupdec/log2.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/log2.m
***** # from the documentation string
***** assert (isequal (log2 (infsupdec (2)), infsupdec (1)));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.log2;
 for testcase = [testcases]'
   assert (isequaln (...
     log2 (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.log2;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (log2 (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.log2;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (log2 (in1), out));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsupdec/bitunpack.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/bitunpack.m
***** test
  littleendian = bitunpack (uint16 (1))(1);
  b = zeros (1, 136);
  if (littleendian)
    b([52, 63, 117, 127, 133]) = 1;
  else
    b([7, 12, 71, 77, 133]) = 1;
  endif
  assert (bitunpack (infsupdec (3, 4)), logical (b));
1 test, 1 passed, 0 known failure, 0 skipped
[inst/@infsupdec/minus.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/minus.m
***** # from the documentation string
***** assert (isequal (infsupdec (2, 3) - infsupdec (1, 2), infsupdec (0, 2)));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.sub;
 for testcase = [testcases]'
   assert (isequaln (...
     minus (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.sub;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (minus (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsupdec.sub;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (minus (in1, in2), out));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsupdec/expm1.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/expm1.m
***** # from the documentation string
***** assert (isequal (expm1 (infsupdec (eps)), infsupdec ("[0x1p-52, 0x1.0000000000001p-52]")));
1 test, 1 passed, 0 known failure, 0 skipped
[inst/@infsupdec/interior.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/interior.m
***** assert (interior (infsupdec (1, 2), infsupdec (0, 3)));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.interior;
 for testcase = [testcases]'
   assert (isequaln (...
     interior (testcase.in{1}, testcase.in{2}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.interior;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 assert (isequaln (interior (in1, in2), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsupdec.interior;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 in2 = vertcat (vertcat (testcases.in){:, 2});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 in2 = reshape ([in2; in2(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (interior (in1, in2), out));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsupdec/tanh.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/tanh.m
***** test "from the documentation string";
 assert (isequal (tanh (infsupdec (1)), infsupdec ("[0x1.85EFAB514F394p-1, 0x1.85EFAB514F395p-1]")));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.tanh;
 for testcase = [testcases]'
   assert (isequaln (...
     tanh (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.tanh;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (tanh (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.tanh;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (tanh (in1), out));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/@infsupdec/log.m]
>>>>> /<<PKGBUILDDIR>>/inst/@infsupdec/log.m
***** # from the documentation string
***** assert (isequal (log (infsupdec (2)), infsupdec ("[0x1.62E42FEFA39EFp-1, 0x1.62E42FEFA39Fp-1]")));
***** shared testdata
 # Load compiled test data (from src/test/*.itl)
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.infsupdec.log;
 for testcase = [testcases]'
   assert (isequaln (...
     log (testcase.in{1}), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.infsupdec.log;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 assert (isequaln (log (in1), out));
***** test
 # N-dimensional array evaluation
 testcases = testdata.NoSignal.infsup.log;
 in1 = vertcat (vertcat (testcases.in){:, 1});
 out = vertcat (testcases.out);
 # Reshape data
 i = -1;
 do
   i = i + 1;
   testsize = factor (numel (in1) + i);
 until (numel (testsize) > 2)
 in1 = reshape ([in1; in1(1:i)], testsize);
 out = reshape ([out; out(1:i)], testsize);
 assert (isequaln (log (in1), out));
4 tests, 4 passed, 0 known failure, 0 skipped
[inst/midrad.m]
>>>>> /<<PKGBUILDDIR>>/inst/midrad.m
***** assert (isempty (midrad ()));
***** warning id=interval:UndefinedOperation
 assert (isnai (midrad (0, -inf)));
***** warning id=interval:UndefinedOperation
 assert (isnai (midrad (0, -.1)));
***** warning id=interval:UndefinedOperation
 assert (isnai (midrad (0, "-.1")));
***** warning id=interval:UndefinedOperation
 assert (isnai (midrad (0, infsup("-.1"))));
***** assert (isequal (midrad ("pi"), infsupdec ("pi")));
***** warning id=interval:ImplicitPromote
 assert (isequal (midrad (infsup (2), 2), infsupdec (0, 4)));
***** assert (isequal (midrad (2, infsup (2)), infsupdec (0, 4)));
***** warning id=interval:ImplicitPromote
 assert (isequal (midrad (infsup (2), infsup (2)), infsupdec (0, 4)));
***** assert (isequal (midrad (2, infsupdec (2)), infsupdec (0, 4)));
***** assert (isequal (midrad (infsupdec (2), 2), infsupdec (0, 4)));
***** warning id=interval:ImplicitPromote
 assert (isequal (midrad (infsup (2), infsupdec (2)), infsupdec (0, 4)));
***** assert (isequal (midrad (infsupdec (2), infsup (2)), infsupdec (0, 4)));
***** assert (isequal (midrad (infsupdec (2), infsupdec (2)), infsupdec (0, 4)));
***** assert (isequal (midrad (1, magic (3)), infsupdec ([-7, 0, -5; -2, -4, -6; -3, -8, -1], [9, 2, 7; 4, 6, 8; 5, 10, 3])));
***** assert (isequal (midrad (magic (3), 1), infsupdec ([7, 0, 5; 2, 4, 6; 3, 8, 1], [9, 2, 7; 4, 6, 8; 5, 10, 3])));
***** # from the documentation string
***** assert (isequal (midrad (42, 3), infsupdec (39, 45)));
***** assert (isequal (midrad (0, inf), entire ()));
***** assert (isequal (midrad ("1.1", "0.1"), infsupdec (1 - eps, "1.2")));
***** # N-dimensional arrays
***** assert (isequal (midrad (zeros (2, 2, 2), ones (2, 2, 2)), infsupdec (-ones (2, 2, 2), ones (2, 2, 2))));
***** assert (isequal (midrad (zeros (2, 2, 2), 1), infsupdec (-ones (2, 2, 2), ones (2, 2, 2))));
***** assert (isequal (midrad (0, ones (2, 2, 2)), infsupdec (-ones (2, 2, 2), ones (2, 2, 2))));
***** test
 [M, R] = midrad (infsupdec (-ones (2, 2, 2), ones (2, 2, 2)));
 assert (M, zeros (2, 2, 2));
 assert (R, ones (2, 2, 2));
23 tests, 23 passed, 0 known failure, 0 skipped
[inst/verinvnonneg.m]
>>>>> /<<PKGBUILDDIR>>/inst/verinvnonneg.m
***** assert (verinvnonneg (eye (1)), 1)
***** assert (verinvnonneg (eye (2)), 1)
***** assert (verinvnonneg (eye (3)), 1)
***** assert (verinvnonneg (eye (4)), 1)
***** assert (verinvnonneg (eye (5)), 1)
***** assert (verinvnonneg (eye (6)), 1)
***** assert (verinvnonneg (eye (7)), 1)
***** assert (verinvnonneg (eye (8)), 1)
***** assert (verinvnonneg (zeros (1)), 0)
***** assert (verinvnonneg (zeros (2)), 0)
***** assert (verinvnonneg (zeros (3)), 0)
***** assert (verinvnonneg (zeros (4)), 0)
***** assert (verinvnonneg (zeros (5)), 0)
***** assert (verinvnonneg (zeros (6)), 0)
***** assert (verinvnonneg (zeros (7)), 0)
***** assert (verinvnonneg (zeros (8)), 0)
***** assert (verinvnonneg (magic (7)), 0)
***** assert (verinvnonneg (infsup (-inf, inf)), -1)
18 tests, 18 passed, 0 known failure, 0 skipped
[inst/empty.m]
>>>>> /<<PKGBUILDDIR>>/inst/empty.m
***** assert (inf (empty ()), inf);
***** assert (sup (empty ()), -inf);
***** assert (decorationpart (empty ()), {"trv"});
***** assert (inf (empty (5)), inf (5));
***** assert (sup (empty (5)), -inf (5));
***** assert (strcmp (decorationpart (empty (5)), "trv"), true (5));
***** assert (inf (empty (5, 6)), inf (5, 6));
***** assert (sup (empty (5, 6)), -inf (5, 6));
***** assert (strcmp (decorationpart (empty (5, 6)), "trv"), true (5, 6));
***** assert (inf (empty (5, 6, 7)), inf (5, 6, 7));
***** assert (sup (empty (5, 6, 7)), -inf (5, 6, 7));
***** assert (strcmp (decorationpart (empty (5, 6, 7)), "trv"), true (5, 6, 7));
12 tests, 12 passed, 0 known failure, 0 skipped
[inst/vereigvec.m]
>>>>> /<<PKGBUILDDIR>>/inst/vereigvec.m
***** test
 A = [1 0 0; 0 1 1; 0 0 1];
 assert (vereigvec (A, [1; 0; 0]), 1);
 assert (vereigvec (A, [0; 1; 0]), 1);
 assert (vereigvec (A, [0; 0; 1]), 0);
***** test
 A = magic (3);
 [evc, lambda] = vereigvec (A, [1 1 1]);
 assert (evc, 1);
 assert (lambda == 15);
 assert (vereigvec (A, [1; 0; 0]), 0);
 assert (vereigvec (A, [0; 1; 0]), 0);
 assert (vereigvec (A, [0; 0; 1]), 0);
***** test
 A = magic (3) + infsup ("[-5, 5]");
 [evc, lambda, As] = vereigvec (A, [1 0 0]);
 assert (evc, 1);
 assert (lambda == "[3, 13]");
 assert (ismember ([8 1 6; 0 2 4; 0 5 -2], As));
 assert (max (max (wid (As))) < 1e-14);
3 tests, 3 passed, 0 known failure, 0 skipped
[inst/verlinineqnn.m]
>>>>> /<<PKGBUILDDIR>>/inst/verlinineqnn.m
***** test
 A = [-2, -3; -2, -1];
 b = [-1500; -1000];
 [x, y] = verlinineqnn (A, b);
 assert (x, [375; 250], 1e-9);
 assert (all (x >= [375; 250]));
 assert (isnan (y));
***** test
 A = [1, 2; 3, 4];
 b = [-1; 0];
 [x, y] = verlinineqnn (A, b);
 assert (y, [1; 0], 1e-9);
 assert (all (y >= [1; 0]));
 assert (isnan (x));
***** test
 A = [1, 2; 3, 4];
 b = [1; 1];
 [x, y] = verlinineqnn (A, b);
 assert (x, [0; 0]);
 assert (isnan (y));
3 tests, 3 passed, 0 known failure, 0 skipped
[inst/nai.m]
>>>>> /<<PKGBUILDDIR>>/inst/nai.m
***** assert (isnai (nai ()));
***** assert (isnai (nai (2)), true (2));
***** assert (isnai (nai (3, 4)), true (3, 4));
***** assert (decorationpart (nai ()), {"ill"});
***** assert (isnai (nai (2, 2, 2)), true (2, 2, 2))
5 tests, 5 passed, 0 known failure, 0 skipped
Checking C++ files ...
[src/intervaltotext.cc]
>>>>> /<<PKGBUILDDIR>>/src/intervaltotext.cc
***** assert (intervaltotext (infsup (1 + eps), "exact decimal"), "[1.0000000000000002220446049250313080847263336181640625]");
***** assert (intervaltotext (infsup (1 + eps), "exact hexadecimal"), "[0x1.0000000000001p+0]");
***** assert (intervaltotext (infsup (pi), "[.3g]"), "[3.14, 3.15]");
***** assert (intervaltotext (infsup (pi), "[.4g]"), "[3.141, 3.142]");
***** assert (intervaltotext (infsup (1 + eps)), "[1, 1.00001]");
***** assert (intervaltotext (infsup (1)), "[1]");
***** assert (reshape (intervaltotext (infsup (reshape (1:120, 2, 3, 4, 5))), 1, 120), intervaltotext (infsup (1:120)));
***** assert (intervaltotext (infsupdec (1 + eps), "exact decimal"), "[1.0000000000000002220446049250313080847263336181640625]_com");
***** assert (intervaltotext (infsupdec (1 + eps), "exact hexadecimal"), "[0x1.0000000000001p+0]_com");
***** assert (intervaltotext (infsupdec (1 + eps)), "[1, 1.00001]_com");
***** assert (intervaltotext (infsupdec (1)), "[1]_com");
***** assert (reshape (intervaltotext (infsupdec (reshape (1:120, 2, 3, 4, 5))), 1, 120), intervaltotext (infsupdec (1:120)));
***** assert (intervaltotext (infsup (2, 3), "[g]"), "[2, 3]");
***** assert (intervaltotext (infsup (2, 3), "9:[g]"), "[  2,  3]");
***** assert (intervaltotext (infsup (), "[g]"), "[Empty]");
***** assert (intervaltotext (infsup (), "9:[g]"), "[ Empty ]");
***** assert (intervaltotext (infsup (2, 3), "g"), "2 3");
***** assert (intervaltotext (infsupdec (2, 3), "g"), "2 3 _com");
***** assert (intervaltotext (infsup (), "[Cg]"), "[EMPTY]");
***** assert (intervaltotext (infsup (), "[cg]"), "[empty]");
***** assert (intervaltotext (infsup (-inf, inf), "[g]"), "[Entire]");
***** assert (intervaltotext (infsup (-inf, inf), "[<g]"), "[-inf, inf]");
***** assert (intervaltotext (infsup (2, 3), "[3g]"), "[  2,   3]");
***** assert (intervaltotext (infsup (2, 3), "[-3g]"), "[2  , 3  ]");
***** assert (intervaltotext (infsup (2, 3), "[03g]"), "[002, 003]");
***** assert (intervaltotext (infsup (2, 3), "[+g]"), "[+2, +3]");
***** assert (intervaltotext (infsup (2, 3), "[ g]"), "[2, 3]");
***** assert (intervaltotext (infsup (2, 3), "[g]"), "[2, 3]");
***** assert (intervaltotext (infsup (-2, 3), "[+g]"), "[-2, +3]");
***** assert (intervaltotext (infsup (-2, 3), "[ g]"), "[-2, 3]");
***** assert (intervaltotext (infsup (-2, 3), "[g]"), "[-2, +3]");
***** assert (intervaltotext (infsup (2, 3), "[f]"), "[2.000000, 3.000000]");
***** assert (intervaltotext (infsup (2, 3), "[e]"), "[2.000000e+00, 3.000000e+00]");
***** assert (intervaltotext (infsup (2, 3), "[E]"), "[2.000000E+00, 3.000000E+00]");
***** assert (intervaltotext (infsup (-inf, inf), "[<F]"), "[-INF, INF]");
***** assert (intervaltotext (infsup (2, 3), "?g"), "2.5?5");
***** assert (intervaltotext (infsup (2, 3), "9:?g"), "    2.5?5");
***** assert (intervaltotext (infsup (), "?g"), "[Empty]");
***** assert (intervaltotext (infsup (), "9:?g"), "[ Empty ]");
***** assert (intervaltotext (infsup (), "C?g"), "[EMPTY]");
***** assert (intervaltotext (infsup (), "c?g"), "[empty]");
***** assert (intervaltotext (infsup (-inf, inf), "?g"), "0??");
***** assert (intervaltotext (infsup (2, 3), "4?g"), " 2.5?5");
***** assert (intervaltotext (infsup (2, 3), "?3g"), "2.5?005");
***** assert (intervaltotext (infsup (2, 3), "04?g"), "02.5?5");
***** assert (intervaltotext (infsup (2, 3), "+?g"), "+2.5?5");
***** assert (intervaltotext (infsup (2, 3), "?f"), "2.500000?500000");
***** assert (intervaltotext (infsup (2, 3), "?e"), "2.500000?500000e+00");
***** assert (intervaltotext (infsup (2, 3), "?E"), "2.500000?500000E+00");
49 tests, 49 passed, 0 known failure, 0 skipped
[src/mpfr_linspace_d.cc]
>>>>> /<<PKGBUILDDIR>>/src/mpfr_linspace_d.cc
***** assert (mpfr_linspace_d (-inf, 1, 10, 10), 1 : 10);
***** assert (mpfr_linspace_d (inf, 1, 10, 8) - mpfr_linspace_d (-inf, 1, 10, 8), [0 2 2 4 4 4 8 0] .* eps);
2 tests, 2 passed, 0 known failure, 0 skipped
[src/mpfr_vector_sum_d.cc]
>>>>> /<<PKGBUILDDIR>>/src/mpfr_vector_sum_d.cc
***** assert (mpfr_vector_sum_d (0, [eps, realmax, realmax, -realmax, -realmax], 2), eps)
***** assert (mpfr_vector_sum_d (-inf, [eps/2, 1], 2), 1)
***** assert (mpfr_vector_sum_d (+inf, [eps/2, 1], 2), 1 + eps)
***** test
  a = inf (infsup ("0X1.1111111111111P+100"));
  b = inf (infsup ("0X1.1111111111111P+1"));
  [s, e] = mpfr_vector_sum_d (0.5, [a, b], 2);
  assert (s, a);
  assert (e, b);
***** test
  a = inf (infsup ("0X1.1111111111111P+53"));
  b = inf (infsup ("0X1.1111111111111P+1"));
  c = inf (infsup ("0X1.1111111111112P+53"));
  d = inf (infsup ("0X1.111111111111P-3"));
  [s, e] = mpfr_vector_sum_d (0.5, [a, b], 2);
  assert (s, c);
  assert (e, d);
***** test
  a = inf (infsup ("0X1.1111111111111P+2"));
  b = inf (infsup ("0X1.1111111111111P+1"));
  c = inf (infsup ("0X1.999999999999AP+2"));
  d = inf (infsup ("-0X1P-51"));
  [s, e] = mpfr_vector_sum_d (0.5, [a, b], 2);
  assert (s, c);
  assert (e, d);
***** test
  for dim = 1:6
    assert (mpfr_vector_sum_d (0.5, ones (1, 2, 3, 4, 5), dim), sum (ones (1, 2, 3, 4, 5), dim));
  endfor
***** shared testdata
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.double.sum_nearest;
 for testcase = [testcases]'
   assert (isequaln (...
     mpfr_vector_sum_d (0.5, testcase.in{1}, 2), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.double.sum_nearest;
 in1 = vertcat (testcases.in);
 in1 = cell2mat (cellfun ("postpad", in1, {(max (cellfun ("numel", in1)))}, "UniformOutput", false));
 out = vertcat (testcases.out);
 assert (isequaln (mpfr_vector_sum_d (0.5, in1, 2), out));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.double.sum_abs_nearest;
 for testcase = [testcases]'
   assert (isequaln (...
     mpfr_vector_sum_d (0.5, abs (testcase.in{1}), 2), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.double.sum_abs_nearest;
 in1 = vertcat (testcases.in);
 in1 = cell2mat (cellfun ("postpad", in1, {(max (cellfun ("numel", in1)))}, "UniformOutput", false));
 out = vertcat (testcases.out);
 assert (isequaln (mpfr_vector_sum_d (0.5, abs (in1), 2), out));
11 tests, 11 passed, 0 known failure, 0 skipped
[src/mpfr_function_d.cc]
>>>>> /<<PKGBUILDDIR>>/src/mpfr_function_d.cc
***** assert (mpfr_function_d ('plus', 0, 2, 2), 4);
***** assert (mpfr_function_d ('plus', -inf, 1, eps / 2), 1);
***** assert (mpfr_function_d ('plus', +inf, 1, eps / 2), 1 + eps);
***** error mpfr_function_d ('Krauskefarben', 0, 47, 11);
***** # Cross-check unit tests from crlibm against the MPFR library.
***** # We simulate binary64 floating-point arithmetic in MPFR
***** # with mpfr_function_d and results shall be identical.
***** #
***** shared testdata
 testdata = load (fullfile (...
   fileparts (file_in_loadpath ("__check_crlibm__.m")), ...
   "test", ...
   "crlibm.mat"));
***** function verify (fname, rnd, data)
  assert (mpfr_function_d (fname, rnd, data.input), data.output);
***** endfunction
***** test verify ("acos", -inf, testdata.acos_rd);
***** test verify ("acos", +inf, testdata.acos_ru);
***** test verify ("acos",  0.5, testdata.acos_rn);
***** test verify ("acos",  0,   testdata.acos_rz);
***** test verify ("asin", -inf, testdata.asin_rd);
***** test verify ("asin", +inf, testdata.asin_ru);
***** test verify ("asin",  0.5, testdata.asin_rn);
***** test verify ("asin",  0,   testdata.asin_rz);
***** test verify ("atan", -inf, testdata.atan_rd);
***** test verify ("atan", +inf, testdata.atan_ru);
***** test verify ("atan",  0.5, testdata.atan_rn);
***** test verify ("atan",  0,   testdata.atan_rz);
***** test verify ("cos", -inf, testdata.cos_rd);
***** test verify ("cos", +inf, testdata.cos_ru);
***** test verify ("cos",  0.5, testdata.cos_rn);
***** test verify ("cos",  0,   testdata.cos_rz);
***** test verify ("cosh", -inf, testdata.cosh_rd);
***** test verify ("cosh", +inf, testdata.cosh_ru);
***** test verify ("cosh",  0.5, testdata.cosh_rn);
***** test verify ("cosh",  0,   testdata.cosh_rz);
***** test verify ("exp", -inf, testdata.exp_rd);
***** test verify ("exp", +inf, testdata.exp_ru);
***** test verify ("exp",  0.5, testdata.exp_rn);
***** test verify ("exp",  0,   testdata.exp_rz);
***** test verify ("expm1", -inf, testdata.expm1_rd);
***** test verify ("expm1", +inf, testdata.expm1_ru);
***** test verify ("expm1",  0.5, testdata.expm1_rn);
***** test verify ("expm1",  0,   testdata.expm1_rz);
***** test verify ("log", -inf, testdata.log_rd);
***** test verify ("log", +inf, testdata.log_ru);
***** test verify ("log",  0.5, testdata.log_rn);
***** test verify ("log",  0,   testdata.log_rz);
***** test verify ("log10", -inf, testdata.log10_rd);
***** test verify ("log10", +inf, testdata.log10_ru);
***** test verify ("log10",  0.5, testdata.log10_rn);
***** test verify ("log10",  0,   testdata.log10_rz);
***** test verify ("log1p", -inf, testdata.log1p_rd);
***** test verify ("log1p", +inf, testdata.log1p_ru);
***** test verify ("log1p",  0.5, testdata.log1p_rn);
***** test verify ("log1p",  0,   testdata.log1p_rz);
***** test verify ("log2", -inf, testdata.log2_rd);
***** test verify ("log2", +inf, testdata.log2_ru);
***** test verify ("log2",  0.5, testdata.log2_rn);
***** test verify ("log2",  0,   testdata.log2_rz);
***** test verify ("sin", -inf, testdata.sin_rd);
***** test verify ("sin", +inf, testdata.sin_ru);
***** test verify ("sin",  0.5, testdata.sin_rn);
***** test verify ("sin",  0,   testdata.sin_rz);
***** test verify ("sinh", -inf, testdata.sinh_rd);
***** test verify ("sinh", +inf, testdata.sinh_ru);
***** test verify ("sinh",  0.5, testdata.sinh_rn);
***** test verify ("sinh",  0,   testdata.sinh_rz);
***** test verify ("tan", -inf, testdata.tan_rd);
***** test verify ("tan", +inf, testdata.tan_ru);
***** test verify ("tan",  0.5, testdata.tan_rn);
***** test verify ("tan",  0,   testdata.tan_rz);
60 tests, 60 passed, 0 known failure, 0 skipped
[src/mpfr_matrix_sqr_d.cc]
>>>>> /<<PKGBUILDDIR>>/src/mpfr_matrix_sqr_d.cc
***** test
 m = magic (3);
 [l, u] = mpfr_matrix_sqr_d (m, m + 1);
 assert (l, [91, 67, 67; 67, 91, 67; 67, 67, 91]);
 assert (u, [124, 100, 100; 100, 124, 100; 100, 100, 124]);
1 test, 1 passed, 0 known failure, 0 skipped
[src/crlibm_function.cc]
>>>>> /<<PKGBUILDDIR>>/src/crlibm_function.cc
***** test
  for f = {"acos", "asin", "atan", "cos", "cosh", "exp", "expm1", "log", "log10", "log1p", "log2", "sin", "sinh", "tan"}
    for rnd = {+inf, -inf, 0, 0.5}
      assert (crlibm_function (f{:}, rnd{:}, 0.5), mpfr_function_d (f{:}, rnd{:}, 0.5));
    endfor
  endfor
!!!!! test failed
ASSERT errors for:  assert (crlibm_function (f {:}, rnd {:}, 0.5),mpfr_function_d (f {:}, rnd {:}, 0.5))

  Location  |  Observed  |  Expected  |  Reason
     ()        -0.69315     -0.69315     Abs err 1.1102e-16 exceeds tol 0 by 1e-16
1 test, 0 passed, 0 known failure, 0 skipped
[src/mpfr_vector_dot_d.cc]
>>>>> /<<PKGBUILDDIR>>/src/mpfr_vector_dot_d.cc
***** test;
  [l, u] = mpfr_vector_dot_d (-1, -1, 2, 3, 1);
  assert (l, -3);
  assert (u, 6);
***** test;
  x = [realmax, realmax, -realmax, -realmax, 1, eps/2];
  y = ones (size (x));
  [l, u] = mpfr_vector_dot_d (x, y, x, y, 2);
  d = mpfr_vector_dot_d (0.5, x, y, 2);
  assert (l, 1);
  assert (u, 1 + eps);
  assert (ismember (d, infsup (l, u)));
***** test;
  [l, u] = mpfr_vector_dot_d (0, 0, inf, inf, 1);
  d = mpfr_vector_dot_d (0.5, 0, inf, 1);
  assert (l, 0);
  assert (u, inf);
  assert (isequaln (d, NaN));
***** test;
  x = reshape (1:24, 2, 3, 4);
  y = 2.*ones (2, 3, 4);
  [l u] = mpfr_vector_dot_d (x, y, x, y, 3);
  d = mpfr_vector_dot_d (0.5, x, y, 3);
  assert (l, [80, 96, 112; 88, 104, 120]);
  assert (u, [80, 96, 112; 88, 104, 120]);
  assert (d, [80, 96, 112; 88, 104, 120]);
***** shared testdata
 testdata = load (file_in_loadpath ("test/itl.mat"));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.double.dot_nearest;
 for testcase = [testcases]'
   assert (isequaln (...
     mpfr_vector_dot_d (0.5, testcase.in{1}, testcase.in{2}, 2), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.double.dot_nearest;
 in1 = vertcat (testcases.in)(:, 1);
 in1 = cell2mat (cellfun ("postpad", in1, {(max (cellfun ("numel", in1)))}, "UniformOutput", false));
 in2 = vertcat (testcases.in)(:, 2);
 in2 = cell2mat (cellfun ("postpad", in2, {(max (cellfun ("numel", in2)))}, "UniformOutput", false));
 out = vertcat (testcases.out);
 assert (isequaln (mpfr_vector_dot_d (0.5, in1, in2, 2), out));
***** test
 # Scalar evaluation
 testcases = testdata.NoSignal.double.sum_sqr_nearest;
 for testcase = [testcases]'
   assert (isequaln (...
     mpfr_vector_dot_d (0.5, testcase.in{1}, testcase.in{1}, 2), ...
     testcase.out));
 endfor
***** test
 # Vector evaluation
 testcases = testdata.NoSignal.double.sum_sqr_nearest;
 in1 = vertcat (testcases.in);
 in1 = cell2mat (cellfun ("postpad", in1, {(max (cellfun ("numel", in1)))}, "UniformOutput", false));
 out = vertcat (testcases.out);
 assert (isequaln (mpfr_vector_dot_d (0.5, in1, in1, 2), out));
8 tests, 8 passed, 0 known failure, 0 skipped
[src/__setround__.cc]
>>>>> /<<PKGBUILDDIR>>/src/__setround__.cc
***** xtest <Rounding-mode switches fail on your system; some matrix operations will be slower than expected>
  __setround__ (+inf);
  assert (1 + realmin > 1, true);
  assert (1 - realmin == 1, true);
  __setround__ (0.5);
***** xtest <Rounding-mode switches fail on your system; some matrix operations will be slower than expected>
  __setround__ (-inf);
  assert (1 + realmin == 1, true);
  assert (1 - realmin < 1, true);
  __setround__ (0.5);
***** test 
  __setround__ (0.5);
  assert (1 + realmin == 1, true);
  assert (1 - realmin == 1, true);
***** shared
  __setround__ (0.5);
3 tests, 3 passed, 0 known failure, 0 skipped
[src/mpfr_to_string_d.cc]
>>>>> /<<PKGBUILDDIR>>/src/mpfr_to_string_d.cc
***** test;
  [s, isexact] = mpfr_to_string_d (-inf, "decimal", .1);
  assert (s, {"0.1"});
  assert (isexact, false);
***** assert (mpfr_to_string_d (0, "exact hexadecimal", inf), {"inf"});
***** assert (mpfr_to_string_d (0, "exact hexadecimal", -inf), {"-inf"});
***** assert (mpfr_to_string_d (0, "exact hexadecimal", nan), {"nan"});
***** assert (mpfr_to_string_d (0, "exact hexadecimal", 0), {"0x0.0000000000000p+0"});
***** assert (mpfr_to_string_d (0, "exact hexadecimal", 2), {"0x1.0000000000000p+1"});
***** assert (mpfr_to_string_d (0, "exact hexadecimal", -1), {"-0x1.0000000000000p+0"});
***** assert (mpfr_to_string_d (0, "exact hexadecimal", pow2 (-1022)), {"0x1.0000000000000p-1022"});
***** assert (mpfr_to_string_d (0, "exact hexadecimal", pow2 (-1074)), {"0x0.0000000000001p-1022"});
9 tests, 9 passed, 0 known failure, 0 skipped
[src/mpfr_matrix_mul_d.cc]
>>>>> /<<PKGBUILDDIR>>/src/mpfr_matrix_mul_d.cc
***** test;
  [l, u] = mpfr_matrix_mul_d (magic (3), magic (3)', magic (3) + 1, magic (3)' + 1);
  assert (l, [101, 71, 53; 71, 83, 71; 53, 71, 101]);
  assert (u, [134, 104, 86; 104, 116, 104; 86, 104, 134]);
***** xtest;
  if (((exist ("__octave_config_info__") && ...
                __octave_config_info__.ENABLE_OPENMP) || ...
       (not (exist ("__octave_config_info__")) && ...
                  octave_config_info ("features").OPENMP)) ...
       && nproc ("overridable") > 1)
    ## OpenMP is enabled and may use more than one thread.
    ## We should observe speed-ups by that.
    A = vec (magic (2000));
    tic;
    mpfr_matrix_mul_d (A', A, A', A);
    time_per_element = toc;
    A = [A A];
    tic;
    mpfr_matrix_mul_d (A', A, A', A);
    time_per_element_parallel = toc / numel (ans);

    ## Ideally, the runtime would be cut in half (at least),
    ## however, there is an overhead, so let's be pessimistic and
    ## assume that the parallel execution is at least 20% faster.
    assert (time_per_element > 1.2 * time_per_element_parallel)
  endif
2 tests, 2 passed, 0 known failure, 0 skipped
Run tests in debian/check.m
Checking supplementary TST files ...
>>>>> processing crlibm.tst
***** test verify ("log", -inf, testdata.log_rd);
!!!!! test failed
ASSERT errors for:  assert (crlibm_function (fname, rnd, data.input),data.output)

  Location  |  Observed  |  Expected  |  Reason
    (3)       -744.4401    -744.4401     Abs err 1.1369e-13 exceeds tol 0 by 1e-13
shared variables   scalar structure containing the fields:

    testdata =

      scalar structure containing the fields:

        acos_rd =

          scalar structure containing the fields:

            input: 33x1 matrix
            output: 33x1 matrix

        acos_rn =

          scalar structure containing the fields:

            input: 110x1 matrix
            output: 110x1 matrix

        acos_ru =

          scalar structure containing the fields:

            input: 33x1 matrix
            output: 33x1 matrix

        acos_rz =

          scalar structure containing the fields:

            input: 96x1 matrix
            output: 96x1 matrix

        asin_rd =

          scalar structure containing the fields:

            input: 595x1 matrix
            output: 595x1 matrix

        asin_rn =

          scalar structure containing the fields:

            input: 748x1 matrix
            output: 748x1 matrix

        asin_ru =

          scalar structure containing the fields:

            input: 649x1 matrix
            output: 649x1 matrix

        asin_rz =

          scalar structure containing the fields:

            input: 633x1 matrix
            output: 633x1 matrix

        atan_rd =

          scalar structure containing the fields:

            input: 368x1 matrix
            output: 368x1 matrix

        atan_rn =

          scalar structure containing the fields:

            input: 5623x1 matrix
            output: 5623x1 matrix

        atan_ru =

          scalar structure containing the fields:

            input: 367x1 matrix
            output: 367x1 matrix

        atan_rz =

          scalar structure containing the fields:

            input: 494x1 matrix
            output: 494x1 matrix

        cos_rd =

          scalar structure containing the fields:

            input: 354x1 matrix
            output: 354x1 matrix

        cos_rn =

          scalar structure containing the fields:

            input: 10790x1 matrix
            output: 10790x1 matrix

        cos_ru =

          scalar structure containing the fields:

            input: 353x1 matrix
            output: 353x1 matrix

        cos_rz =

          scalar structure containing the fields:

            input: 444x1 matrix
            output: 444x1 matrix

        cosh_rd =

          scalar structure containing the fields:

            input: 495x1 matrix
            output: 495x1 matrix

        cosh_rn =

          scalar structure containing the fields:

            input: 549x1 matrix
            output: 549x1 matrix

        cosh_ru =

          scalar structure containing the fields:

            input: 495x1 matrix
            output: 495x1 matrix

        cosh_rz =

          scalar structure containing the fields:

            input: 566x1 matrix
            output: 566x1 matrix

        exp_rd =

          scalar structure containing the fields:

            input: 13x1 matrix
            output: 13x1 matrix

        exp_rn =

          scalar structure containing the fields:

            input: 4771x1 matrix
            output: 4771x1 matrix

        exp_ru =

          scalar structure containing the fields:

            input: 638x1 matrix
            output: 638x1 matrix

        exp_rz =

          scalar structure containing the fields:

            input: 718x1 matrix
            output: 718x1 matrix

        expm1_rd =

          scalar structure containing the fields:

            input: 32x1 matrix
            output: 32x1 matrix

        expm1_rn =

          scalar structure containing the fields:

            input: 239x1 matrix
            output: 239x1 matrix

        expm1_ru =

          scalar structure containing the fields:

            input: 34x1 matrix
            output: 34x1 matrix

        expm1_rz =

          scalar structure containing the fields:

            input: 427x1 matrix
            output: 427x1 matrix

        log_rd =

          scalar structure containing the fields:

            input: 28x1 matrix
            output: 28x1 matrix

        log_rn =

          scalar structure containing the fields:

            input: 1117x1 matrix
            output: 1117x1 matrix

        log_ru =

          scalar structure containing the fields:

            input: 28x1 matrix
            output: 28x1 matrix

        log_rz =

          scalar structure containing the fields:

            input: 53x1 matrix
            output: 53x1 matrix

        log10_rd =

          scalar structure containing the fields:

            input: 28x1 matrix
            output: 28x1 matrix

        log10_rn =

          scalar structure containing the fields:

            input: 52x1 matrix
            output: 52x1 matrix

        log10_ru =

          scalar structure containing the fields:

            input: 28x1 matrix
            output: 28x1 matrix

        log10_rz =

          scalar structure containing the fields:

            input: 40x1 matrix
            output: 40x1 matrix

        log1p_rd =

          scalar structure containing the fields:

            input: 8x1 matrix
            output: 8x1 matrix

        log1p_rn =

          scalar structure containing the fields:

            input: 227x1 matrix
            output: 227x1 matrix

        log1p_ru =

          scalar structure containing the fields:

            input: 8x1 matrix
            output: 8x1 matrix

        log1p_rz =

          scalar structure containing the fields:

            input: 343x1 matrix
            output: 343x1 matrix

        log2_rd =

          scalar structure containing the fields:

            input: 107x1 matrix
            output: 107x1 matrix

        log2_rn =

          scalar structure containing the fields:

            input: 104x1 matrix
            output: 104x1 matrix

        log2_ru =

          scalar structure containing the fields:

            input: 107x1 matrix
            output: 107x1 matrix

        log2_rz =

          scalar structure containing the fields:

            input: 113x1 matrix
            output: 113x1 matrix

        sin_rd =

          scalar structure containing the fields:

            input: 150x1 matrix
            output: 150x1 matrix

        sin_rn =

          scalar structure containing the fields:

            input: 10533x1 matrix
            output: 10533x1 matrix

        sin_ru =

          scalar structure containing the fields:

            input: 148x1 matrix
            output: 148x1 matrix

        sin_rz =

          scalar structure containing the fields:

            input: 186x1 matrix
            output: 186x1 matrix

        sinh_rd =

          scalar structure containing the fields:

            input: 356x1 matrix
            output: 356x1 matrix

        sinh_rn =

          scalar structure containing the fields:

            input: 416x1 matrix
            output: 416x1 matrix

        sinh_ru =

          scalar structure containing the fields:

            input: 356x1 matrix
            output: 356x1 matrix

        sinh_rz =

          scalar structure containing the fields:

            input: 415x1 matrix
            output: 415x1 matrix

        tan_rd =

          scalar structure containing the fields:

            input: 349x1 matrix
            output: 349x1 matrix

        tan_rn =

          scalar structure containing the fields:

            input: 5723x1 matrix
            output: 5723x1 matrix

        tan_ru =

          scalar structure containing the fields:

            input: 349x1 matrix
            output: 349x1 matrix

        tan_rz =

          scalar structure containing the fields:

            input: 465x1 matrix
            output: 465x1 matrix


56 tests, 55 passed, 0 known failure, 0 skipped
>>>>> processing meshgrid.tst
32 tests, 32 passed, 0 known failure, 0 skipped
Summary: 2389 tests, 2386 passed, 1 known failures, 0 skipped
Some tests failed.  Giving up...
make: *** [debian/rules:21: binary] Error 1
dpkg-buildpackage: error: debian/rules binary subprocess returned exit status 2
--------------------------------------------------------------------------------
Build finished at 2020-10-29T19:17:02Z

Finished
--------


+------------------------------------------------------------------------------+
| Cleanup                                                                      |
+------------------------------------------------------------------------------+

Purging /<<BUILDDIR>>
Not cleaning session: cloned chroot in use
E: Build failure (dpkg-buildpackage died)

+------------------------------------------------------------------------------+
| Summary                                                                      |
+------------------------------------------------------------------------------+

Build Architecture: amd64
Build Type: binary
Build-Space: 45236
Build-Time: 619
Distribution: unstable
Fail-Stage: build
Host Architecture: amd64
Install-Time: 46
Job: octave-interval_3.2.0-6
Machine Architecture: amd64
Package: octave-interval
Package-Time: 683
Source-Version: 3.2.0-6
Space: 45236
Status: attempted
Version: 3.2.0-6
--------------------------------------------------------------------------------
Finished at 2020-10-29T19:17:02Z
Build needed 00:11:23, 45236k disk space
E: Build failure (dpkg-buildpackage died)
DC-Status: Failed 684.249251512s
